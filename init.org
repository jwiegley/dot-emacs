:PROPERTIES:
:ID:       5152F6C3-5A47-45CA-9329-49002C64E282
:CREATED:  [2024-05-30 Thu 16:51]
:SLUG:     init
:END:
#+title: John Wiegley's .emacs file

#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

* Startup

** Set the garbage collector threshold, to avoid collections

#+begin_src emacs-lisp
(setq gc-cons-percentage 0.5
      gc-cons-threshold (* 128 1024 1024))
#+end_src

** Report time spent loading this module

#+begin_src emacs-lisp
(eval-and-compile
  (defconst emacs-start-time (current-time))

  (defun report-time-since-load (&optional suffix)
    (message "Loading init...done (%.3fs)%s"
             (float-time (time-subtract (current-time) emacs-start-time))
             suffix)))

(add-hook 'after-init-hook
          (lambda () (report-time-since-load " [after-init]"))
          t)
#+end_src

** Load =use-package= for all the declarations below

#+begin_src emacs-lisp
(eval-and-compile
  (defsubst emacs-path (path)
    (expand-file-name path user-emacs-directory))

  (setq package-enable-at-startup nil
        load-path
        (append (list (emacs-path "use-package"))
                (delete-dups load-path)
                (list (emacs-path "lisp")))))

(require 'use-package)

(let ((verbose (or nil init-file-debug)))
  (setq use-package-verbose verbose
        use-package-expand-minimally (not verbose)
        use-package-compute-statistics verbose
        debug-on-error verbose
        debug-on-message "finalizer failed"
        debug-on-quit verbose))

(eval-and-compile
  (defun use-package-normalize/:nix (_name-symbol _keyword args)
    args)

  (defun use-package-handler/:nix (name-symbol _keyword _arg rest state)
    (use-package-process-keywords name-symbol rest state))

  (add-to-list 'use-package-keywords :nix))
#+end_src

** During loading of this module, clear =file-name-handler-alist=

#+begin_src emacs-lisp
(defvar file-name-handler-alist-old file-name-handler-alist)

(setq file-name-handler-alist nil)

(add-hook 'after-init-hook
          (lambda () (setq file-name-handler-alist file-name-handler-alist-old)))
#+end_src

** Define the "data environment" for this instance of Emacs

#+begin_src emacs-lisp
(eval-and-compile
  (defconst emacs-environment (getenv "NIX_MYENV_NAME"))

  (let ((emacs-data-suffix
         (and (string= "emacsERC" emacs-environment) "alt")))

    (defconst alternate-emacs (string= emacs-data-suffix "alt"))

    (defconst user-data-directory
      (emacs-path (if emacs-data-suffix
                      (format "data-%s" emacs-data-suffix)
                    "data"))))

  (defun user-data (dir)
    (expand-file-name dir user-data-directory)))
#+end_src

** Disable warnings about obsolete functions when compiling

#+begin_src emacs-lisp
(eval-when-compile
  (dolist (sym '(cl-flet lisp-complete-symbol))
    (setplist sym (use-package-plist-delete
                   (symbol-plist sym) 'byte-obsolete-info))))
#+end_src

** Disable global eldoc-mode

#+begin_src emacs-lisp
(remove-hook 'after-change-major-mode-hook
             'global-eldoc-mode-enable-in-buffers)

(global-eldoc-mode -1)
#+end_src

** Garbage collect at the end of startup

#+begin_src emacs-lisp
(add-hook 'after-init-hook #'garbage-collect t)
#+end_src

** Define standard colors

#+begin_src emacs-lisp
(use-package john-wiegley-theme)
#+end_src

* Helper functions

** Quickly test if a host is available

#+begin_src emacs-lisp
(defun quickping (host)
  (= 0 (call-process "ping" nil nil nil "-c1" "-W50" "-q" host)))
#+end_src

** Push and pop window configurations

#+begin_src emacs-lisp
(eval-and-compile
  (defvar saved-window-configuration nil)

  (defun push-window-configuration ()
    (interactive)
    (push (current-window-configuration) saved-window-configuration))

  (defun pop-window-configuration ()
    (interactive)
    (let ((config (pop saved-window-configuration)))
      (if config
          (set-window-configuration config)
        (if (> (length (window-list)) 1)
            (delete-window)
          (bury-buffer)))))
#+end_src

** Lookup a password using =auth-source=

#+begin_src emacs-lisp
(eval-when-compile
  (require 'auth-source)
  (require 'auth-source-pass))

(defun lookup-password (host user port)
  (require 'auth-source)
  (require 'auth-source-pass)
  (let ((auth (auth-source-search :host host :user user :port port)))
    (if auth
        (let ((secretf (plist-get (car auth) :secret)))
          (if secretf
              (funcall secretf)
            (error "Auth entry for %s@%s:%s has no secret!"
                   user host port)))
      (error "No auth entry found for %s@%s:%s" user host port))))
#+end_src

** info

#+begin_src emacs-lisp
(use-package info :autoload Info-goto-node)
#+end_src

*** info-look

#+begin_src emacs-lisp
(use-package info-look :autoload info-lookup-add-help)
#+end_src

** add-all-to-list

#+begin_src emacs-lisp
(eval-and-compile
  (defun add-all-to-list (var &rest elems)
    (dolist (elem (reverse elems))
      (add-to-list var elem))))
#+end_src

* Libraries

** org-constants

#+begin_src emacs-lisp
(use-package org-constants)
#+end_src

** COMMENT aio

#+begin_src emacs-lisp
(use-package aio :defer t)
#+end_src

** async

#+begin_src emacs-lisp
(use-package async :defer t)
#+end_src

** uuidgen

#+begin_src emacs-lisp
(use-package uuidgen
  :functions (uuidgen-1))
#+end_src

** COMMENT crux

#+begin_src emacs-lisp
(use-package crux
  :bind ("C-c e i" . crux-find-user-init-file))
#+end_src

** dash

#+begin_src emacs-lisp
(use-package dash :defer t)
#+end_src

** diminish

#+begin_src emacs-lisp
(use-package diminish :defer t)
#+end_src

** el-job

#+begin_src emacs-lisp
(use-package el-job :defer t)
#+end_src

** s

#+begin_src emacs-lisp
(use-package s :defer t)
#+end_src

** f

#+begin_src emacs-lisp
(use-package f :defer t)
#+end_src

** parse-csv

#+begin_src emacs-lisp
(use-package parse-csv :defer t)
#+end_src

** llama

#+begin_src emacs-lisp
(use-package llama :defer t)
#+end_src

** pg

#+begin_src emacs-lisp
(use-package pg :defer t)
#+end_src

** quick-peek

#+begin_src emacs-lisp
(use-package quick-peek :defer t)
#+end_src

** language-id

#+begin_src emacs-lisp
(use-package language-id :defer t)
#+end_src

** timeout

#+begin_src emacs-lisp
(use-package timeout
  :commands (timeout-throttle! timeout-debounce!))
#+end_src

** web

#+begin_src emacs-lisp
(use-package web :defer t)
#+end_src

* Packages (pre-requisities)

** epg

#+begin_src emacs-lisp
(use-package epg
  :defer t
  :config
  (put 'epg-gpg-program 'customized-value t))
#+end_src

** emacs

This pseudo-package represents Emacs itself, and configures many variables and
advices that relate to core functionality that isn't considered a "package"
unto itself.

#+begin_src emacs-lisp
(use-package emacs
  :nix nil
  :demand t
  :bind*
  ;; ("<C-return>" . other-window)   ; use avy
  ("<C-tab>"    . ignore)
  :bind ("A-y" . yank)
  :custom
  ;; C source code
  (auto-hscroll-mode 'current-line)
  (create-lockfiles nil)
  (delete-by-moving-to-trash #'system-move-file-to-trash)
  (enable-recursive-minibuffers t)
  (fill-column 78)
  (history-delete-duplicates t)
  (history-length 200)
  (load-prefer-newer t)
  (line-spacing 1)
  (menu-bar-mode nil)
  (message-log-max 16384)
  (native-comp-jit-compilation nil)
  (redisplay-dont-pause t)
  (tool-bar-mode nil)
  (undo-limit 800000)
  (user-full-name "John Wiegley")
  (visible-bell t)
  (x-stretch-cursor t)

  ;; ;; Settings for the Cocoa port
  ;; (ns-command-modifier 'meta)
  ;; (ns-right-command-modifier 'meta)
  ;; (ns-option-modifier 'super)
  ;; (ns-right-option-modifier 'super)
  ;; (ns-function-modifier 'hyper)

  ;; Settings for the Emacs Mac-port
  (mac-control-modifier 'alt)
  (mac-right-control-modifier 'control)
  (mac-pass-command-to-system nil)
  (mac-command-modifier 'meta)
  (mac-right-command-modifier 'meta)
  (mac-option-modifier 'super)
  (mac-right-option-modifier 'super)

  (frame-title-format
   '(:eval
     (concat
      (if buffer-file-name default-directory "%b")
      "    "
      (number-to-string
       (cdr
        (assq 'width
              (frame-parameters))))
      "x"
      (number-to-string
       (cdr
        (assq 'height
              (frame-parameters)))))))

  (completion-cycle-threshold 7)
  (completion-ignored-extensions
   '(".a"
     ".aux"
     ".bbl"
     ".bin"
     ".blg"
     ".class"
     ".cp"
     ".cps"
     ".elc"
     ".fmt"
     ".fn"
     ".fns"
     ".git/"
     ".glo"
     ".glob"
     ".gmo"
     ".hg/"
     ".idx"
     ".ky"
     ".kys"
     ".la"
     ".lib"
     ".ln"
     ".lo"
     ".lof"
     ".lot"
     ".mem"
     ".mo"
     ".o"
     ".pg"
     ".pgs"
     ".pyc"
     ".pyo"
     ".so"
     ".tfm"
     ".toc"
     ".tp"
     ".tps"
     ".v.d"
     ".vio"
     ".vo" ".vok" ".vos"
     ".vr"
     ".vrs"
     "~"))

  ;; startup.el
  (auto-save-list-file-prefix (user-data "auto-save-list/.saves-"))
  (inhibit-startup-echo-area-message "johnw")
  (inhibit-startup-screen t)
  (initial-buffer-choice t)
  (initial-major-mode 'fundamental-mode)
  (initial-scratch-message "")
  (user-mail-address "johnw@newartisans.com")

  ;; advice.el
  (ad-redefinition-action 'accept)

  ;; files.el
  (auto-save-file-name-transforms '(("\\`/[^/]*:.*" "/tmp" t)))
  (backup-directory-alist '(("." . "~/.local/share/emacs/backups")))
  (confirm-kill-emacs 'yes-or-no-p)
  (delete-old-versions t)
  (directory-free-space-args "-kh")
  (large-file-warning-threshold nil)
  (save-abbrevs 'silently)
  (trash-directory "~/.Trash")
  (version-control t)

  ;; simple.el
  (backward-delete-char-untabify-method 'untabify)
  (column-number-mode t)
  (indent-tabs-mode nil)
  (kill-do-not-save-duplicates t)
  (kill-ring-max 500)
  (kill-whole-line t)
  (line-number-mode t)
  (mail-user-agent 'gnus-user-agent)
  (next-line-add-newlines nil)
  (save-interprogram-paste-before-kill t)

  ;; bytecomp.el
  (byte-compile-verbose nil)

  ;; prog-mode.el
  (prettify-symbols-unprettify-at-point 'right-edge)

  ;; scroll-bar.el
  (scroll-bar-mode nil)

  ;; paragraphs.el
  (sentence-end-double-space nil)

  ;; paren.el
  (show-paren-delay 0)

  ;; window.el
  (same-window-buffer-names
   '("*eshell*"
     "*shell*"
     "*mail*"
     "*inferior-lisp*"
     "*ielm*"
     "*scheme*"))
  (switch-to-buffer-preserve-window-point t)

  ;; warnings.el
  (warning-minimum-log-level :error)

  ;; frame.el
  (window-divider-default-bottom-width 1)
  (window-divider-default-places 'bottom-only)
  (blink-cursor-mode nil)

  ;; nsm.el
  (nsm-settings-file (user-data "network-security.data"))

  ;; facemenu.el
  (list-colors-sort 'hsv)

  :custom-face
  (cursor ((t (:background "hotpink"))))
  (highlight ((t (:background "blue4"))))
  (minibuffer-prompt ((t (:foreground "grey80"))))
  (mode-line-inactive ((t (:background "grey50"))))
  (nobreak-space ((t nil)))
  (variable-pitch ((t (:height 1.2 :family "Bookerly"))))

  :init
  (setq disabled-command-function nil) ;; enable all commands

  :config
  (add-hook 'after-save-hook
            #'executable-make-buffer-file-executable-if-script-p)

  (define-key input-decode-map [?\C-m] [C-m])

  ;; Setup keymaps that are bound into by many declarations below.

  (eval-and-compile
    (mapc (lambda (entry)
            (define-prefix-command (cdr entry))
            (bind-key (car entry) (cdr entry)))
          '(("C-'"   . my-ctrl-quote-map)
            ("<C-m>" . my-ctrl-m-map)
            ("C-h e" . my-emacs-lisp-help-map)
            ("C-c b" . my-bookmarks-bibliography-map)
            ("C-c e" . my-emacs-lisp-map)
            ("C-c m" . my-ctrl-c-m-map)
            ("C-c n" . my-ctrl-c-n-map)
            ("C-c t" . my-multi-term-map)
            ("C-c w" . my-web-map)
            ("C-c y" . my-yasnippet-map)
            ("C-c H" . my-highlight-map)
            ("C-c N" . my-ctrl-c-N-map)))))
#+end_src

** hydra

#+begin_src emacs-lisp
(use-package hydra
  :bind
  ("C-h e a" . my/hydra-apropos/body)
  :config
  (defhydra my/hydra-apropos (:color blue :hint nil)
  "
_a_propos        _c_ommand
_d_ocumentation  _l_ibrary
_v_ariable       _u_ser-option
^ ^          valu_e_"
  ("a" apropos)
  ("d" apropos-documentation)
  ("v" apropos-variable)
  ("c" apropos-command)
  ("l" apropos-library)
  ("u" apropos-user-option)
  ("e" apropos-value)))
#+end_src

*** pretty-hydra

#+begin_src emacs-lisp
(use-package pretty-hydra
  :demand t
  :functions (pretty-hydra-define))
#+end_src

*** major-mode-hydra

#+begin_src emacs-lisp
(use-package major-mode-hydra
  :bind ("M-SPC" . major-mode-hydra)
  :functions (major-mode-hydra-define))
#+end_src

* Packages

** abbrev

#+begin_src emacs-lisp
(use-package abbrev
  :nix nil
  :diminish
  :hook
  ((text-mode prog-mode) . abbrev-mode)
  (expand-load
   . (lambda ()
       (add-hook 'expand-expand-hook #'indent-according-to-mode)
       (add-hook 'expand-jump-hook #'indent-according-to-mode)))
  :custom
  (abbrev-file-name (emacs-path "abbrevs.el"))
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
#+end_src

** ace-window

#+begin_src emacs-lisp
(use-package ace-window
  :bind* ("<C-return>" . ace-window)
  :custom
  (aw-dispatch-when-more-than 3)
  (aw-scope 'frame))
#+end_src

** agda-input

#+begin_src emacs-lisp
(use-package agda-input
  :custom
  (agda-input-tweak-all
   '(agda-input-compose (agda-input-prepend "\\") (agda-input-nonempty)))
  (agda-input-user-translations
   '(("^"      "^")
     ("nat"    "⟹")
     ("next"   "◯")
     ("always" "□")
     ("aly"    "□")
     ("even"   "◇")
     ("evn"    "◇")
     ("for"    "△")
     ("mer"    "▽")
     ("iso"    "≅")
     ("miso"   "≃")
     ("diag"   "∆")
     ("whl"    "⊳")
     ("whr"    "⊲"))))
#+end_src

** aggressive-indent

=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode]] is a minor mode that keeps your code always indented.
It reindents after every change, making it more reliable than
=electric-indent-mode=.

#+begin_src emacs-lisp
(use-package aggressive-indent
  :diminish
  :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src

** aider

#+begin_src emacs-lisp
(use-package aider
  :bind
  ("C-c A" . aider-transient-menu)
  :custom
  (aider-args `("-c" "~/.config/aider/config.yaml"
                "--model" "openai/hera/Qwen3-Coder-480B-A35B-Instruct"
                "--openai-api-base" "http://vulcan/litellm/v1"
                "--api-key" ,(concat "openai="
                                     (auth-source-pass-get 'secret "vulcan"))
                "--no-show-model-warnings"
                "--no-auto-accept-architect"
                "--no-auto-commits"
                "--no-git-ignore"))
  :config
  ;; (aider-magit-setup-transients)
  )
#+end_src

** alert

#+begin_src emacs-lisp
(use-package alert
  :load-path "lisp/alert"
  :autoload (alert alert-add-rule)
  :custom
  ;; (alert-default-style 'fringe)
  (alert-default-style 'osx-notifier)
  (alert-notifier-command
   "~/Applications/Home Manager Apps/terminal-notifier.app/Contents/MacOS/terminal-notifier"))
#+end_src

** align

#+begin_src emacs-lisp
(use-package align
  :nix nil
  :commands align
  :bind (("M-["   . align-code)
         ("C-c [" . align-regexp))
  :custom
  (align-c++-modes '(csharp-mode c++-mode c-mode java-mode))
  (align-to-tab-stop nil)
  :preface
  (defun align-code (beg end &optional arg)
    (interactive "rP")
    (if (null arg)
        (align beg end)
      (let ((end-mark (copy-marker end)))
        (indent-region beg end-mark nil)
        (align beg end-mark)))))
#+end_src

** COMMENT all-the-icons

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

** COMMENT anki-editor

#+begin_src emacs-lisp
(use-package anki-editor
  :commands anki-editor-submit)
#+end_src

** ansi-color

#+begin_src emacs-lisp
(use-package ansi-color
  :nix nil
  :defer t
  :custom
  (ansi-color-names-vector
   ["black" "red" "green" "brown" "blue" "magenta" "blue" "white"]))
#+end_src

** aria2

#+begin_src emacs-lisp
(use-package aria2
  :commands
  (aria2-downloads-list
   aria2-add-file
   aria2-add-uris))
#+end_src

** ascii

#+begin_src emacs-lisp
(use-package ascii
  :bind ("C-c e A" . ascii-toggle)
  :commands (ascii-on ascii-off)
  :preface
  (defun ascii-toggle ()
    (interactive)
    (if ascii-display
        (ascii-off)
      (ascii-on))))
#+end_src

** auth-source-pass

#+begin_src emacs-lisp
(use-package auth-source-pass
  :preface
  (defvar auth-source-pass--cache (make-hash-table :test #'equal))

  (defun auth-source-pass--reset-cache ()
    (setq auth-source-pass--cache (make-hash-table :test #'equal)))

  (defun auth-source-pass--read-entry (entry)
    "Return a string with the file content of ENTRY."
    (run-at-time 45 nil #'auth-source-pass--reset-cache)
    (let ((cached (gethash entry auth-source-pass--cache)))
      (or cached
          (puthash
           entry
           (with-temp-buffer
             (insert-file-contents (expand-file-name
                                    (format "%s.gpg" entry)
                                    (getenv "PASSWORD_STORE_DIR")))
             (buffer-substring-no-properties (point-min) (point-max)))
           auth-source-pass--cache))))

  (defun auth-source-pass-entries ()
    "Return a list of all password store entries."
    (let ((store-dir (getenv "PASSWORD_STORE_DIR")))
      (mapcar
       (lambda (file) (file-name-sans-extension (file-relative-name file store-dir)))
       (directory-files-recursively store-dir "\.gpg$"))))
  :config
  (auth-source-pass-enable))
#+end_src

** autorevert

#+begin_src emacs-lisp
(use-package autorevert
  :custom
  (auto-revert-use-notify nil)
  :config
  (global-auto-revert-mode t))
#+end_src

** avy

[[https://github.com/abo-abo/avy][avy]] is a GNU Emacs package for jumping to visible text using a char-based
decision tree.

#+begin_src emacs-lisp
(use-package avy
  :bind* (("<S-return>" . avy-goto-char-timer)
          ("C-." . avy-goto-char-timer))
  :custom
  (avy-case-fold-search t)
  (avy-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s))
  (avy-timeout-seconds 0.3)
  :functions (avy-setup-default)
  :preface
  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-copy-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (cl-destructuring-bind (start . end)
          (bounds-of-thing-at-point 'line)
        (copy-region-as-kill start end)))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-yank-whole-line (pt)
    (avy-action-copy-whole-line pt)
    (save-excursion (yank))
    t)

  (defun avy-action-teleport-whole-line (pt)
    (avy-action-kill-whole-line pt)
    (save-excursion (yank)) t)

  (defun avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char pt))
  :config
  (avy-setup-default)

  (define-key isearch-mode-map (kbd "C-.") 'avy-isearch)
  (define-key isearch-mode-map (kbd "<S-return>") 'avy-isearch)

  (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
        (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line)

  (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
        (alist-get ?w avy-dispatch-alist) 'avy-action-copy
        (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line
        (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line)

  (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
        (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line)

  (setf (alist-get ?  avy-dispatch-alist) 'avy-action-mark-to-char))
#+end_src

*** avy-embark

Prompt the user for an action and perform it.

The targets of the action are chosen by =embark-target-finders=. By default, if
called from a minibuffer the target is the top completion candidate. When
called from a non-minibuffer buffer there can multiple targets and you can
cycle among them by using =embark-cycle= (which is bound by default to the same
key binding =embark-act= is, but see =embark-cycle-key=).

This command uses =embark-prompter= to ask the user to specify an action, and
calls it injecting the target at the first minibuffer prompt.

If you call this from the minibuffer, it can optionally quit the minibuffer.
The variable =embark-quit-after-action= controls whether calling =embark-act= with
nil ARG quits the minibuffer, and if ARG is non-nil it will do the opposite.
Interactively, ARG is the prefix argument.

If instead you call this from outside the minibuffer, the first ARG targets
are skipped over (if ARG is negative the skipping is done by cycling
backwards) and cycling starts from the following target.

#+begin_src emacs-lisp
(use-package avy-embark
  :no-require t
  :after avy
  :preface
  (defun avy-action-embark (pt)
    (require 'embark)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
  :config
  (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark))
#+end_src

**** avy-embark-collect

This packages provides two commands, =avy-embark-collect-choose= and
=avy-embark-collect-act=, that use avy to jump to an Embark Collect entry and
choose it or act on it, respectively.

#+begin_src emacs-lisp
(use-package avy-embark-collect
  :after (avy embark))
#+end_src

*** avy-flyspell

#+begin_src emacs-lisp
(use-package avy-flyspell
  :no-require t
  :after avy
  :functions (flyspell-auto-correct-word)
  :preface
  (defun avy-action-flyspell (pt)
    (save-excursion
      (goto-char pt)
      (when (require 'flyspell nil t)
        (flyspell-auto-correct-word)))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)
  :config
  (setf (alist-get ?\; avy-dispatch-alist) 'avy-action-flyspell))
#+end_src

*** avy-zap

#+begin_src emacs-lisp
(use-package avy-zap
  :bind (("M-z" . avy-zap-up-to-char-dwim)
         ("M-Z" . avy-zap-to-char-dwim)))
#+end_src

*** lasgun

[[https://github.com/aatmunbaxi/lasgun.el][lasgun.el]] (lays-gun) provides avy-backed, actionable placement of multiple
inactive marks in the current buffer. Once these marks have been collected,
you can act on the marks in bulk, without disturbing your point (with some
obvious exceptions). If this sounds familiar to how avy works, it is! lasgun
simply generalizes the =Filter -> Select -> Act= from avy to one that works on
multiple selected candidates.

#+begin_src emacs-lisp
(use-package lasgun
  :after avy
  :commands (lasgun-make-multiple-cursors)
  :preface
  (defun ab/lasgun-goto-primary-make-cursors (pt)
    (goto-char pt)
    (lasgun-make-multiple-cursors
     (xor lasgun-pop-before-make-multiple-cursors nil)))
  :init
  (setf (alist-get ?c avy-dispatch-alist)
	'ab/lasgun-goto-primary-make-cursors))
#+end_src

** COMMENT awesome-tray

#+begin_src emacs-lisp
(use-package awesome-tray
  :config
  (awesome-tray-mode 1))
#+end_src

** COMMENT backup-each-save

Ever wish to go back to an older saved version of a file? Then this package is
for you. This package copies every file you save in Emacs to a backup
directory tree (which mirrors the tree structure of the filesystem), with a
timestamp suffix to make multiple saves of the same file unique. Never lose
old saved versions again.

#+begin_src emacs-lisp
(use-package backup-each-save
  :commands backup-each-save
  :custom
  (make-backup-file-name-function 'my-make-backup-file-name)
  (backup-each-save-filter-function 'backup-each-save-filter)
  (backup-enable-predicate 'my-dont-backup-files-p)
  :preface
  (defun my-make-backup-file-name (file)
    (make-backup-file-name-1 (expand-file-name (file-truename file))))

  (defun backup-each-save-filter (filename)
    (not (string-match
          (concat "\\(^/tmp\\|\\.emacs\\.d/data\\(-alt\\)?/"
                  "\\|\\.newsrc\\(\\.eld\\)?\\|"
                  "\\(archive/sent/\\|recentf\\`\\)\\)")
          filename)))

  (defun my-dont-backup-files-p (filename)
    (unless (string-match filename "\\(archive/sent/\\|recentf\\`\\)")
      (normal-backup-enable-predicate filename)))
  :hook (after-save . backup-each-save))
#+end_src

** COMMENT backup-walker

#+begin_src emacs-lisp
(use-package backup-walker
  :commands backup-walker-start)
#+end_src

** COMMENT beacon

#+begin_src emacs-lisp
(use-package beacon
  :diminish
  :commands beacon-mode)
#+end_src

** biblio

[[https://github.com/cpitclaudel/biblio.el][biblio.el]] makes it easy to browse and gather bibliographic references and
publications from various sources, by keywords or by DOI. References are
automatically fetched from well-curated sources, and formatted as BibTeX.

#+begin_src emacs-lisp
(use-package biblio
  :commands biblio-lookup)
#+end_src

** bind-key

#+begin_src emacs-lisp
(use-package bind-key
  :defer t
  :custom
  (bind-key-segregation-regexp
   "\\`\\(\\(C-[chx.] \\|M-[gso] \\)\\([CM]-\\)?\\|.+-\\)"))
#+end_src

** bm

#+begin_src emacs-lisp
(use-package bm
  :unless alternate-emacs
  :bind (("C-c b b" . bm-toggle)
         ("C-c b n" . bm-next)
         ("C-c b p" . bm-previous))
  :commands (bm-repository-load
             bm-buffer-save
             bm-buffer-save-all
             bm-buffer-restore)
  :hook
  (after-init        . bm-repository-load)
  (find-file         . bm-buffer-restore)
  (after-revert      . bm-buffer-restore)
  (kill-buffer       . bm-buffer-save)
  (after-save        . bm-buffer-save)
  (vc-before-checkin . bm-buffer-save)
  (kill-emacs        . (lambda ()
                         (bm-buffer-save-all)
                         (bm-repository-save)))
  :custom
  (bm-buffer-persistence t)
  (bm-cycle-all-buffers t)
  (bm-highlight-style 'bm-highlight-only-fringe)
  (bm-in-lifo-order t)
  (bm-repository-file (user-data "bm-repository")))
#+end_src

** bookmark

#+begin_src emacs-lisp
(use-package bookmark
  ;; :demand t
  :bind
  ("<f4>" . (lambda () (interactive) (bookmark-set "SAVED")))
  ("<f1>" . (lambda () (interactive) (bookmark-jump "SAVED")))
  :custom
  (bookmark-default-file "~/doc/bookmarks"))
#+end_src

*** COMMENT bookmark+

#+begin_src emacs-lisp
(use-package bookmark+
  :nix bookmark-plus
  :after bookmark
  :demand t
  :commands (bmkp-jump-dired)
  :bind (:map bookmark-bmenu-mode-map
              ("n" . next-line)
              ("p" . previous-line))
  :custom
  (bmkp-bmenu-commands-file (user-data "bmk-bmenu-commands.el"))
  (bmkp-bmenu-state-file (user-data "bmk-bmenu-state.el"))
  (bmkp-crosshairs-flag nil)
  (bmkp-last-as-first-bookmark-file bookmark-default-file))
#+end_src

** COMMENT browse-at-remote

#+begin_src emacs-lisp
(use-package browse-at-remote
  :bind ("C-c B" . browse-at-remote))
#+end_src

** browse-kill-ring

#+begin_src emacs-lisp
(use-package browse-kill-ring
  :commands browse-kill-ring)
#+end_src

** browse-url

#+begin_src emacs-lisp
(use-package browse-url
  :defer t
  :custom
  (browse-url-browser-function 'browse-url-default-macosx-browser))
#+end_src

** COMMENT buffer-terminator

The buffer-terminator package automatically kills buffers to help maintain a
clean and efficient workspace, while also improving Emacs' performance by
reducing the number of open buffers, thereby decreasing the number of active
modes, timers, and other processes associated with those buffers.

Activating =(buffer-terminator-mode)= terminates all buffers that have been
inactive for longer than the duration specified by
=buffer-terminator-inactivity-timeout= (default: 30 minutes). It checks every
=buffer-terminator-interval= (default: 10 minutes) to determine if a buffer
should be terminated.

#+begin_src emacs-lisp
(use-package buffer-terminator
  :custom
  (buffer-terminator-verbose t)
  :config
  (add-to-list 'buffer-terminator-rules-alist
               (cons 'keep-buffer-name-regexp
                     (rx (or "*scratch*"
                             "*Messages*"
                             "*server*"
                             "*Group*"
                             "*Org Agenda*"
                             "*GPTel Chat*"
                             (seq bol " *Minibuf-" (zero-or-more nonl) "*" eol)
                             (seq bol "*Summary")
                             (seq bol "*gptel-aibo:")
                             (seq bol "*Article")
                             (seq bol "#")))))
  (buffer-terminator-mode 1))
#+end_src

** COMMENT bufler

#+begin_src emacs-lisp
(use-package bufler
  :bind ("C-x C-B" . bufler))
#+end_src

** burly

#+begin_src emacs-lisp
(use-package burly
  :commands (burly-bookmark-windows burly-open-bookmark))
#+end_src

** COMMENT c-includes

#+begin_src emacs-lisp
(use-package c-includes
  :nix nil
  :commands c-includes
  :after cc-mode
  :bind (:map c-mode-base-map
              ("C-c C-i"  . c-includes-current-file)))
#+end_src

** calc

#+begin_src emacs-lisp
(use-package calc
  :nix nil
  :custom
  (calc-kill-line-numbering nil))
#+end_src

*** calc-units

#+begin_src emacs-lisp
(use-package calc-units
  :nix nil
  :after calc
  :custom
  (calc-ensure-consistent-units t)
  (math-additional-units
   '((b    nil          "Bit")
     (B    "8 * b"      "Byte")
     (bps  "b / s"      "Bit per second")
     (Bps  "B / s"      "Bytes per second")
     (gpm  "gal / min"  "Gallons per minute")
     (cfm  "ft^3 / min" "Cubic feet per minute")))
  (math-units-table nil)
  :config
  (setf (symbol-function 'calc-convert-units)
        (symbol-function 'calc-convert-exact-units))

  (defalias 'calcFunc-uconv 'math-convert-units)
  (defalias 'calcFunc-strip 'math-remove-units))
#+end_src

*** literate-calc-mode

#+begin_src emacs-lisp
(use-package literate-calc-mode
  :commands (literate-calc-minor-mode
             literate-calc-kill-result)
  :diminish literate-calc-minor-mode
  :custom
  (literate-calc-usimplify-results t))
#+end_src

** calendar

#+begin_src emacs-lisp
(use-package calendar
  :nix nil
  :custom
  (calendar-mark-holidays-flag t)
  (calendar-date-style 'iso))
#+end_src

*** cal-dst

#+begin_src emacs-lisp
(use-package cal-dst
  :custom
  (calendar-daylight-time-zone-name "PDT")
  (calendar-standard-time-zone-name "PST")
  (calendar-time-zone -480))
#+end_src

*** solar

#+begin_src emacs-lisp
(use-package solar
  :custom
  (calendar-latitude 38.559979)
  (calendar-longitude -121.417465))
#+end_src

*** bahai-calendar

#+begin_src emacs-lisp
(use-package bahai-calendar
  :no-require t
  :after calendar
  :preface
  (defconst first-year-in-list 172)

  (defconst naw-ruz
    '((3 21 2015)
      (3 20 2016)
      (3 20 2017)
      (3 21 2018)
      (3 21 2019)
      (3 20 2020)
      (3 20 2021)
      (3 21 2022)
      (3 21 2023)
      (3 20 2024)
      (3 20 2025)
      (3 21 2026)
      (3 21 2027)
      (3 20 2028)
      (3 20 2029)
      (3 20 2030)
      (3 21 2031)
      (3 20 2032)
      (3 20 2033)
      (3 20 2034)
      (3 21 2035)
      (3 20 2036)
      (3 20 2037)
      (3 20 2038)
      (3 21 2039)
      (3 20 2040)
      (3 20 2041)
      (3 20 2042)
      (3 21 2043)
      (3 20 2044)
      (3 20 2045)
      (3 20 2046)
      (3 21 2047)
      (3 20 2048)
      (3 20 2049)
      (3 20 2050)
      (3 21 2051)
      (3 20 2052)
      (3 20 2053)
      (3 20 2054)
      (3 21 2055)
      (3 20 2056)
      (3 20 2057)
      (3 20 2058)
      (3 20 2059)
      (3 20 2060)
      (3 20 2061)
      (3 20 2062)
      (3 20 2063)
      (3 20 2064))
    "The days when Naw-Rúz begins, for the next fifty years.")

  (defconst days-of-há
    '(4 4 5 4 4 4 5 4 4 4 5 4 4 4 4 5 4 4 4 5 4 4 4 5 4
        4 4 5 4 4 4 5 4 4 4 5 4 4 4 5 4 4 4 4 5 4 4 4 5 4))

  (defconst bahai-months
    '("Bahá"      ; 1
      "Jalál"     ; 2
      "Jamál"     ; 3
      "‘Aẓamat"   ; 4
      "Núr"       ; 5
      "Raḥmat"    ; 6
      "Kalimát"   ; 7
      "Kamál"     ; 8
      "Asmá’"     ; 9
      "‘Izzat"    ; 10
      "Mashíyyat" ; 11
      "‘Ilm"      ; 12
      "Qudrat"    ; 13
      "Qawl"      ; 14
      "Masá’il"   ; 15
      "Sharaf"    ; 16
      "Sulṭán"    ; 17
      "Mulk"      ; 18
      "‘Alá’"     ; 19
      ))

  (eval-when-compile
    (require 'cal-julian)
    (require 'diary-lib))

  (defun bahai-date (month day &optional bahai-year)
    (require 'cal-julian)
    (require 'diary-lib)
    (let* ((greg-year (if bahai-year
                          (+ 1844 (1- bahai-year))
                        (nth 2 (calendar-current-date))))
           (year (1+ (- greg-year 1844)))
           (first-day (cl-find-if (lambda (x) (= greg-year (nth 2 x)))
                                  naw-ruz))
           (greg-base (calendar-julian-to-absolute first-day))
           (hdays (nth (- year first-year-in-list) days-of-há))
           (offset (+ (1- day) (* 19 (1- month))
                      (if (= month 19)
                          hdays
                        0)))
           (greg-date (calendar-julian-from-absolute (+ greg-base offset))))
      (apply #'diary-date greg-date))))
#+end_src

*** holidays

#+begin_src emacs-lisp
(use-package holidays
  :defer t
  :custom
  (holiday-bahai-holidays nil)
  (holiday-hebrew-holidays nil))
#+end_src

** COMMENT centaur-tabs

#+begin_src emacs-lisp
(use-package centaur-tabs
  :demand t
  :config
  (centaur-tabs-mode t)
  :bind
  ("C-<prior>" . centaur-tabs-backward)
  ("C-<next>" . centaur-tabs-forward))
#+end_src

** COMMENT centered-cursor-mode

Makes the cursor stay vertically in a defined position (usually centered). The
vertical position can be altered:

| =C-M--= | =ccm-vpos-up=       |
| =C-M-+= | =ccm-vpos-down=     |
| =C-M-== | =ccm-vpos-down=     |
| =C-M-0= | =ccm-vpos-recenter= |

#+begin_src emacs-lisp
(use-package centered-cursor-mode
  :commands centered-cursor-mode)
#+end_src

** COMMENT citre

[[https://github.com/universal-ctags/citre][Citre]] started out as a tool utilizing tags files (in the ctags format). Now it
is a superior code reading and auto-completion tool with pluggable backend
design. The built-in backends include:

- A tags file (in ctags format) backend.
- A GNU global backend.
- An xref adapter that transforms any xref backend into Citre backend.
- Eglot backend, based on the xref adapter.

The tools offered by Citre are:

- =completion-at-point= , xref and imenu integration.
- =citre-jump=: A =completing-read= UI for jumping to definition/references.
- =citre-peek= : A powerful code reading tool that lets you go down the rabbit
  hole without leaving current buffer.

#+begin_src emacs-lisp
(use-package citre-config
  :nix citre
  :bind (("C-x c j" . citre-jump)
         ("C-x c J" . citre-jump-back)
         ("C-x c p" . citre-ace-peek)
         ("C-x c u" . citre-update-this-tags-file))
  :custom
  (citre-use-project-root-when-creating-tags t
   citre-prompt-language-for-ctags-command t
   citre-auto-enable-citre-mode-modes '(prog-mode)))
#+end_src

** COMMENT cl-info

#+begin_src emacs-lisp
(use-package cl-info
  :nix nil)
#+end_src

** col-highlight

#+begin_src emacs-lisp
(use-package col-highlight
  :commands column-highlight-mode)
#+end_src

** color-moccur

#+begin_src emacs-lisp
(use-package color-moccur
  :commands (isearch-moccur isearch-all isearch-moccur-all)
  :bind (("M-s O" . moccur)
         :map isearch-mode-map
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
  :custom
  (moccur-following-mode-toggle nil))
#+end_src

** color-theme

#+begin_src emacs-lisp
(use-package color-theme
  :no-require t
  :init
  (deftheme midnight
    "midnight theme")

  (custom-theme-set-faces
   'midnight

   '(default ((t (:background "black" :foreground "grey85"))))
   '(mouse ((t (:foreground "grey85"))))
   '(cursor ((t (:background "grey85"))))

   '(font-lock-comment-face ((t (:italic t :foreground "grey60"))))
   '(font-lock-string-face ((t (:foreground "Magenta"))))
   '(font-lock-keyword-face ((t (:foreground "Cyan"))))
   '(font-lock-warning-face ((t (:bold t :foreground "Pink"))))
   '(font-lock-constant-face ((t (:foreground "OliveDrab"))))
   '(font-lock-type-face ((t (:foreground "DarkCyan"))))
   '(font-lock-variable-name-face ((t (:foreground "DarkGoldenrod"))))
   '(font-lock-function-name-face ((t (:foreground "SlateBlue"))))
   '(font-lock-builtin-face ((t (:foreground "SkyBlue"))))
   '(highline-face ((t (:background "grey12"))))
   '(setnu-line-number-face ((t (:background "Grey15" :foreground "White" :bold t))))
   '(show-paren-match-face ((t (:background "grey30"))))
   '(region ((t (:background "grey15"))))
   '(highlight ((t (:background "blue"))))
   '(secondary-selection ((t (:background "navy"))))
   '(widget-field-face ((t (:background "navy"))))
   '(widget-single-line-field-face ((t (:background "royalblue")))))
  :config
  (enable-theme 'midnight))
#+end_src

** command-log-mode

This add-on can be used to demo Emacs to an audience. When activated,
keystrokes get logged into a designated buffer, along with the command bound
to them.

#+begin_src emacs-lisp
(use-package command-log-mode
  :bind (("C-c e M" . command-log-mode)
         ("C-c e L" . clm/open-command-log-buffer)))
#+end_src

** compile

#+begin_src emacs-lisp
(use-package compile
  :nix nil
  :bind (("C-c c" . compile)
         ("M-O"   . show-compilation))
  :bind (:map compilation-mode-map
              ("z" . delete-window))
  :hook (compilation-filter . compilation-ansi-color-process-output)
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-context-lines 10)
  (compilation-scroll-output 'first-error)
  (compilation-skip-threshold 2)
  (compilation-window-height 100)
  :preface
  (defun show-compilation ()
    (interactive)
    (let ((it
           (catch 'found
             (dolist (buf (buffer-list))
               (when (string-match "\\*compilation\\*" (buffer-name buf))
                 (throw 'found buf))))))
      (if it
          (display-buffer it)
        (call-interactively #'compile))))

  (defun compilation-ansi-color-process-output ()
    (ansi-color-process-output nil)
    (set (make-local-variable 'comint-last-output-start)
         (point-marker))))
#+end_src

** COMMENT compile-angel

#+begin_src emacs-lisp
(use-package compile-angel
  :custom
  (compile-angel-verbose nil)
  :config
  (compile-angel-on-load-mode)
  (add-hook 'emacs-lisp-mode-hook
            #'compile-angel-on-save-local-mode))
#+end_src

** copy-as-format

#+begin_src emacs-lisp
(use-package copy-as-format
  :bind (("C-c w m" . copy-as-format-markdown)
         ("C-c w s" . copy-as-format-slack)
         ("C-c w o" . copy-as-format-org-mode)
         ("C-c w t" . copy-as-format-telegram)
         ("C-c w g" . copy-as-format-github)
         ("C-c w w" . copy-as-format-whatsapp))
  :custom
  (copy-as-format-default "slack")
  :config
  (defun copy-as-format--org-mode (text _multiline)
    (format "#+begin_src %s\n%s\n#+end_src\n"
            (replace-regexp-in-string "-mode\\'" "" (symbol-name major-mode))
            text)))
#+end_src

** crosshairs

#+begin_src emacs-lisp
(use-package crosshairs
  :bind ("M-o c" . crosshairs-mode))
#+end_src

** COMMENT ctrlf

#+begin_src emacs-lisp
(use-package ctrlf
  :demand t
  :config
  (ctrlf-mode +1))
#+end_src

** COMMENT cursor-chg

#+begin_src emacs-lisp
(use-package cursor-chg
  :demand t
  :commands change-cursor-mode
  :config
  (change-cursor-mode 1)
  (toggle-cursor-type-when-idle 1))
#+end_src

** cus-edit

#+begin_src emacs-lisp
(use-package cus-edit
  :bind (("C-c o" . customize-option)
         ("C-c O" . customize-group)
         ("C-c F" . customize-face))
  :custom
  (custom-file (emacs-path "settings.el"))
  (custom-raised-buttons nil)
  (custom-safe-themes
   '("644e23f289dcd3548c3f054785c72cf1fd81fcee07875ac7fed311985a67a0dc"
     "c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223"
     "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa"
     "b9e9ba5aeedcc5ba8be99f1cc9301f6679912910ff92fdf7980929c2fc83ab4d"
     "84d2f9eeb3f82d619ca4bfffe5f157282f4779732f48a5ac1484d94d5ff5b279"
     "a27c00821ccfd5a78b01e4f35dc056706dd9ede09a8b90c6955ae6a390eb1c1e"
     default))
  :preface
  (defun my-set-custom-variable ()
    (interactive)
    (save-excursion
      (custom-set-variables (read (current-buffer)))
      (message "Variable has been set"))))
#+end_src

** dabbrev

#+begin_src emacs-lisp
(use-package dabbrev
  :bind ("C-M-/" . dabbrev-expand)
  :custom
  (dabbrev-case-fold-search nil)
  (dabbrev-case-replace nil)
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
#+end_src

** deadgrep

#+begin_src emacs-lisp
(use-package deadgrep
  :bind ("M-s d" . deadgrep))
#+end_src

** COMMENT debbugs-gnu

#+begin_src emacs-lisp
(use-package debbugs-gnu
  :nix nil
  :commands (debbugs-gnu debbugs-gnu-search)
  :bind ("C-c #" . gnus-read-ephemeral-emacs-bug-group))
#+end_src

** dedicated

#+begin_src emacs-lisp
(use-package dedicated
  :bind ("C-c W" . dedicated-mode))
#+end_src

** delsel

#+begin_src emacs-lisp
(use-package delsel
  :custom (delete-selection-mode 1))
#+end_src

** diff-hl

[[https://github.com/dgutov/diff-hl][diff-hl]] highlights uncommitted changes on the left side of the window (area
also known as the "gutter"), and allows you to jump between and revert them
selectively.

In buffers controlled by Git, you can also stage and unstage the changes.

#+begin_src emacs-lisp
(use-package diff-hl
  :commands (diff-hl-mode diff-hl-dired-mode))
#+end_src

*** diff-hl-flydiff

This mode enables diffing on-the-fly (i.e. without saving the buffer first)
Toggle in all buffers with =M-x diff-hl-flydiff-mode=. This is part of the
diff-hl package.

#+begin_src emacs-lisp
(use-package diff-hl-flydiff
  :commands diff-hl-flydiff-mode)
#+end_src

** diff-mode

#+begin_src emacs-lisp
(use-package diff-mode
  :commands diff-mode
  :custom
  (diff-mode-hook '(diff-delete-empty-files diff-make-unified smerge-mode))
  :custom-face
  (diff-added ((((background dark)) (:foreground "#FFFF9B9BFFFF"))
               (t (:foreground "DarkGreen"))))
  (diff-changed ((((background dark)) (:foreground "Yellow"))
                 (t (:foreground "MediumBlue"))))
  (diff-context ((((background dark)) (:foreground "White"))
                 (t (:foreground "Black"))))
  (diff-file-header ((((background dark)) (:foreground "Cyan" :background "Black"))
                     (t (:foreground "Red" :background "White"))))
  (diff-header ((((background dark)) (:foreground "Cyan"))
                (t (:foreground "Red"))))
  (diff-index ((((background dark)) (:foreground "Magenta"))
               (t (:foreground "Green"))))
  (diff-nonexistent ((((background dark)) (:foreground "#FFFFFFFF7474"))
                     (t (:foreground "DarkBlue")))))
#+end_src

** diffview

#+begin_src emacs-lisp
(use-package diffview
  :commands (diffview-current diffview-region diffview-message))
#+end_src

** dired

#+begin_src emacs-lisp
(use-package dired
  :bind ("C-c j" . dired-two-pane)
  :bind (:map dired-mode-map
              ("j"     . dired)
              ("z"     . pop-window-configuration)
              ("e"     . ora-ediff-files)
              ("^"     . dired-up-directory)
              ("q"     . pop-window-configuration)
              ("M-!"   . shell-command)
              ("<tab>" . dired-next-window)
              ("M-G")
              ("M-s f"))
  :hook
  (dired-mode . dired-hide-details-mode)
  (emacs-startup . dired-two-pane)
  :custom
  (dired-clean-up-buffers-too nil)
  (dired-dwim-target t)
  (dired-hide-details-hide-information-lines nil)
  (dired-hide-details-hide-symlink-targets nil)
  ;; This does not work on all Tramp hosts
  ;; (dired-listing-switches "--group-directories-first -lah")
  (dired-listing-switches "-lah")
  (dired-mouse-drag-files t)
  (dired-no-confirm
   '(byte-compile chgrp chmod chown copy hardlink symlink touch))
  (dired-recursive-copies 'always)
  (dired-recursive-deletes 'always)
  (dired-vc-rename-file t)
  :functions (dired-dwim-target-directory)
  :preface
  (defun dired-two-pane (&optional arg)
    (interactive "P")
    (push-window-configuration)
    (let ((here default-directory))
      (delete-other-windows)
      (dired "~/Downloads")
      (revert-buffer)
      (split-window-horizontally)
      (if arg
          (dired here)
        (dired "~/Desktop")
        (split-window-vertically)
        (dired "~/Inbox"))
      (revert-buffer)
      (pop-to-buffer "Downloads")))

  (defun dired-next-window ()
    (interactive)
    (let ((next
           (car (cl-remove-if-not
                 (lambda (wind)
                   (with-current-buffer (window-buffer wind)
                     (eq major-mode 'dired-mode)))
                 (cdr (window-list))))))
      (when next
        (select-window next))))

  (defvar mark-files-cache (make-hash-table :test #'equal))

  (defun mark-similar-versions (name)
    (let ((pat name))
      (if (string-match "^\\(.+?\\)-[0-9._-]+$" pat)
          (setq pat (match-string 1 pat)))
      (or (gethash pat mark-files-cache)
          (ignore (puthash pat t mark-files-cache)))))

  ;; (defun dired-mark-similar-version ()
  ;;   (interactive)
  ;;   (setq mark-files-cache (make-hash-table :test #'equal))
  ;;   (dired-mark-sexp '(mark-similar-versions name)))

  (defun ora-ediff-files ()
    (interactive)
    (let ((files (dired-get-marked-files))
          (wnd (current-window-configuration)))
      (if (<= (length files) 2)
          (let ((file1 (car files))
                (file2 (if (cdr files)
                           (cadr files)
                         (read-file-name
                          "file: "
                          (dired-dwim-target-directory)))))
            (if (file-newer-than-file-p file1 file2)
                (ediff-files file2 file1)
              (ediff-files file1 file2))
            (add-hook 'ediff-after-quit-hook-internal
                      `(lambda ()
                         (setq ediff-after-quit-hook-internal nil)
                         (set-window-configuration ,wnd))))
        (error "no more than 2 files should be marked")))))
#+end_src

*** dired-follow

#+begin_src emacs-lisp
(use-package dired-follow
  :no-require t
  :after dired
  :demand t
  :hook
  (dired-mode
   . (lambda () (bind-key "F" #'dired-follow-mode dired-mode-map)))
  :preface
  (defun do-dired-display-file (_)
    (dired-display-file))
  :config
  (define-minor-mode dired-follow-mode
    "Diplay file at point in dired after a move."
    :lighter " dired-f"
    :global t
    :group 'dired
    (if dired-follow-mode
        (advice-add 'dired-next-line :after #'do-dired-display-file)
      (advice-remove 'dired-next-line #'do-dired-display-file))))
#+end_src

*** dired-hist

#+begin_src emacs-lisp
(use-package dired-hist
  :demand t
  :after dired
  :bind (:map dired-mode-map
              ("l" . dired-hist-go-back)
              ("r" . dired-hist-go-forward))
  :config
  (dired-hist-mode 1))
#+end_src

*** dired-rsync

#+begin_src emacs-lisp
(use-package dired-rsync
  :after dired
  :bind (:map dired-mode-map
              ("Y" . dired-rsync)))
#+end_src

*** dired-toggle

#+begin_src emacs-lisp
(use-package dired-toggle
  :bind ("C-c ~" . dired-toggle)
  :preface
  (defun my-dired-toggle-mode-hook ()
    (interactive)
    (visual-line-mode 1)
    (setq-local visual-line-fringe-indicators '(nil right-curly-arrow))
    (setq-local word-wrap nil))
  :hook (dired-toggle-mode . my-dired-toggle-mode-hook))
#+end_src

*** dired-x

#+begin_src emacs-lisp
(use-package dired-x
  :after dired
  :diminish dired-omit-mode
  :hook
  (dired-mode . dired-omit-mode)
  :custom
  (dired-omit-mode nil t)
  (dired-omit-size-limit 60000)
  (dired-omit-files
   "\\`[.]?#\\|\\`[.]\\'\\|\\`\\([.]\\(DS_Store\\|localized\\|com-apple-bird.*\\)\\|Icon\015\\)\\'"))
#+end_src

*** diredfl

Extra font-lock rules for dired.

#+begin_src emacs-lisp
(use-package diredfl
  :after dired
  :custom-face
  (diredfl-file-name ((t (:foreground "grey80"))))
  :config
  (diredfl-global-mode 1))
#+end_src

*** dired-subtree

[[https://github.com/Fuco1/dired-hacks/blob/master/dired-subtree.el][dired-subtree]] defines function =dired-subtree-insert= which instead inserts the
subdirectory directly below its line in the original listing, and indent the
listing of subdirectory to resemble a tree-like structure (somewhat similar to
tree(1) except the pretty graphics). The tree display is somewhat more
intuitive than the default "flat" subdirectory manipulation provided by `i'.

#+begin_src emacs-lisp
(use-package dired-subtree
  :after dired
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-cycle)
              ("TAB" . dired-subtree-cycle)
              ("C-i" . dired-subtree-cycle)
              ("i" . dired-subtree-insert)))
#+end_src

** direnv

#+begin_src emacs-lisp
(use-package direnv
  :functions (direnv--maybe-update-environment)
  :preface
  (defconst emacs-binary-path (directory-file-name
                               (file-name-directory
                                (executable-find "emacsclient"))))

  (defun patch-direnv-environment (&rest _args)
    (let ((dir (file-name-as-directory emacs-binary-path)))
      (unless (member dir exec-path)
        (setenv "PATH" (concat emacs-binary-path ":" (getenv "PATH")))
        (setq exec-path (cons dir exec-path)))))

  (defvar my-direnv-last-buffer nil)

  (defun my-direnv-maybe-update (&rest _ignore)
    (unless (eq (current-buffer) my-direnv-last-buffer)
      (setq my-direnv-last-buffer (current-buffer))
      (direnv--maybe-update-environment)))
  :init
  (advice-add 'direnv-update-directory-environment
              :after #'patch-direnv-environment)

  (add-hook 'change-major-mode-hook #'my-direnv-maybe-update)
  ;; (add-hook 'buffer-list-update-hook #'my-direnv-maybe-update)
  (add-hook 'window-selection-change-functions #'my-direnv-maybe-update))
#+end_src

** discover-my-major

#+begin_src emacs-lisp
(use-package discover-my-major
  :bind (("C-h <C-m>" . discover-my-major)
         ("C-h M-m"   . discover-my-mode)))
#+end_src

** COMMENT docker

#+begin_src emacs-lisp
(use-package docker
  :bind ("C-c d" . docker)
  :diminish
  :init
  (use-package docker-image   :commands docker-images)
  (use-package docker-volume  :commands docker-volumes)
  (use-package docker-network :commands docker-containers)
  (use-package docker-compose :commands docker-compose)

  (use-package docker-container
    :commands docker-containers
    :custom
    (docker-containers-shell-file-name "/bin/bash")
    (docker-containers-show-all nil)))
#+end_src

** docker-compose-mode

#+begin_src emacs-lisp
(use-package docker-compose-mode
  :mode "docker-compose.*\.yml\\'")
#+end_src

** dockerfile-mode

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :mode "Dockerfile[a-zA-Z.-]*\\'")
#+end_src

** COMMENT doc-view

#+begin_src emacs-lisp
(use-package doc-view
  :nix nil
  :defer t
  :custom
  (doc-view-resolution 300))
#+end_src

** doxymacs

#+begin_src emacs-lisp
(use-package doxymacs
  :commands (doxymacs-mode doxymacs-font-lock)
  :config
  (doxymacs-mode 1)
  (doxymacs-font-lock))
#+end_src

** COMMENT dumb-jump

#+begin_src emacs-lisp
(use-package dumb-jump
  :hook ((coq-mode haskell-mode) . dumb-jump-mode))
#+end_src

** eager-state

#+begin_src emacs-lisp
(use-package eager-state
  :config
  (eager-state-mode 1)
  (eager-state-preempt-kill-emacs-hook-mode 1))
#+end_src

** easy-kill

#+begin_src emacs-lisp
(use-package easy-kill
  :bind ([remap kill-ring-save] . easy-kill))
#+end_src

** COMMENT easysession

The [[https://github.com/jamescherti/easysession.el][easysession.el]] Emacs package is a lightweight session manager for Emacs
that can persist and restore file editing buffers, indirect buffers (clones),
Dired buffers, the tab-bar, and Emacs frames (including or excluding the frame
size, width, and height). It offers a convenient and effortless way to manage
Emacs editing sessions and utilizes built-in Emacs functions to persist and
restore frames.

Key features include:

- Minimalistic design focused on performance and simplicity, avoiding
  unnecessary complexity.

- Persist and restore file editing buffers, indirect buffers/clones, dired
  buffers, tab-bar, the Emacs frame.

- Automatically save sessions by activating the mode with
  =easysession-save-mode= to ensure that the current session is automatically
  saved every =easysession-save-interval= seconds and when emacs quits.

- Helper functions: Switch to a session (i.e., load and change the current
  session) with =easysession-switch-to=, load the Emacs editing session with
  =easysession-load=, save the Emacs editing session with =easysession-save= and
  =easysession-save-as=, delete the current Emacs session with
  =easysession-delete=, and rename the current Emacs session with
  =easysession-rename=.

#+begin_src emacs-lisp
(use-package easysession
  :custom
  (easysession-save-interval (* 10 60))
  :init
  (add-hook 'emacs-startup-hook #'easysession-load-including-geometry 98)
  (add-hook 'emacs-startup-hook #'easysession-save-mode 99))
#+end_src

** eat

[[https://codeberg.org/akib/emacs-eat][Eat]]’s name self-explanatory, it stands for "Emulate A Terminal". Eat is a
terminal emulator. It can run most (if not all) full-screen terminal programs,
including Emacs.

It is pretty fast, more than three times faster than Term, despite being
implemented entirely in Emacs Lisp. So fast that you can comfortably run Emacs
inside Eat, or even use your Emacs as a terminal multiplexer.

It has many features that other Emacs terminal emulator still don't have, for
example Sixel support, complete mouse support, shell integration, etc.

It flickers less than other Emacs terminal emulator, so you get more
performance and a smoother experience.

To get the most out of Eat, you should also setup shell integration.

#+begin_src emacs-lisp
(use-package eat
  :commands (eat))
#+end_src

** COMMENT ebdb

#+begin_src emacs-lisp
(use-package ebdb-com
  :nix ebdb
  :commands ebdb)
#+end_src

** edbi

#+begin_src emacs-lisp
(use-package edbi
  :commands edbi:sql-mode)
#+end_src

** ediff

#+begin_src emacs-lisp
(use-package ediff
  :nix nil
  :bind (:prefix-map
         my-ediff-map
         :prefix "C-c ="
         ("b" . ediff-buffers)
         ("B" . ediff-buffers3)
         ("c" . compare-windows)
         ("=" . ediff-files)
         ("f" . ediff-files)
         ("F" . ediff-files3)
         ("m" . count-matches)
         ("r" . ediff-revision)
         ("p" . ediff-patch-file)
         ("P" . ediff-patch-buffer)
         ("l" . ediff-regions-linewise)
         ("w" . ediff-regions-wordwise))
  :custom
  (ediff-combination-pattern
   '("<<<<<<< A: HEAD" A "||||||| Ancestor" Ancestor "=======" B ">>>>>>> B: Incoming"))
  (ediff-diff-options "-w")
  (ediff-highlight-all-diffs nil)
  (ediff-show-clashes-only t)
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  :custom-face
  (ediff-current-diff-C ((t (:extend t :background "#222200"))))
  :init
  (defun test-compare ()
    (interactive)
    (delete-other-windows)
    (let ((here (point)))
      (search-forward "got:")
      (split-window-below)
      (goto-char here))
    (search-forward "expected:")
    (call-interactively #'compare-windows))

  (defun test-ediff ()
    (interactive)
    (goto-char (point-min))
    (search-forward "expected:")
    (forward-line 1)
    (goto-char (line-beginning-position))
    (let ((begin (point)))
      (search-forward "(")
      (goto-char (match-beginning 0))
      (forward-sexp)
      (let ((text (buffer-substring begin (point)))
            (expected (get-buffer-create "*expected*")))
        (with-current-buffer expected
          (erase-buffer)
          (insert text))
        (search-forward "got:")
        (forward-line 1)
        (goto-char (line-beginning-position))
        (setq begin (point))
        (search-forward "(")
        (goto-char (match-beginning 0))
        (forward-sexp)
        (setq text (buffer-substring begin (point)))
        (let ((got (get-buffer-create "*got*")))
          (with-current-buffer got
            (erase-buffer)
            (insert text))
          (ediff-buffers expected got))))))
#+end_src

*** ediff-keep

#+begin_src emacs-lisp
(use-package ediff-keep
  :nix nil
  :after ediff)
#+end_src

** edit-env

#+begin_src emacs-lisp
(use-package edit-env
  :commands edit-env)
#+end_src

** edit-indirect

#+begin_src emacs-lisp
(use-package edit-indirect
  :bind (("C-c '" . edit-indirect-region)))
#+end_src

** edit-rectangle

#+begin_src emacs-lisp
(use-package edit-rectangle
  :bind ("C-x r e" . edit-rectangle))
#+end_src

** edit-server

#+begin_src emacs-lisp
(use-package edit-server
  :if (and window-system (not alternate-emacs))
  :hook
  (edit-server-edit-mode . visual-line-mode)
  (edit-server-edit-mode . visual-fill-column-mode)
  :custom
  (edit-server-new-frame
   '((name . "Edit with Emacs FRAME")
     (top . 200)
     (left . 200)
     (width . 80)
     (height . 25)
     (minibuffer . t)
     (menu-bar-lines . t)
     (window-system . x)))
  :init
  (if after-init-time
      (edit-server-start)
    (add-hook 'after-init-hook #'edit-server-start)))
#+end_src

** edit-var

#+begin_src emacs-lisp
(use-package edit-var
  :bind ("C-c e v" . edit-variable))
#+end_src

** COMMENT electric

#+begin_src emacs-lisp
(use-package electric
  :nix nil
  :defer t
  :custom
  (electric-indent-mode nil))
#+end_src

** emamux

#+begin_src emacs-lisp
(use-package emamux
  :commands emamux:send-command
  :custom
  (emamux:show-buffers-with-index nil)
  (emamux:get-buffers-regexp
   "^\\(buffer[0-9]+\\): +\\([0-9]+\\) +\\(bytes\\): +[\"]\\(.*\\)[\"]"))
#+end_src

** emojify

#+begin_src emacs-lisp
(use-package emojify
  :after erc
  :config
  (global-emojify-mode))
#+end_src

** COMMENT engine-mode

#+begin_src emacs-lisp
(use-package engine-mode
  :config
  (defengine google "https://www.google.com/search?q=%s"
             :keybinding "/")
  (engine-mode 1))
#+end_src

** epa

#+begin_src emacs-lisp
(use-package epa
  :preface
  (defun epa--key-widget-value-create (widget)
    (let* ((key (widget-get widget :value))
           (primary-sub-key (car (last (epg-key-sub-key-list key) 3)))
           (primary-user-id (car (epg-key-user-id-list key))))
      (insert (format "%c "
                      (if (epg-sub-key-validity primary-sub-key)
                          (car (rassq (epg-sub-key-validity primary-sub-key)
                                      epg-key-validity-alist))
                        ? ))
              (epg-sub-key-id primary-sub-key)
              " "
              (if primary-user-id
                  (if (stringp (epg-user-id-string primary-user-id))
                      (epg-user-id-string primary-user-id)
                    (epg-decode-dn (epg-user-id-string primary-user-id)))
                ""))))
  :config
  (epa-file-enable))
#+end_src

** COMMENT erc

#+begin_src emacs-lisp
(use-package erc
  :commands (erc erc-tls)
  :bind (:map erc-mode-map
              ("C-c r" . reset-erc-track-mode))
  :hook
  (erc-mode . abbrev-mode)
  (erc-mode . erc-spelling-mode)
  :custom
  (erc-fill-function 'erc-fill-variable)
  (erc-fill-static-center 12)
  (erc-foolish-content
   '("travis-ci.*ekmett"
     "analystics.*ekmett"
     "rudybot:"))
  (erc-format-nick-function 'erc-format-@nick)
  (erc-generate-log-file-name-function 'erc-generate-log-file-name-short)
  (erc-header-line-format nil)
  (erc-hide-list '("JOIN" "NICK" "PART" "QUIT"))
  (erc-lurker-hide-list '("JOIN" "NICK" "PART" "QUIT" "MODE"))
  (erc-ignore-list
   '("lensbot"
     "rudybot"
     "johnwilkins"))
  (erc-ignore-reply-list '("JordiGH"))
  (erc-keywords
   '("wiegley"
     "ledger"
     "eshell"
     "use-package"))
  (erc-log-channels-directory "~/.local/share/ERC")
  (erc-log-write-after-send t)
  (erc-modules
   '(autojoin
     button
     completion
     dcc
     fill
     identd
     irccontrols
     list
     match
     menu
     move-to-prompt
     netsplit
     noncommands
     readonly
     replace
     ring
     services
     smiley
     stamp
     track
     truncate
     highlight-nicknames))
  (erc-nick "johnw")
  (erc-port 6667)
  (erc-priority-people-regexp "\\`[^#].+")
  (erc-prompt-for-nickserv-password nil)
  (erc-rename-buffers t)
  (erc-replace-alist '(("</?FONT>" . "")))
  (erc-server "irc.libera.chat")
  (erc-services-mode t)
  (erc-text-matched-hook '(erc-hide-fools))
  (erc-track-enable-keybindings t)
  (erc-track-exclude '("#idris" "#agda" "#twitter_jwiegley"))
  (erc-track-exclude-types
   '("JOIN" "KICK" "NICK" "PART" "QUIT" "MODE" "333" "353"))
  (erc-track-faces-priority-list
   '(erc-error-face
     (erc-nick-default-face erc-current-nick-face)
     erc-current-nick-face erc-keyword-face
     (erc-nick-default-face erc-pal-face)
     erc-pal-face erc-nick-msg-face erc-direct-msg-face))
  (erc-track-score-mode t)
  (erc-track-showcount t)
  (erc-user-full-name 'user-full-name)
  (erc-use-auth-source-for-nickserv-password t)
  (erc-auto-query 'window-noselect)
  (erc-autoaway-message "I'm away (after %i seconds of idle-time)")
  (erc-autojoin-channels-alist
   '(("libera"
      "##categorytheory"
      "#coq"
      "#haskell"
      "#haskell-infrastructure"
      "#haskell-ops"
      "#ledger"
      "#nix-darwin"
      "#nixos"
      "#org-mode")))
  :defines
  (erc-modified-channels-alist
   erc-timestamp-only-if-changed-flag
   erc-timestamp-format
   erc-fill-prefix
   erc-fill-column
   erc-insert-timestamp-function
   erc-identd-port
   erc-identd-process
   erc-nickserv-passwords)
  :functions
  (erc-modified-channels-display
   erc-modified-channels-update
   erc-track-mode
   erc-track-minor-mode
   erc-list-match
   erc-send-input)
  :preface
  (defun irc (&optional arg)
    (interactive "P")
    (if arg
        (pcase-dolist (`(,server . ,nick)
                       '(("irc.libera.chat" . "johnw")))
          (erc-tls :server server :port 6697 :nick (concat nick "_")
                   :password (lookup-password server nick 6697)))
      (let ((pass (lookup-password "irc.libera.chat" "johnw" 6697)))
        ;; (setq erc-nickserv-passwords
        ;;       (list (cons nil (list (list (cons "johnw" pass))))))
        (when (> (length pass) 32)
          (error "Failed to read ZNC password"))
        (erc :server "127.0.0.1" :port 6697 :nick "johnw"
             :password (concat "johnw/libera:" pass)))))

  (defun reset-erc-track-mode ()
    (interactive)
    (setq erc-modified-channels-alist nil)
    (erc-modified-channels-update)
    (erc-modified-channels-display)
    (force-mode-line-update))

  (defun setup-irc-environment ()
    (set (make-local-variable 'scroll-conservatively) 100)
    (setq erc-timestamp-only-if-changed-flag nil
          erc-timestamp-format "%H:%M "
          erc-fill-prefix "          "
          erc-fill-column 78
          erc-insert-timestamp-function 'erc-insert-timestamp-left
          line-spacing 4))

  (defun accept-certificate ()
    (interactive)
    (when (re-search-backward "/znc[\n ]+AddTrustedServerFingerprint[\n ]+\\(.+\\)" nil t)
      (goto-char (point-max))
      (erc-send-input (concat "/znc AddTrustedServerFingerprint " (match-string 1)))))

  (defcustom erc-foolish-content '()
    "Regular expressions to identify foolish content.
    Usually what happens is that you add the bots to
    `erc-ignore-list' and the bot commands to this list."
    :group 'erc
    :type '(repeat regexp))

  (defun erc-foolish-content (msg)
    "Check whether MSG is foolish."
    (erc-list-match erc-foolish-content msg))
  :init
  (add-hook 'erc-mode-hook #'setup-irc-environment)

  (when alternate-emacs
    (add-hook 'emacs-startup-hook #'irc))

  (use-package erc-identd
    :defer t
    :config
    (defun erc-identd-start (&optional port)
      "Start an identd server listening to port 8113.
Port 113 (auth) will need to be redirected to port 8113 on your
machine -- using iptables, or a program like redir which can be
run from inetd. The idea is to provide a simple identd server
when you need one, without having to install one globally on
your system."
      (interactive (list (read-string "Serve identd requests on port: " "8113")))
      (unless port (setq port erc-identd-port))
      (when (stringp port)
        (setq port (string-to-number port)))
      (when erc-identd-process
        (delete-process erc-identd-process))
      (setq erc-identd-process
	    (make-network-process :name "identd"
			          :buffer nil
			          :host 'local :service port
			          :server t :noquery t
			          :filter 'erc-identd-filter))
      (set-process-query-on-exit-flag erc-identd-process nil)))
  :config
  (erc-track-minor-mode 1)
  (erc-track-mode 1)

  (add-hook 'erc-insert-pre-hook
            (lambda (s)
              (when (erc-foolish-content s)
                (setq erc-insert-this nil))))

  (bind-key "<f5>" #'accept-certificate))
#+end_src

*** COMMENT erc-alert

#+begin_src emacs-lisp
(use-package erc-alert
  :nix nil
  :after erc)
#+end_src

*** erc-highlight-nicknames

#+begin_src emacs-lisp
(use-package erc-highlight-nicknames
  :after erc)
#+end_src

*** erc-macros

#+begin_src emacs-lisp
(use-package erc-macros
  :nix nil
  :after erc)
#+end_src

*** erc-yank

#+begin_src emacs-lisp
(use-package erc-yank
  :load-path "lisp/erc-yank"
  :after erc
  :bind (:map erc-mode-map
              ("C-y" . erc-yank))
  :custom
  (erc-yank-query-before-gisting nil))
#+end_src

** ert

#+begin_src emacs-lisp
(use-package ert
  :bind ("C-c e t" . ert-run-tests-interactively))
#+end_src

** esh-toggle

#+begin_src emacs-lisp
(use-package esh-toggle
  :bind ("C-x C-z" . eshell-toggle))
#+end_src

** eshell

#+begin_src emacs-lisp
(use-package eshell
  :commands (eshell eshell-command)
  :custom
  ;; (eshell-password-prompt-regexp "")
  (eshell-directory-change-hook '(my-direnv-maybe-update))
  (eshell-directory-name (emacs-path "eshell"))
  (eshell-hist-ignoredups t)
  (eshell-history-size 50000)
  (eshell-ls-dired-initial-args '("-h"))
  (eshell-ls-exclude-regexp "~\\'")
  (eshell-ls-initial-args "-h")
  (eshell-modules-list
   '(eshell-alias
     eshell-basic
     eshell-cmpl
     eshell-dirs
     eshell-glob
     eshell-hist
     eshell-ls
     eshell-pred
     eshell-prompt
     eshell-rebind
     eshell-script
     ;; eshell-smart
     eshell-term
     eshell-unix
     eshell-xtra))
  (eshell-prompt-function
   (lambda nil
     (concat (abbreviate-file-name (eshell/pwd))
             (if (= (user-uid) 0)
                 " # " " $ "))))
  (eshell-rebind-keys-alist
   '(([(control ?a)] . eshell-bol)
     ([home]         . eshell-bol)
     ([(control ?d)] . eshell-delchar-or-maybe-eof)
     ([backspace]    . eshell-delete-backward-char)
     ([delete]       . eshell-delete-backward-char)))
  (eshell-save-history-on-exit t)
  (eshell-stringify-t nil)
  (eshell-term-name "ansi")
  (eshell-visual-commands '("vi" "top" "screen" "less" "lynx" "rlogin" "telnet"))
  :preface
  (defvar eshell-isearch-map
    (let ((map (copy-keymap isearch-mode-map)))
      (define-key map [(control ?m)] 'eshell-isearch-return)
      (define-key map [return]       'eshell-isearch-return)
      (define-key map [(control ?r)] 'eshell-isearch-repeat-backward)
      (define-key map [(control ?s)] 'eshell-isearch-repeat-forward)
      (define-key map [(control ?g)] 'eshell-isearch-abort)
      (define-key map [backspace]    'eshell-isearch-delete-char)
      (define-key map [delete]       'eshell-isearch-delete-char)
      map)
    "Keymap used in isearch in Eshell.")

  (defun eshell-spawn-external-command (beg end)
    "Parse and expand any history references in current input."
    (save-excursion
      (goto-char end)
      (when (looking-back "&!" beg)
        (delete-region (match-beginning 0) (match-end 0))
        (goto-char beg)
        (insert "spawn "))))

  (defun eshell-initialize ()
    (add-hook 'eshell-expand-input-functions #'eshell-spawn-external-command)

    (use-package em-unix
      :defer t
      :config
      (unintern 'eshell/su nil)
      (unintern 'eshell/sudo nil)))
  :init
  (add-hook 'eshell-first-time-mode-hook #'eshell-initialize))
#+end_src

*** eshell-bookmark

#+begin_src emacs-lisp
(use-package eshell-bookmark
  :hook (eshell-mode . eshell-bookmark-setup))
#+end_src

*** eshell-up

#+begin_src emacs-lisp
(use-package eshell-up
  :commands eshell-up)
#+end_src

*** eshell-z

#+begin_src emacs-lisp
(use-package eshell-z
  :after eshell)
#+end_src

*** COMMENT eshell-async

These hacks should not be necessary once asynchronous handling of Lisp
commands makes its way into Eshell itself.

#+begin_src emacs-lisp
(use-package eshell-async
  :no-require t
  :config
  (static-if (version= emacs-version "30.1")
      (load "eshell-ext-30.1")
    (static-if (version= emacs-version "29.4")
        (load "eshell-ext-29.4")
      (load "eshell-ext-HEAD"))))
#+end_src

** COMMENT etags

#+begin_src emacs-lisp
(use-package etags
  :nix nil
  :bind ("M-T" . tags-search)
  :custom
  (tags-add-tables t)
  (tags-apropos-verbose t)
  (tags-case-fold-search nil)
  (tags-revert-without-query t))
#+end_src

** COMMENT eval-expr

#+begin_src emacs-lisp
(use-package eval-expr
  :bind ("M-:" . eval-expr)
  :custom
  (eval-expr-print-function 'pp)
  (eval-expr-print-length 100)
  (eval-expr-print-level 20)
  :config
  (defun eval-expr-minibuffer-setup ()
    (local-set-key (kbd "<tab>") #'lisp-complete-symbol)
    (set-syntax-table emacs-lisp-mode-syntax-table)
    (paredit-mode)))
#+end_src

** evil

#+begin_src emacs-lisp
(use-package evil
  :commands evil-mode)
#+end_src

** expand-region

#+begin_src emacs-lisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region)
  ("M-@" . er/expand-region))
#+end_src

*** change-inner

[[https://github.com/magnars/change-inner.el][change-inner]] gives you vim's ci command, building on =expand-region=. It is most
easily explained by example:

#+begin_src bash
function test() {
  return "semantic kill";
}
#+end_src

With point after the word semantic

- =change-inner= ="= would kill the contents of the string
- =change-outer= ="= would kill the entire string
- =change-inner= ={= would kill the return-statement
- =change-outer= ={= would kill the entire block

Giving these commands a prefix argument means copy instead of kill.

#+begin_src emacs-lisp
(use-package change-inner
  :bind (("M-i"     . change-inner)
         ("M-o M-o" . change-outer)))
#+end_src

** eyebrowse

#+begin_src emacs-lisp
(use-package eyebrowse
  :bind-keymap ("C-\\" . eyebrowse-mode-map)
  :bind (:map eyebrowse-mode-map
              ("C-\\ C-\\" . eyebrowse-last-window-config)
              ("s-1" . eyebrowse-switch-to-window-config-1)
              ("s-2" . eyebrowse-switch-to-window-config-2)
              ("s-3" . eyebrowse-switch-to-window-config-3)
              ("s-4" . eyebrowse-switch-to-window-config-4))
  :custom
  (eyebrowse-keymap-prefix "")
  (eyebrowse-mode-line-separator " ")
  (eyebrowse-new-workspace t)
  :config
  (eyebrowse-mode t))
#+end_src

** feebleline

#+begin_src emacs-lisp
(use-package feebleline
  :bind (("M-o m" . feebleline-mode))
  :config
  (window-divider-mode t))
#+end_src

** fence-edit

#+begin_src emacs-lisp
(use-package fence-edit
  :commands fence-edit-code-at-point)
#+end_src

** ffap

#+begin_src emacs-lisp
(use-package ffap
  :bind (
         ;; ("C-c v"     . ffap)
         ("C-c <tab>" . ff-find-other-file)))
#+end_src

** find-dired

#+begin_src emacs-lisp
(use-package find-dired
  :defer t
  :custom
  (find-ls-option '("-print0 | xargs -P4 -0 ls -ldN" . "-ldN"))
  (find-ls-subdir-switches "-ldN"))
#+end_src

** COMMENT flycheck

#+begin_src emacs-lisp
(use-package flycheck
  :commands (flycheck-mode
             flycheck-next-error
             flycheck-previous-error)
  :custom
  (flycheck-coq-executable "ct-coqtop")
  (flycheck-display-errors-delay 0.0)
  (flycheck-standard-error-navigation nil)
  :init
  (dolist (where '((emacs-lisp-mode-hook . emacs-lisp-mode-map)
                   (haskell-mode-hook    . haskell-mode-map)
                   (js2-mode-hook        . js2-mode-map)
                   (c-mode-common-hook   . c-mode-base-map)
                   (rust-mode-hook       . rust-mode-map)))
    (add-hook (car where)
              `(lambda ()
                 (bind-key "M-n" #'flycheck-next-error ,(cdr where))
                 (bind-key "M-p" #'flycheck-previous-error ,(cdr where)))))
  :functions (flycheck-clear-idle-change-timer)
  :preface
  (defun magnars/adjust-flycheck-automatic-syntax-eagerness ()
    "Adjust how often we check for errors based on if there are any.
This lets us fix any errors as quickly as possible, but in a
clean buffer we're an order of magnitude laxer about checking."
    (setq flycheck-idle-change-delay
          (if flycheck-current-errors 0.3 3.0)))
  :config
  (defalias 'show-error-at-point-soon
    'flycheck-show-error-at-point)

  ;; Each buffer gets its own idle-change-delay because of the
  ;; buffer-sensitive adjustment above.
  (make-variable-buffer-local 'flycheck-idle-change-delay)

  (add-hook 'flycheck-after-syntax-check-hook
            #'magnars/adjust-flycheck-automatic-syntax-eagerness)

  ;; Remove newline checks, since they would trigger an immediate check
  ;; when we want the idle-change-delay to be in effect while editing.
  (setq-default flycheck-check-syntax-automatically
                '(save idle-change mode-enabled))

  (defun flycheck-handle-idle-change ()
    "Handle an expired idle time since the last change.
This is an overwritten version of the original
flycheck-handle-idle-change, which removes the forced deferred.
Timers should only trigger inbetween commands in a single
threaded system and the forced deferred makes errors never show
up before you execute another command."
    (flycheck-clear-idle-change-timer)
    (flycheck-buffer-automatically 'idle-change)))
#+end_src

*** COMMENT flycheck-haskell

#+begin_src emacs-lisp
(use-package flycheck-haskell
  :commands flycheck-haskell-setup
  :hook
  (haskell-mode . flycheck-mode)
  (haskell-mode . flycheck-haskell-setup)
  :config
  (flycheck-haskell-hpack-preference 'prefer-cabal))
#+end_src

** flymake

#+begin_src emacs-lisp
(use-package flymake
  :commands (flymake-mode)
  :bind (:map
         flymake-mode-map
         ("M-n" . flymake-goto-next-error)
         ("M-p" . flymake-goto-prev-error))
  :hook
  (emacs-lisp-mode . flymake-mode)
  :custom
  (flymake-fringe-indicator-position 'left-fringe)
  (flymake-suppress-zero-counters t)
  (flymake-start-on-flymake-mode t)
  (flymake-no-changes-timeout nil)
  (flymake-start-on-save-buffer t)
  (flymake-proc-compilation-prevents-syntax-check t)
  (flymake-wrap-around nil)
  :custom-face
  (flymake-note ((t nil)))
  (flymake-warning ((t (:underline nil)))))
#+end_src

** flyspell

#+begin_src emacs-lisp
(use-package flyspell
  :after ispell
  :bind (("C-c i b" . flyspell-buffer)
         ("C-c i f" . flyspell-mode)
         :map flyspell-mode-map
         ("C-,")
         ("C-."))
  :custom
  (flyspell-abbrev-p nil)
  (flyspell-use-meta-tab nil)
  :config
  (defun my-flyspell-maybe-correct-transposition (beg end candidates)
    (unless (let (case-fold-search)
              (string-match "\\`[A-Z0-9]+\\'"
                            (buffer-substring-no-properties beg end)))
      (flyspell-maybe-correct-transposition beg end candidates))))
#+end_src

** focus

#+begin_src emacs-lisp
(use-package focus
  :commands focus-mode)
#+end_src

** font-lock

#+begin_src emacs-lisp
(use-package font-lock
  :defer t
  :custom
  (global-font-lock-mode t)
  (font-lock-support-mode 'jit-lock-mode)
  (font-lock-verbose nil)
  :custom-face
  (font-lock-comment-face ((t (:foreground "grey50" :slant italic))))
  (font-lock-doc-face ((t (:foreground "cornflowerblue")))))
#+end_src

*** font-lock-studio

#+begin_src emacs-lisp
(use-package font-lock-studio
  :commands (font-lock-studio
             font-lock-studio-region))
#+end_src

** format-all

#+begin_src emacs-lisp
(use-package format-all
  :load-path "lisp/emacs-format-all-the-code"
  :commands (format-all-buffer
             format-all-mode)
  :hook
  (prog-mode . enable-format-all-if-indicated)
  :custom
  (format-all-formatters '(("Python" (black "--line-length" "79"))))
  :preface
  (defun enable-format-all-if-indicated ()
    (interactive)
    (when (locate-dominating-file default-directory ".format")
      (format-all-mode 1)
      (whitespace-mode 1)))
  :config
  (defun format-all--resolve-system (choices)
    "Get first choice matching `format-all--system-type' from CHOICES."
    (cl-dolist (choice choices)
      (cond ((atom choice)
             (cl-return choice))
            ((eql format-all--system-type (car choice))
             (cl-return (cadr choice)))))))
#+end_src

** free-keys

#+begin_src emacs-lisp
(use-package free-keys
  :commands free-keys)
#+end_src

** COMMENT fullframe

#+begin_src emacs-lisp
(use-package fullframe
  :defer t
  :init
  (autoload #'fullframe "fullframe"))
#+end_src

** ghub

#+begin_src emacs-lisp
(use-package ghub
  :defer t
  :config
  (require 'auth-source-pass)
  (defvar my-ghub-token-cache nil)
  (advice-add
   'ghub--token :around
   (lambda (orig-func host username package &optional nocreate forge)
     (or my-ghub-token-cache
         (setq my-ghub-token-cache
               (funcall orig-func host username package nocreate forge))))))
#+end_src

** gist

#+begin_src emacs-lisp
(use-package gist
  :no-require t ; not actually a package
  :bind ("C-c G" . my-gist-region-or-buffer)
  :preface
  (defun my-gist-region-or-buffer (start end)
    (interactive "r")
    (copy-region-as-kill start end)
    (deactivate-mark)
    (let ((file-name buffer-file-name))
      (with-temp-buffer
        (if file-name
            (call-process "gist" nil t nil "-f" file-name "-P")
          (call-process "gist" nil t nil "-P"))
        (kill-ring-save (point-min) (1- (point-max)))
        (message (buffer-substring (point-min) (1- (point-max))))))))
#+end_src

** git-annex

#+begin_src emacs-lisp
(use-package git-annex
  :load-path "lisp/git-annex"
  :after dired
  :defer t)
#+end_src

** git-link

#+begin_src emacs-lisp
(use-package git-link
  :bind ("C-c Y" . git-link)
  :commands (git-link git-link-commit git-link-homepage))
#+end_src

** git-timemachine

#+begin_src emacs-lisp
(use-package git-timemachine
  :commands git-timemachine)
#+end_src

** COMMENT git-undo

#+begin_src emacs-lisp
(use-package git-undo
  :load-path "lisp/git-undo"
  :commands git-undo)
#+end_src

** COMMENT gitpatch

#+begin_src emacs-lisp
(use-package gitpatch
  :commands gitpatch-mail)
#+end_src

** COMMENT google-this

#+begin_src emacs-lisp
(use-package google-this
  :bind-keymap ("C-c /" . google-this-mode-submap)
  :bind* ("M-SPC" . google-this-search)
  :bind (:map google-this-mode-map
              ("/" . google-this-search)))
#+end_src

** goto-last-change

#+begin_src emacs-lisp
(use-package goto-last-change
  :bind ("C-x C-/" . goto-last-change))
#+end_src

** gptel

#+begin_src emacs-lisp
(use-package gptel
  :load-path "lisp/gptel"
  :demand t
  :bind
  (("C-c u"    . gptel-menu)
   :prefix-map
   gptel-cmd-map
   :prefix "C-x c"
   ("x"        . gptel-abort)
   ("i"        . (lambda () (interactive) (gptel--inspect-fsm)))
   ("RET"      . gptel-send)
   ("<return>" . gptel-send)
   :map
   gptel-mode-map
   ("C-c C-n"  . my/gptel-next-prompt)
   ("C-c C-p"  . my/gptel-previous-prompt))
  :hook
  (gptel-mode . turn-off-auto-fill)
  (gptel-mode . visual-line-fill-column-mode)
  (gptel-mode . (lambda () (yas-activate-extra-mode 'gptel-mode)))
  (gptel-mode . my/gptel-prepare-new-chat-buffer)
  (gptel-mode . (lambda () (setq-local gptel-stream t)))
  (gptel-post-stream . gptel-auto-scroll)
  :custom
  (gptel-default-mode 'org-mode)
  (gptel-log-level 'info)
  (gptel-include-reasoning 'ignore)
  (gptel-use-tools t)
  (gptel-stream nil)
  (gptel-track-media t)
  (gptel-use-header-line t)
  (gptel-org-branching-context t)
  (gptel-prompt-prefix-alist
   '((markdown-mode . "# ")
     (org-mode . "*Prompt*: ")
     (text-mode . "# ")))
  (gptel-response-prefix-alist
   '((markdown-mode . "# ")
     (org-mode . "*Response*:\n")
     (text-mode . "# ")))
  :preface
  (defun my/gptel-remove-extra-whitespace (beg end)
    (save-excursion
      (goto-char beg)
      (while (re-search-forward "\n\n\n+" end t)
        (replace-match "\n\n"))))

  (defun my/gptel-previous-prompt ()
    (interactive)
    (goto-char (line-beginning-position))
    (when (re-search-backward
           (regexp-quote (gptel-prompt-prefix-string)) nil t)
      (goto-char (line-end-position))))

  (defun my/gptel-next-prompt (&rest _ignore)
    (interactive)
    (goto-char (line-end-position))
    (when (re-search-forward
           (regexp-quote (gptel-prompt-prefix-string)) nil t)
      (goto-char (line-end-position))))

  (defun my/gptel-prepare-new-chat-buffer ()
    (gptel--apply-preset
     'default
     (lambda (sym val) (set (make-local-variable sym) val)))
    (setq-local gptel--set-buffer-locally t))
  :config
  ;; These are defvars
  (setq gptel-expert-commands t)

  (add-all-to-list 'gptel-post-response-functions
                   #'my/gptel-next-prompt
                   #'my/gptel-remove-extra-whitespace)

  (cl-defmethod gptel--parse-response :after
    ((_backend gptel-openai) response info)
    "Capture request details in RESPONSE into INFO for introspection."
    (when-let* ((usage (plist-get response :timings)))
      (plist-put info :timings
                 (--mapcat (list it (plist-get usage it))
                           '(:predicted_n
                             :predicted_per_second
                             :prompt_n
                             :prompt_per_second))))))
#+end_src

*** gptel-backends

#+name: gptel-define
#+begin_src emacs-lisp :tangle no :exports none
(defun my/gptel-hf-models (server)
    "Return a list of Lisp symbols representing every HF model installed."
    (with-temp-buffer
      (shell-command (format "hf --server %s models" server)
                     (current-buffer))
      (goto-char (point-min))
      (while (re-search-forward "\\(BAAI/\\|sentence-transformers/\\|Warning:\\)" nil t)
        (delete-region (line-beginning-position) (1+ (line-end-position))))
      (sort-lines nil (point-min) (point-max))
      (goto-char (point-max))
      (insert ")")
      (goto-char (point-min))
      (insert "(")
      (forward-char -1)
      (read (current-buffer))))
#+end_src

#+name: models-clio
#+begin_src emacs-lisp :tangle no :exports none :var DEFUN=gptel-define
(my/gptel-hf-models "192.168.50.112")
#+end_src

#+name: models-hera
#+begin_src emacs-lisp :tangle no :exports none :var DEFUN=gptel-define
(my/gptel-hf-models "192.168.50.5")
#+end_src

#+name: models-athena
#+begin_src emacs-lisp :tangle no :exports none :var DEFUN=gptel-define
(my/gptel-hf-models "192.168.50.235")
#+end_src

#+begin_comment
,#+begin_src emacs-lisp :var CLIO=models-clio :var HERA=models-hera :var ATHENA=models-athena
#+end_comment

#+begin_src emacs-lisp
(use-package gptel-backends
  :after (gptel)
  :config
  ;; (gptel-backends-make-clio `(,@CLIO))
  ;; (gptel-backends-make-athena `(,@ATHENA))
  (setq gptel-model 'hera/Qwen3-Coder-480B-A35B-Instruct
        ;; gptel-backend (gptel-backends-make-hera `(,@HERA))
        gptel-backend (gptel-backends-make-litellm)
        ))
#+end_src

*** gptel-presets

#+begin_src emacs-lisp
(use-package gptel-presets
  :after (gptel))
#+end_src

*** gptel-tools

#+begin_src emacs-lisp
(use-package gptel-tools
  :after (gptel)
  :custom
  (gptel-include-tool-results t))
#+end_src

**** gptel-emacs-tools

#+begin_src emacs-lisp
(use-package gptel-emacs-tools
  :load-path "lisp/gptel-emacs-tools"
  :after (gptel-tools))
#+end_src

*** gptel-litellm

#+begin_src emacs-lisp
(use-package gptel-litellm
  :load-path "lisp/gptel-litellm"
  :after (gptel)
  :config
  (gptel-litellm-install-sessions))
#+end_src

*** gptel-org

#+begin_src emacs-lisp
(use-package gptel-org
  :config
  (add-to-list 'gptel-org-ignore-elements 'comment-block))
#+end_src

*** gptel-integrations

#+begin_src emacs-lisp
(use-package gptel-integrations
  :after (org))
#+end_src

*** gptel-transient

#+begin_src emacs-lisp
(use-package gptel-transient
  :after (org)
  :config
  ;; Patch the transient menu so it accept <return> instead of RET.
  ;; I use keyboard return in Emacs, but C-m is bound to a command.
  (when (ignore-errors (transient-get-suffix 'gptel-menu "RET"))
    (transient-suffix-put 'gptel-menu "RET" :key "<return>"))
  (when (ignore-errors (transient-get-suffix 'gptel-tools "RET"))
    (transient-suffix-put 'gptel-tools "RET" :key "<return>")))
#+end_src

*** gptel-rewrite

#+begin_src emacs-lisp
(use-package gptel-rewrite
  :after (gptel)
  :demand t
  :bind (("M-R" . gptel-rewrite)
         :map
         gptel-cmd-map
         ("r" . gptel-rewrite)
         :map gptel-rewrite-actions-map
         ("<return>" . gptel--rewrite-dispatch))
  :custom
  (gptel-rewrite-default-action 'accept))
#+end_src

**** gptel-commit

#+begin_src emacs-lisp
(use-package gptel-commit
  :no-require t
  :after (gptel git-commit)
  :preface
  (defun my/gptel-commit-summary ()
    "Insert a commit message header line in the format I use, followed by a
standard magit (GNU style) changelog.

Don't get the LLM to write the commit message itself, because it's bad
at inferring my intent.

Intended to be placed in `git-commit-setup-hook'."
    (gptel-with-preset 'commit-summary
      (let ((commit-buffer (current-buffer))) ;commit message buffer

        (with-temp-buffer
          (vc-git-command               ;insert diff
           (current-buffer) 1 nil
           "diff-index" "--exit-code" "--patch"
           (and (magit-anything-staged-p) "--cached")
           "HEAD" "--")

          (gptel-request nil            ;Run request on diff buffer contents
            :context commit-buffer
            :callback
            (lambda (resp info)
              (if (not (stringp resp))
                  (message "Git commit summary generation failed")
                (with-current-buffer (plist-get info :context)
                  (save-excursion
                    (goto-char (point-min))
                    (insert resp "\n\n")
                    (magit-generate-changelog))))))))))
  :config
  (gptel-make-preset 'commit-summary
    :system 'commit-summary
    :parents 'rewrite
    :tools nil)

  (add-hook 'git-commit-setup-hook #'my/gptel-commit-summary 50))
#+end_src

*** gptel-context

#+begin_src emacs-lisp
(use-package gptel-context
  :after (gptel)
  :demand t
  :bind (:map
         gptel-cmd-map
         ("a" . gptel-context-add)))
#+end_src

*** gptel-quick

#+begin_src emacs-lisp
(use-package gptel-quick
  :after (gptel)
  :demand t
  :bind (:map
         gptel-cmd-map
         ("q" . gptel-quick)))
#+end_src

*** corsair

#+begin_src emacs-lisp
(use-package corsair
  :demand t
  :bind
  (("M-T" . corsair-open-chat-buffer)
   :map
   gptel-cmd-map
   ("C" . corsair-open-chat-buffer)
   ("w" . corsair-accumulate-selected-text))
  :preface
  (defun gptel-add-asterixes (&rest _ignore)
    (let (inserted)
      (save-excursion
        (goto-char (point-min))
        (when (eolp)
          (insert "* New chat\n\n*Prompt*: ")
          (setq inserted t)
          ))
      (when inserted
        (goto-char (point-max)))))
  :config
  (advice-add #'corsair-open-chat-buffer :after #'gptel-add-asterixes)

  (defun corsair-open-chat-buffer (&optional arg)
    "Open or switch to the GPTel chat buffer and set it up for GPTel."
    (interactive "P")
    (let ((buffer (funcall (if arg
                               #'generate-new-buffer
                             #'get-buffer)
                           corsair-chat-buffer-name)))
      (when (or (null buffer) arg)
        (when (null buffer)
          (setq buffer (get-buffer-create corsair-chat-buffer-name)))
        (with-current-buffer buffer
          (unless (derived-mode-p 'org-mode)
            (org-mode))
          (gptel-mode)))
      (switch-to-buffer buffer))))
#+end_src

*** gptel-ext

#+begin_src emacs-lisp
(use-package gptel-ext
  :after (gptel)
  :demand t
  :bind
  (:map
   gptel-cmd-map
   ("s" . gptel-ext-shorten)
   ("p" . gptel-ext-proofread)
   ("t" . gptel-ext-title)
   :map
   gptel-mode-map
   ("C-c C-t" . gptel-ext-clear-buffer))
  :config
  (push '(code-infill . gptel-ext-code-infill) gptel-directives)

  ;; When chat buffers are saved with C-x C-s, automatically name them into
  ;; the Org-roam directory.
  (gptel-ext-write-to-org-roam-install))
#+end_src

*** ob-gptel

#+begin_src emacs-lisp
(use-package ob-gptel
  :load-path "lisp/ob-gptel"
  :config
  (add-to-list 'org-babel-load-languages '(gptel . t))

  (add-hook 'completion-at-point-functions 'ob-gptel-capf nil t))
#+end_src

*** gptel-prompts

#+begin_src emacs-lisp
(use-package gptel-prompts
  :load-path "lisp/gptel-prompts"
  :after (gptel)
  :config
  (gptel-prompts-update))
#+end_src

*** gptel-rag

#+begin_src emacs-lisp
(use-package gptel-rag
  :load-path "lisp/gptel-rag"
  :after (gptel))
#+end_src

*** gptel-got

#+begin_src emacs-lisp
(use-package gptel-got
  :after (gptel)
  ;; :config
  ;; (mapcar (lambda (tool) (cl-pushnew tool gptel-tools)) gptel-got)
  )
#+end_src

*** COMMENT gptel-aibo

[[https://github.com/dolmens/gptel-aibo][gptel-aibo]] is an AI writing assistant system built on top of [[https://github.com/karthink/gptel][gptel]]. It helps
you create and manage content in Emacs, including code, documents, and even
fiction, along with many other possibilities. As you talk to the LLM, it
automatically sends the content (or a portion of it) that you're currently
working on, allowing you to refer to elements like "this function," "this
class," or "this file," etc. It also defines an action set and its format with
the LLM, so once a response is received, you can easily apply the suggestions
with a single command (=gptel-aibo-apply-last-suggestions=, bound to =C-c !=).

While you can chat with the LLM for complex tasks, when your context is clear
enough, you can use the quick command =gptel-aibo-summon= to invoke the LLM to
generate appropriate content right at your cursor position. If the newly
inserted content has direct implications for the next few lines, the LLM will
adjust them accordingly. All these changes will be displayed using an in-place
diff format. If you accept these inputs, the LLM can even predict what comes
next. At any point, you can press Enter to accept suggestions or Esc to
dismiss them.

The term /aibo/, meaning partner, is currently ambiguous — it could refer to
gptel’s partner, or the user’s.

#+begin_src emacs-lisp
(use-package gptel-aibo
  :commands (gptel-aibo gptel-aibo-summon)
  :bind
  ("C-c !" . gptel-aibo-summon)
  :preface
  (defun my-gptel-aibo-filter-response (orig-func response info)
    (let ((fixed-response
           (and response
                (with-temp-buffer
                  (insert response)
                  (goto-char (point-min))
                  (while (re-search-forward
                          "\\*\\(\\*\\(SEARCH\\|REPLACE\\)\\*\\)\\*" nil t)
                    (replace-match (match-string 1)))
                  (buffer-string)))))
      (funcall orig-func fixed-response info)))
  :config
  (require 'aibo-hack)
  (advice-add 'gptel-aibo--summon-callback
              :around #'my-gptel-aibo-filter-response))
#+end_src

*** macher

[[https://github.com/kmontag/macher][macher]] provides multi-file, project-aware LLM editing capabilities within
Emacs. It allows you to send complex implementation requests and receive
proposed changes as reviewable patches, which can include changes to multiple
files. You can then apply the changes and/or send them back to the LLM for
revision.

The LLM receives contextual information about the current project and file, as
well as tools to read additional project context.

macher is a lightweight Emacs-native take on the editing workflows of more
full-featured tools like [[https://aider.chat/][Aider]] or [[https://plandex.ai/][Plandex]]. It works with any gptel backend
that supports tool use, and aims for a nonintrusive and easily-customizable
UX. Your existing gptel configuration gets extended when making macher
requests, so you can use it alongside other tools.

#+begin_src sh
(use-package macher
 :commands (macher-implement))
#+end_src

*** gptel-fn-complete

#+begin_src emacs-lisp
(use-package gptel-fn-complete
  :bind
  ("C-c . c" . gptel-fn-complete))
#+end_src

*** llm-tool-collection

#+begin_src emacs-lisp
(use-package llm-tool-collection
  :load-path "lisp/llm-tool-collection"
  :config
  (mapcar (apply-partially #'apply #'gptel-make-tool)
          (llm-tool-collection-get-tag 'filesystem))
  (mapcar (apply-partially #'apply #'gptel-make-tool)
          (llm-tool-collection-get-tag 'editing)))
#+end_src

*** mcp

#+begin_src emacs-lisp
(use-package mcp
  :load-path "lisp/mcp.el"
  :after (gptel)
  :custom
  (mcp-hub-servers
   `(
     ;; ("brave-search" :command "mcp-server-brave-search")
     ;; ("fetch" :command "mcp-server-fetch")
     ;; ("filesystem" :command "mcp-server-filesystem"
     ;;  :args (,(expand-file-name "~/Products/")))
     ;; ("gdrive" :command "mcp-server-gdrive")
     ;; ("git" :command "mcp-server-git")
     ;; ("google-maps" :command "mcp-server-google-maps")
     ;; ("memory" :command "mcp-server-memory")
     ;; ("postgres" :command "mcp-server-postgres")
     ;; ("sequential-thinking" :command "mcp-server-sequential-thinking")
     ;; ("slack" :command "mcp-server-slack")
     ;; ("sqlite" :command "mcp-server-sqlite")
     ;; ("time" :command "mcp-server-time")
     ("github" :command "github-mcp-server"
      :args ("stdio")
      :env (:GITHUB_PERSONAL_ACCESS_TOKEN
            ,(lookup-password "api.github.com" "johnw" 80)))
     ("nixos"
      :command "uvx"
      :args ("--isolated" "--from" "mcp-nixos" "mcp-nixos" "--"))
     ("org-mcp"
      :command "uvx"
      :args ("--isolated" "--from" "org-mcp" "org-mcp"
             "--org-dir" ,org-directory)))))
#+end_src

** grep

#+begin_src emacs-lisp
(use-package grep
  :bind (("M-s n" . find-name-dired)
         ("M-s F" . find-grep)
         ("M-s D" . find-grep-dired))
  :custom
  (grep-command "egrep -nH -e ")
  (grep-find-command
   "find . -name '*' -type f -print0 | xargs -0 -P8 egrep -nH ")
  (grep-save-buffers t))
#+end_src

** gud

#+begin_src emacs-lisp
(use-package gud
  :commands gud-gdb
  :bind (("<f9>"    . gud-cont)
         ("<f10>"   . gud-next)
         ("<f11>"   . gud-step)
         ("S-<f11>" . gud-finish))
  :custom
  (gdb-find-source-frame t)
  (gdb-same-frame nil)
  :init
  (defun show-debugger ()
    (interactive)
    (let ((gud-buf
           (catch 'found
             (dolist (buf (buffer-list))
               (if (string-match "\\*gud-" (buffer-name buf))
                   (throw 'found buf))))))
      (if gud-buf
          (switch-to-buffer-other-window gud-buf)
        (call-interactively #'gud-gdb)))))
#+end_src

** COMMENT hammy

#+begin_src emacs-lisp
(use-package hammy
  :config
  ;; We name the timer with the Unicode TOMATO character, and propertize it
  ;; with a tomato-colored face.
  (hammy-define (propertize "🍅" 'face '(:foreground "tomato"))
    :documentation "The classic pomodoro timer."
    :intervals
    (list
     (interval :name "Work"
               :duration "25 minutes"
               :before (announce "Starting work time.")
               :advance (announce "Break time!"))
     (interval :name "Break"
               :duration (if (and (not (zerop cycles))
                                  (zerop (mod cycles 3)))
                             ;; If a multiple of three cycles have elapsed,
                             ;; the fourth work period was just completed, so
                             ;; take a longer break.
                             "30 minutes"
                           "5 minutes")
               :before (announce "Starting break time.")
               :advance (announce "Break time is over!")))))
#+end_src

** COMMENT haskell-edit

#+begin_src emacs-lisp
(use-package haskell-edit
  :load-path "lisp/haskell-config"
  :after haskell-mode
  :bind (:map haskell-mode-map
              ("C-c M-q" . haskell-edit-reformat)))
#+end_src

** help

#+begin_src emacs-lisp
(use-package help
  :defer t
  :custom
  (temp-buffer-resize-mode t))
#+end_src

** helpful

#+begin_src emacs-lisp
(use-package helpful
  :bind (("C-h e F" . helpful-function)
         ("C-h e C" . helpful-command)
         ("C-h e M" . helpful-macro)
         ("C-h e L" . helpful-callable)
         ("C-h e S" . helpful-at-point)
         ("C-h e V" . helpful-variable)))
#+end_src

** hi-lock

#+begin_src emacs-lisp
(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
#+end_src

** hideif

#+begin_src emacs-lisp
(use-package hideif
  :diminish hide-ifdef-mode
  :hook (c-mode-common . hide-ifdef-mode))
#+end_src

** hideshow

#+begin_src emacs-lisp
(use-package hideshow
  :diminish hs-minor-mode
  :hook (prog-mode . hs-minor-mode)
  :bind (:map prog-mode-map
              ("C-c h" . hs-toggle-hiding)))
#+end_src

** highlight

#+begin_src emacs-lisp
(use-package highlight
  :bind (("C-c H H" . hlt-highlight-region)
         ("C-c H U" . hlt-unhighlight-region)))
#+end_src

** highlight-cl

#+begin_src emacs-lisp
(use-package highlight-cl
  :hook (emacs-lisp-mode . highlight-cl-add-font-lock-keywords))
#+end_src

** highlight-defined

#+begin_src emacs-lisp
(use-package highlight-defined
  :commands highlight-defined-mode
  :custom
  (highlight-defined-face-use-itself t)
  :hook
  (help-mode . highlight-defined-mode)
  (emacs-lisp-mode . highlight-defined-mode))
#+end_src

** highlight-numbers

#+begin_src emacs-lisp
(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))
#+end_src

** highlight-quoted

#+begin_src emacs-lisp
(use-package highlight-quoted
  :ensure t
  :hook
  (emacs-lisp-mode . highlight-quoted-mode))
#+end_src

** hilit-chg

#+begin_src emacs-lisp
(use-package hilit-chg
  :bind ("M-o C" . highlight-changes-mode))
#+end_src

** COMMENT hippie-exp

#+begin_src emacs-lisp
(use-package hippie-exp
  :nix nil
  :bind (("M-/"   . hippie-expand)
         ("C-M-/" . dabbrev-completion))
  :custom
  (hippie-expand-try-functions-list
   '(try-expand-dabbrev
     try-expand-dabbrev-all-buffers
     try-expand-dabbrev-from-kill
     try-complete-file-name-partially
     try-complete-file-name
     try-expand-all-abbrevs
     try-expand-list
     try-expand-line
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol)))
#+end_src

** hl-line

#+begin_src emacs-lisp
(use-package hl-line
  :commands hl-line-mode
  :bind ("M-o h" . hl-line-mode))
#+end_src

*** hl-line+

#+begin_src emacs-lisp
(use-package hl-line+
  :nix hl-line-plus
  :after hl-line)
#+end_src

** COMMENT hl-todo

#+begin_src emacs-lisp
(use-package hl-todo
  :demand t
  :commands hl-todo-mode
  :diminish hl-todo-mode
  :custom
  (hl-todo-keyword-faces
   '(("TODO"  . "#FF0000")
     ("FIXME" . "#FF0000")
     ("DEBUG" . "#A020F0")))
  :preface
  (defun consult-ripgrep-haskell-todo ()
    (interactive)
    (consult-ripgrep nil "\\b\\(TODO\\|error\\|undefined\\|NYI\\|jww\\|FIXME\\)\\b"))
  :config
  (global-hl-todo-mode)

  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-commands
               '(consult-ripgrep-haskell-todo buffer)))
#+end_src

** ialign

To use [[https://github.com/mkcms/interactive-align][ialign]], mark a region and then call =ialign=. You can enter a regexp in
the minibuffer that will be passed to =align-regexp= command. As the contents of
minibuffer change, the region is realigned.

#+begin_src emacs-lisp
(use-package ialign
  :bind ("C-c {" . ialign))
#+end_src

** ibuffer

#+begin_src emacs-lisp
(use-package ibuffer
  :bind ("C-x C-b" . ibuffer)
  :custom
  (ibuffer-default-display-maybe-show-predicates t)
  (ibuffer-expert t)
  (ibuffer-formats
   '((mark modified read-only " "
           (name 16 -1)
           " "
           (size 6 -1 :right)
           " "
           (mode 16 16)
           " " filename)
     (mark " "
           (name 16 -1)
           " " filename)))
  (ibuffer-maybe-show-regexps nil)
  (ibuffer-saved-filter-groups
   '(("default"
      ("Magit"
       (or
        (mode . magit-status-mode)
        (mode . magit-log-mode)
        (name . "\\*magit")
        (name . "magit-")
        (name . "git-monitor")))
      ("Coq"
       (or
        (mode . coq-mode)
        (name . "\\<coq\\>")
        (name . "_CoqProject")))
      ("Commands"
       (or
        (mode . shell-mode)
        (mode . eshell-mode)
        (mode . term-mode)
        (mode . compilation-mode)))
      ("Haskell"
       (or
        (mode . haskell-mode)
        (mode . haskell-cabal-mode)
        (mode . haskell-literate-mode)))
      ("Rust"
       (or
        (mode . rust-mode)
        (mode . cargo-mode)
        (name . "\\*Cargo")
        (name . "^\\*rls\\(::stderr\\)?\\*")
        (name . "eglot")))
      ("Nix"
       (mode . nix-mode))
      ("C++"
       (or
        (mode . c-mode)
        (mode . c++-mode)))
      ("Lisp"
       (mode . emacs-lisp-mode))
      ("Dired"
       (mode . dired-mode))
      ("Gnus"
       (or
        (mode . message-mode)
        (mode . mail-mode)
        (mode . gnus-group-mode)
        (mode . gnus-summary-mode)
        (mode . gnus-article-mode)
        (name . "^\\.newsrc-dribble")
        (name . "^\\*\\(sent\\|unsent\\|fetch\\)")
        (name . "^ \\*\\(nnimap\\|nntp\\|nnmail\\|gnus\\|server\\|mm\\*\\)")
        (name . "\\(Original Article\\|canonical address\\|extract address\\)")))
      ("Org"
       (or
        (name . "^\\*Calendar\\*$")
        (name . "^\\*Org Agenda")
        (name . "^ \\*Agenda")
        (mode . org-mode)))
      ("Emacs"
       (or
        (name . "^\\*scratch\\*$")
        (name . "^\\*Messages\\*$")
        (name . "^\\*\\(Customize\\|Help\\)")
        (name . "\\*\\(Echo\\|Minibuf\\)"))))))
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-shrink-to-minimum-size t t)
  (ibuffer-use-other-window t)
  :init
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default"))))
#+end_src

** COMMENT iedit

#+begin_src emacs-lisp
(use-package iedit
  :defer t)
#+end_src

** COMMENT iflipb

#+begin_src emacs-lisp
(use-package iflipb
  :bind* ("C-<backspace>" . my-iflipb-next-buffer)
  :commands (iflipb-next-buffer iflipb-previous-buffer)
  :preface
  (defvar my-iflipb-auto-off-timeout-sec 1)
  (defvar my-iflipb-auto-off-timer nil)
  (defvar my-iflipb-auto-off-timer-canceler-internal nil)
  (defvar my-iflipb-ing-internal nil)

  (defun my-iflipb-auto-off ()
    (setq my-iflipb-auto-off-timer-canceler-internal nil
          my-iflipb-ing-internal nil)
    (when my-iflipb-auto-off-timer
      (message nil)
      (cancel-timer my-iflipb-auto-off-timer)
      (setq my-iflipb-auto-off-timer nil)))

  (defun my-iflipb-next-buffer (arg)
    (interactive "P")
    (iflipb-next-buffer arg)
    (if my-iflipb-auto-off-timer-canceler-internal
        (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
    (setq my-iflipb-auto-off-timer
          (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0
                               'my-iflipb-auto-off)
          my-iflipb-ing-internal t))

  (defun my-iflipb-previous-buffer ()
    (interactive)
    (iflipb-previous-buffer)
    (if my-iflipb-auto-off-timer-canceler-internal
        (cancel-timer my-iflipb-auto-off-timer-canceler-internal))
    (setq my-iflipb-auto-off-timer
          (run-with-idle-timer my-iflipb-auto-off-timeout-sec 0
                               'my-iflipb-auto-off)
          my-iflipb-ing-internal t))

  :config
  (setq iflipb-always-ignore-buffers
        "\\`\\( \\|\\.newsrc-dribble\\'\\)"
        iflipb-wrap-around t)

  (defun iflipb-first-iflipb-buffer-switch-command ()
    (not (and (or (eq last-command 'my-iflipb-next-buffer)
                  (eq last-command 'my-iflipb-previous-buffer))
              my-iflipb-ing-internal))))
#+end_src

** image-file

#+begin_src emacs-lisp
(use-package image-file
  :demand t
  :hook
  (image-mode . image-transform-reset-to-initial)
  :config
  (auto-image-file-mode 1))
#+end_src

** imenu-list

#+begin_src emacs-lisp
(use-package imenu-list
  :commands imenu-list-minor-mode)
#+end_src

** indent

#+begin_src emacs-lisp
(use-package indent
  :commands indent-according-to-mode
  :custom
  (tab-always-indent 'complete))
#+end_src

** indent-shift

#+begin_src emacs-lisp
(use-package indent-shift
  :bind (("C-c <" . indent-shift-left)
         ("C-c >" . indent-shift-right)))
#+end_src

** info

#+begin_src emacs-lisp
(use-package info
  :bind ("C-h C-i" . info-lookup-symbol)
  :custom
  ;; (Info-default-directory-list (list (emacs-path "lisp/org-mode/doc")))
  (Info-fit-frame-flag nil)
  :preface
  (eval-when-compile
    (defvar buffer-face-mode-face))

  (defun nix-read-environment (name)
    (ignore-errors
      (with-temp-buffer
        (insert-file-contents-literally
         (with-temp-buffer
           (insert-file-contents-literally
            (executable-find (concat "load-env-" name)))
           (and (re-search-forward "^source \\(.+\\)$" nil t)
                (match-string 1))))
        (and (or (re-search-forward "^  nativeBuildInputs=\"\\(.+?\\)\"" nil t)
                 (re-search-forward "^  buildInputs=\"\\(.+?\\)\"" nil t))
             (split-string (match-string 1))))))
  :init
  (setq Info-default-directory-list
        (mapcar
         'expand-file-name
         (append
          (and emacs-environment
               (mapcar (apply-partially #'expand-file-name "share/info")
                       (nix-read-environment emacs-environment)))
          (list "~/.local/share/info"
                (and (getenv "PROFILE_DIR")
                     (expand-file-name "share/info" (getenv "PROFILE_DIR")))))))
  :config
  (add-hook 'Info-mode-hook
            (lambda ()
              (setq buffer-face-mode-face '(:family "Bookerly"))
              (buffer-face-mode)
              (text-scale-adjust 1))))
#+end_src

** inheritenv

Environment variables in Emacs can be set buffer-locally, like many Emacs
preferences, which allows users to have different buffer-local paths for
executables in different projects, specified by a ".dir-locals.el" file or via
a "direnv" integration like envrc (see https://github.com/purcell/envrc).

However, there's a fairly common pitfall when Emacs libraries run background
processes on behalf of a user: many such libraries run processes in temporary
buffers that do not inherit the calling buffer's environment. This can result
in executables not being found, or the wrong versions of executables being
picked up.

An example is the Emacs built-in command =shell-command-to-string=. Whatever
buffer-local =process-environment= (or =exec-path=) the user has set, that command
will always use the Emacs-wide default. This is *specified* behaviour, but not
*expected* or *helpful*.

=inheritenv= provides a couple of tools for dealing with this issue:

1. Library authors can wrap code that plans to execute processes in temporary
   buffers with the =inheritenv= macro.
2. End users can modify commands like =shell-command-to-string= using the
   =inheritenv-add-advice= macro.

Any buffer-local values for TRAMP's corresponding vars (=tramp-remote-path= and
=tramp-remote-process-environment=) are also propagated.

#+begin_src emacs-lisp
(use-package inheritenv)
#+end_src

** COMMENT inhibit-mouse

#+begin_src emacs-lisp
(use-package inhibit-mouse
  :diminish
  :config
  (inhibit-mouse-mode)

  (add-hook 'inhibit-mouse-mode-hook
            (lambda()
              ;; Enable or disable highlighting of clickable text based on
              ;; whether `inhibit-mouse-mode` is active
              (setq mouse-highlight (not (bound-and-true-p inhibit-mouse-mode)))))

  ;; Disable help display when hovering over items
  (setq show-help-function nil)

  (add-hook 'inhibit-mouse-mode-hook
            (lambda()
              ;; Enable or disable the context menu based on the state of
              ;; `inhibit-mouse-mode', the following code dynamically
              ;; toggles `context-menu-mode' accordingly.
              (when (fboundp 'context-menu-mode)
                (if (bound-and-true-p inhibit-mouse-mode)
                    (context-menu-mode -1)
                  (context-menu-mode 1))))))
#+end_src

** ipcalc

#+begin_src emacs-lisp
(use-package ipcalc
  :commands ipcalc)
#+end_src

** isearch

#+begin_src emacs-lisp
(use-package isearch
  :no-require t
  :bind (("C-M-r" . isearch-backward-other-window)
         ("C-M-s" . isearch-forward-other-window))
  :bind (:map isearch-mode-map
              ("C-c" . isearch-toggle-case-fold)
              ("C-t" . isearch-toggle-regexp)
              ("C-^" . isearch-edit-string)
              ("C-i" . isearch-complete))
  :preface
  (defun isearch-backward-other-window ()
    (interactive)
    (split-window-vertically)
    (other-window 1)
    (call-interactively #'isearch-backward))

  (defun isearch-forward-other-window ()
    (interactive)
    (split-window-vertically)
    (other-window 1)
    (call-interactively #'isearch-forward)))
#+end_src

** ispell

#+begin_src emacs-lisp
(use-package ispell
  :bind (:prefix-map
         my-ispell-map
         :prefix "C-c i"
         ("c" . ispell-comments-and-strings)
         ("d" . ispell-change-dictionary)
         ("k" . ispell-kill-ispell)
         ("m" . ispell-message)
         ("r" . ispell-region))
  :custom
  (ispell-extra-args '("--sug-mode=fast" "--keyboard=dvorak")))
#+end_src

** jinx

#+begin_src emacs-lisp
(use-package jinx
  :diminish jinx-mode
  :bind
  ("M-$" . jinx-correct)
  ("C-M-$" . jinx-languages)
  :config
  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-categories
               '(jinx grid (vertico-grid-annotate . 20))))
#+end_src

** jka-compr

#+begin_src emacs-lisp
(use-package jka-compr
  :defer t
  :custom
  (auto-compression-mode t))
#+end_src

** COMMENT jobhours

#+begin_src emacs-lisp
(use-package jobhours
  ;; Load this immediately so it appears in the mode-line
  :demand t
  :bind ("M-o j" . jobhours-update-string))
#+end_src

*** jobhours-org

#+begin_src emacs-lisp
(use-package jobhours-org
  :no-require t
  :demand t
  :config
  (defun my/org-insert-jobhours-string ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (goto-char (line-end-position))
      (let* ((width (- (window-width) (current-column)))
             (jobhours (jobhours-get-string t))
             (spacer (- width (length jobhours)))
             (inhibit-read-only t))
        (when (> spacer 0)
          (insert (make-string spacer ? ) jobhours)))))

  (defun my/org-delayed-update ()
    (run-with-idle-timer
     1 nil
     `(lambda ()
        (with-current-buffer ,(current-buffer)
          (org-save-all-org-buffers)
          (my/org-insert-jobhours-string)))))

  (add-hook 'org-agenda-finalize-hook #'my/org-delayed-update t))
#+end_src

** jq-mode

#+begin_src emacs-lisp
(use-package jq-mode
  :mode "\\.jq\\'")
#+end_src

** js2-mode

#+begin_src emacs-lisp
(use-package js2-mode
  :mode "\\.js\\'")
#+end_src

** COMMENT jupyter

#+begin_src emacs-lisp
(use-package jupyter
  :commands (jupyter-run-server-repl
             jupyter-run-repl
             jupyter-server-list-kernels))
#+end_src

*** COMMENT Using sagemath with Org-babel and Jupyter

#+begin_src jupyter-python :kernel sagemath
2^4
#+end_src

#+RESULTS:
: 16

** key-chord

#+begin_src emacs-lisp
(use-package key-chord
  :commands key-chord-mode)
#+end_src

** keypression

#+begin_src emacs-lisp
(use-package keypression
  :commands key-chord-mode)
#+end_src

** know-your-http-well

#+begin_src emacs-lisp
(use-package know-your-http-well
  :commands (http-header
             http-method
             http-relation
             http-status-code
             media-type))
#+end_src

** link-hint

#+begin_src emacs-lisp
(use-package link-hint
  :bind ("C-c C-o" . link-hint-open-link)
  :preface
  (eval-when-compile
    (defvar eww-mode-map)
    (defvar w3m-mode-map))
  :config
  (add-hook 'eww-mode-hook
            (lambda () (bind-key "f" #'link-hint-open-link eww-mode-map)))
  (add-hook 'w3m-mode-hook
            (lambda () (bind-key "f" #'link-hint-open-link w3m-mode-map))))
#+end_src

** listen

#+begin_src emacs-lisp
(use-package listen
  :commands (listen-play)
  :bind
  ("C-c E p" . listen-pause)
  ("C-c E q" . listen-quit))
#+end_src

** lively

#+begin_src emacs-lisp
(use-package lively
  :commands lively-stop
  :bind ("C-x C-E" . lively))
#+end_src

** machines

#+begin_src emacs-lisp
(use-package m
  :load-path "lisp/machines"
  :defer t)
#+end_src

** macrostep

#+begin_src emacs-lisp
(use-package macrostep
  :bind (("C-c e m" . macrostep-expand)
         ("C-c e M" . macrostep-expand-use-package-minimally))
  :preface
  (defun macrostep-expand-use-package-minimally ()
    (interactive)
    (let ((use-package-expand-minimally t)
          (use-package-compute-statistics nil))
      (call-interactively #'macrostep-expand))))
#+end_src

** magit

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)
         ("C-x G" . magit-status-with-prefix))
  :bind (:map magit-mode-map
              ("U" . magit-unstage-all)
              ("M-h")
              ("M-s")
              ("M-m")
              ("M-w"))
  :bind (:map magit-file-section-map ("<C-return>"))
  :bind (:map magit-hunk-section-map ("<C-return>"))
  :custom
  (magit-diff-options nil)
  (magit-diff-refine-hunk t)
  (magit-fetch-arguments nil)
  ;; This is done for the sake of performance on macOS
  (magit-git-executable "/usr/bin/git")
  (magit-highlight-trailing-whitespace nil)
  (magit-highlight-whitespace nil)
  (magit-log-section-commit-count 10)
  (magit-pre-refresh-hook nil)
  (magit-process-popup-time 15)
  (magit-push-always-verify nil)
  ;; You can tell Magit to only automatically refresh the current Magit
  ;; buffer, but not the status buffer. If you do that, then the status buffer
  ;; is only refreshed automatically if it is the current buffer.
  (magit-refresh-status-buffer nil)
  (magit-section-initial-visibility-alist '((untracked . hide)))
  (magit-stage-all-confirm nil)
  (magit-unstage-all-confirm nil)
  (magit-use-overlays nil)
  :preface
  ;; History can be viewed with:
  ;; git log refs/snapshots/$(git symbolic-ref HEAD)
  (defun magit-monitor (&optional _no-display)
    "Start git-monitor in the current directory."
    (interactive)
    (let* ((path (file-truename
                  (directory-file-name
                   (expand-file-name default-directory))))
           (name (format "*git-monitor: %s*"
                         (file-name-nondirectory path))))
      (unless (and (get-buffer name)
                   (with-current-buffer (get-buffer name)
                     (string= path (directory-file-name default-directory))))
        (with-current-buffer (get-buffer-create name)
          (cd path)
          (if (file-regular-p ".git")
              (let ((branch (string-chop-newline
                             (shell-command-to-string
                              "git branch --show-current")))
                    (repo
                     (with-temp-buffer
                       (insert-file-contents-literally ".git")
                       (goto-char (point-min))
                       (and (looking-at "^gitdir: \\(.+?/\\.git/\\)")
                            (match-string 1)))))
                (when repo
                  (ignore-errors
                    (start-process "*git-monitor*" (current-buffer)
                                   "git-monitor"
                                   "--git-dir" repo
                                   "--work-dir" path
                                   "-r" (concat "refs/heads/" branch)))))
            (ignore-errors
              (start-process "*git-monitor*" (current-buffer)
                             "git-monitor" "--work-dir" path)))))))

  (defun magit-status-with-prefix ()
    (interactive)
    (let ((current-prefix-arg '(4)))
      (call-interactively #'magit-status)))

  (defun endless/visit-pull-request-url ()
    "Visit the current branch's PR on Github."
    (interactive)
    (browse-url
     (format "https://github.com/%s/pull/new/%s"
             (replace-regexp-in-string
              "\\`.+github\\.com:\\(.+?\\)\\(\\.git\\)?\\'" "\\1"
              (magit-get "remote" (magit-get-remote) "url"))
             (magit-get-current-branch))))

  (defvar magit--call-git-cache (make-hash-table :test #'equal))

  (defun my-magit-cache-config (orig-func &rest args)
    (or (and (string= (car args) "config")
             (gethash args magit--call-git-cache))
        (let ((result (apply orig-func args)))
          (puthash args result magit--call-git-cache)
          result)))
  :hook (magit-mode . hl-line-mode)
  :config
  (add-hook 'magit-status-mode-hook (lambda () (magit-monitor t)))

  (define-key magit-mode-map "G" #'endless/visit-pull-request-url)

  ;; Magit also reverts buffers for visited files located inside the current
  ;; repository when the visited file changes on disk. That is implemented on
  ;; top of auto-revert-mode from the built-in library autorevert. To figure
  ;; out whether that impacts performance, check whether performance is
  ;; significantly worse, when many buffers exist and/or when some buffers
  ;; visit files using TRAMP. If so, then this should help.
  (setq auto-revert-buffer-list-filter
        'magit-auto-revert-repository-buffer-p)

  ;; When refreshing the "references buffer" is slow, then that’s usually
  ;; because several hundred refs are being displayed. The best way to address
  ;; that is to display fewer refs, obviously.
  (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

  ;; When you initiate a commit, then Magit by default automatically shows a
  ;; diff of the changes you are about to commit. For large commits this can
  ;; take a long time, which is especially distracting when you are committing
  ;; large amounts of generated data which you don’t actually intend to
  ;; inspect before committing. This behavior can be turned off using:
  (remove-hook 'server-switch-hook 'magit-commit-diff)
  (remove-hook 'with-editor-filter-visit-hook 'magit-commit-diff)

  (advice-add 'magit-git-items :around #'my-magit-cache-config)

  (use-package magit-commit
    :defer t
    :config
    (use-package git-commit
      :custom
      (git-commit-major-mode 'markdown-mode)
      (git-commit-setup-hook
       '(git-commit-save-message
         git-commit-turn-on-auto-fill
         git-commit-turn-on-flyspell
         bug-reference-mode))))

  (use-package magit-pull
    :defer t
    :config
    (transient-insert-suffix 'magit-pull "p"
      '("F" "default" magit-fetch-from-upstream)))

  (use-package magit-push
    :defer t
    :config
    (transient-insert-suffix 'magit-push "p"
      '("P" "default" magit-push-current-to-upstream)))

  ;; (use-package magit-status
  ;;   :defer t
  ;;   :config
  ;;   ;; Speed up Magit status by not generating all of the available sections.
  ;;   (dolist (func '(
  ;;                   ;; magit-insert-status-headers
  ;;                   ;; magit-insert-untracked-files
  ;;                   ;; magit-insert-unstaged-changes
  ;;                   ;; magit-insert-staged-changes
  ;;                   ;; magit-insert-stashes
  ;;                   ;; magit-insert-unpushed-to-pushremote
  ;;                   magit-insert-unpushed-to-upstream-or-recent
  ;;                   magit-insert-unpulled-from-pushremote
  ;;                   magit-insert-unpulled-from-upstream
  ;;                   ))
  ;;     (remove-hook 'magit-status-sections-hook func))

  ;;   (dolist (func '(
  ;;                   ;; magit-insert-error-header
  ;;                   magit-insert-diff-filter-header
  ;;                   ;; magit-insert-head-branch-header
  ;;                   ;; magit-insert-upstream-branch-header
  ;;                   ;; magit-insert-push-branch-header
  ;;                   magit-insert-tags-header
  ;;                   ))
  ;;     (remove-hook 'magit-status-headers-hook func)))
  )
#+end_src

*** magit-autorevert

#+begin_src emacs-lisp
(use-package magit-autorevert
  :after magit
  :custom
  (magit-auto-revert-mode nil))
#+end_src

*** COMMENT magit-lfs

#+begin_src emacs-lisp
(use-package magit-lfs
  :after magit)
#+end_src

*** magit-popup

#+begin_src emacs-lisp
(use-package magit-popup
  :after magit)
#+end_src

*** magit-todos

#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :custom
  (magit-todos-keyword-suffix " ?([^)]+):")
  (magit-todos-keywords '("jww" "FIXME"))
  (magit-todos-exclude-globs '(".git/" "/archive/"))
  :config
  (magit-todos-mode 1))
#+end_src

*** forge

#+begin_src emacs-lisp
(use-package forge
  :after magit
  :bind (:map forge-common-map
              ("C-<return>"))
  :custom
  (forge-database-file "~/.config/forge/database.sqlite")
  (forge-owned-accounts '(("jwiegley")))
  :preface
  (defun my-quick-create-pull-request (_title branch)
    (interactive "sTitle: \nsBranch: ")
    (setq branch (concat "johnw/" branch))
    ;; Split this commit to another branch.
    (magit-branch-spinoff branch)
    ;; Push that branch to the remote.
    (call-interactively #'magit-push-current-to-pushremote)
    (sleep-for 3)
    ;; Create a pullreq using the same title.
    (forge-create-pullreq (concat "origin/" branch) "origin/master"))
  :config
  (transient-insert-suffix 'forge-dispatch "c i"
    '("p" "quick-pr" my-quick-create-pull-request)))
#+end_src

*** COMMENT magit-annex

#+begin_src emacs-lisp
(use-package magit-annex
  :after magit)
#+end_src

*** COMMENT magit-imerge

#+begin_src emacs-lisp
(use-package magit-imerge
  :after magit)
#+end_src

*** magit-tbdiff

#+begin_src emacs-lisp
(use-package magit-tbdiff
  :after magit)
#+end_src

** markdown-mode

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode (("\\`README\\.md\\'" . gfm-mode)
         ("\\.md\\'"          . markdown-mode)
         ("\\.markdown\\'"    . markdown-mode))
  :custom
  (markdown-command "pandoc -f markdown_github+smart")
  (markdown-command-needs-filename t)
  (markdown-enable-math t)
  (markdown-open-command "marked")
  :custom-face
  (markdown-header-face-1 ((t (:inherit markdown-header-face :height 2.0))))
  (markdown-header-face-2 ((t (:inherit markdown-header-face :height 1.6))))
  (markdown-header-face-3 ((t (:inherit markdown-header-face :height 1.4))))
  (markdown-header-face-4 ((t (:inherit markdown-header-face :height 1.2))))
  :init
  (setq markdown-command "multimarkdown"))
#+end_src

*** markdown-preview-mode

#+begin_src emacs-lisp
(use-package markdown-preview-mode
  :after markdown-mode
  :config
  (setq markdown-preview-stylesheets
        (list (concat "https://github.com/dmarcotte/github-markdown-preview/"
                      "blob/master/data/css/github.css"))))
#+end_src

** math-symbol-lists

#+begin_src emacs-lisp
(use-package math-symbol-lists
  :defer t)
#+end_src

** mediawiki

#+begin_src emacs-lisp
(use-package mediawiki
  :commands mediawiki-open
  :custom
  (mediawiki-site-alist
   '(("Wikipedia" "https://en.wikipedia.org/w/" "jwiegley" "" nil "Main Page"))))
#+end_src

** memory-usage

#+begin_src emacs-lisp
(use-package memory-usage
  :commands memory-usage)
#+end_src

** COMMENT mic-paren

Load [[https://github.com/emacsattic/mic-paren/blob/master/mic-paren.el][mic-paren.el]], activate it and Emacs will display highlighting on whatever
parenthesis (and paired delimiter if you like this) matches the one before or
after point. This is an extension to the =paren.el= file distributed with Emacs.
The default behaviour is similar to =paren.el= but more sophisticated. Normally
you can try all default settings to enjoy =mic-paren=.

#+begin_src emacs-lisp
(use-package mic-paren
  :defer 5
  :config
  (paren-activate))
#+end_src

** midnight

#+begin_src emacs-lisp
(use-package midnight
  :demand t
  :bind ("C-c z" . clean-buffer-list)
  :custom
  (midnight-delay 18000)
  (clean-buffer-list-kill-never-buffer-names
   (append '("*scratch*"
             "*Messages*"
             "*server*"
             "*Group*"
             "*Org Agenda*"
             "*GPTel Chat*")
           org-constants-protected-basenames-list))
  (clean-buffer-list-kill-never-regexps
   '("^ \\*Minibuf-.*\\*$"
     "^\\*Summary"
     "^\\*gptel-aibo:"
     "^\\*Article" "^#"))
  (clean-buffer-list-kill-regexps '(".*"))
  :config
  (midnight-mode t))
#+end_src

** COMMENT minimap

#+begin_src emacs-lisp
(use-package minimap
  :commands minimap-mode)
#+end_src

** moccur-edit

#+begin_src emacs-lisp
(use-package moccur-edit
  :after color-moccur)
#+end_src

** COMMENT monitor

#+begin_src emacs-lisp
(use-package monitor
  :defer t
  :init
  (autoload #'define-monitor "monitor"))
#+end_src

** move-lines

#+begin_src emacs-lisp
(use-package move-lines
  :no-require t
  :demand t
  :bind (([(meta shift up)]   . my/move-line-up)
         ([(meta shift down)] . my/move-line-down))
  :preface
  (defun my/move-line-up ()
    (interactive)
    (transpose-lines 1)
    (forward-line -2))

  (defun my/move-line-down ()
    (interactive)
    (forward-line 1)
    (transpose-lines 1)
    (forward-line -1)))
#+end_src

** move-text

#+begin_src emacs-lisp
(use-package move-text
  :demand t
  :preface
  (defun indent-region-advice (&rest ignored)
    (let ((deactivate deactivate-mark))
      (if (region-active-p)
          (indent-region (region-beginning) (region-end))
        (indent-region (line-beginning-position) (line-end-position)))
      (setq deactivate-mark deactivate)))
  :config
  (move-text-default-bindings)

  (advice-add 'move-text-up :after 'indent-region-advice)
  (advice-add 'move-text-down :after 'indent-region-advice))
#+end_src

** mule

#+begin_src emacs-lisp
(use-package mule
  :defer t
  :custom
  ;; mule-cmds.el
  (current-language-environment "UTF-8")
  :config
  (set-terminal-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** multi-term

#+begin_src emacs-lisp
(use-package multi-term
  :bind (("C-c t" . multi-term-next)
         ("C-c T" . multi-term))
  :custom
  (multi-term-program "tmux")
  (multi-term-program-switches "-CC")
  (multi-term-scroll-show-maximum-output t)
  (term-bind-key-alist
   '(("C-c C-c" . term-interrupt-subjob)
     ("C-b"     . my-term-send-raw-at-prompt)
     ("C-f"     . my-term-send-raw-at-prompt)
     ("C-a"     . my-term-send-raw-at-prompt)
     ("C-e"     . my-term-send-raw-at-prompt)
     ("C-p"     . previous-line)
     ("C-n"     . next-line)
     ("C-s"     . isearch-forward)
     ("C-r"     . isearch-backward)
     ("C-m"     . term-send-raw)
     ("M-f"     . term-send-forward-word)
     ("M-b"     . term-send-backward-word)
     ("M->"     . my-term-end-of-buffer)
     ("M-o"     . term-send-backspace)
     ("M-p"     . term-send-up)
     ("M-n"     . term-send-down)
     ("M-d"     . term-send-forward-kill-word)
     ("M-DEL"   . term-send-backward-kill-word)
     ("M-r"     . term-send-reverse-search-history)
     ("M-,"     . term-send-input)
     ("M-/"     . comint-dynamic-complete)
     ("C-y"     . term-paste)))
  :init
  (defun screen ()
    (interactive)
    (let ((term-buffer
           (let ((multi-term-program (executable-find "screen"))
                 (multi-term-program-switches "-DR"))
             (multi-term-get-buffer))))
      (set-buffer term-buffer)
      (multi-term-internal)
      (switch-to-buffer term-buffer)))

  :config
  (require 'term)

  (defalias 'my-term-send-raw-at-prompt 'term-send-raw)

  (defun my-term-end-of-buffer ()
    (interactive)
    (call-interactively #'end-of-buffer)
    (if (and (eobp) (bolp))
        (delete-char -1)))

  (advice-add 'term-process-pager :after
              (lambda () (define-key term-pager-break-map "\177"
                                #'term-pager-back-page))))
#+end_src

** multifiles

Bind a key to =mf/mirror-region-in-multifile=, let's say =C-!=. Now mark a part of
the buffer and press it. A new =*multifile*= buffer pops up. Mark some other
part of another file, and press =C-!= again. This is added to the =*multifile*=.

You can now edit the =*multifile*= buffer, and watch the original files change.
Or you can edit the original files and watch the =*multifile*= buffer change.

#+begin_src emacs-lisp
(use-package multifiles
  :bind ("C-c m f" . mf/mirror-region-in-multifile))
#+end_src

** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
  :demand t
  ;; :after phi-search
  ;; Sometimes you end up with cursors outside of your view. You can scroll
  ;; the screen to center on each cursor with `C-v` and `M-v`.
  ;;
  ;; If you get out of multiple-cursors-mode and yank - it will yank only from
  ;; the kill-ring of main cursor. To yank from the kill-rings of every cursor
  ;; use yank-rectangle, normally found at C-x r y.
  :bind
  ("<C-m> ^"     . mc/edit-beginnings-of-lines)
  ("<C-m> `"     . mc/edit-beginnings-of-lines)
  ("<C-m> $"     . mc/edit-ends-of-lines)
  ("<C-m> '"     . mc/edit-ends-of-lines)
  ("<C-m> R"     . mc/reverse-regions)
  ("<C-m> S"     . mc/sort-regions)
  ("<C-m> W"     . mc/mark-all-words-like-this)
  ("<C-m> Y"     . mc/mark-all-symbols-like-this)
  ("<C-m> a"     . mc/mark-all-like-this-dwim)
  ("<C-m> c"     . mc/mark-all-dwim)
  ("<C-m> l"     . mc/insert-letters)
  ("<C-m> n"     . mc/insert-numbers)
  ("<C-m> A"     . mc/mark-all-in-region)
  ("<C-m> r"     . mc/mark-all-regexp)
  ("<C-m> s"     . set-rectangular-region-anchor)
  ("<C-m> %"     . mc/mark-all-in-region-regexp)
  ("<C-m> t"     . mc/mark-sgml-tag-pair)
  ("<C-m> w"     . mc/mark-next-like-this-word)
  ("<C-m> x"     . mc/mark-more-like-this-extended)
  ("<C-m> y"     . mc/mark-next-like-this-symbol)
  ("<C-m> C-y"   . yank-rectangle)
  ("<C-m> C-x"   . reactivate-mark)
  ("<C-m> C-SPC" . mc/mark-pop)
  ("<C-m> ("     . mc/mark-all-symbols-like-this-in-defun)
  ("<C-m> C-("   . mc/mark-all-words-like-this-in-defun)
  ("<C-m> M-("   . mc/mark-all-like-this-in-defun)
  ("<C-m> ["     . mc/vertical-align-with-space)
  ("<C-m> {"     . mc/vertical-align)
  ("S-<down-mouse-1>")
  ("S-<mouse-1>" . mc/add-cursor-on-click)
  :custom
  (mc/list-file (user-data "mc-lists.el"))
  :preface
  (defun reactivate-mark ()
    (interactive)
    (activate-mark))

  (defun mc/mark-all-regexp ()
    (interactive)
    (let ((search (read-regexp "Mark regexp in region: "))
          (case-fold-search nil))
      (if (string= search "")
          (message "Mark aborted")
        (progn
          (mc/remove-fake-cursors)
          (goto-char (point-min))
          (let ((lastmatch))
            (while (search-forward-regexp search nil t)
              (push-mark (match-beginning 0))
              (mc/create-fake-cursor-at-point)
              (setq lastmatch (point))
              (when (= (point) (match-beginning 0))
                (forward-char)))
            (unless lastmatch
              (error "Search failed for %S" search)))
          (goto-char (match-end 0))
          (if (< (mc/num-cursors) 3)
              (mc/disable-multiple-cursors-mode)
            (mc/pop-state-from-overlay (mc/furthest-cursor-before-point))
            (multiple-cursors-mode 1)))))))
#+end_src

*** mc-calc

#+begin_src emacs-lisp
(use-package mc-calc
  :after multiple-cursors
  :bind (("<C-m> = c" . mc-calc)
         ("<C-m> = =" . mc-calc-eval)
         ("<C-m> = g" . mc-calc-grab)
         ("<C-m> = b" . mc-calc-copy-to-buffer)))
#+end_src

*** mc-extras

#+begin_src emacs-lisp
(use-package mc-extras
  :after multiple-cursors
  :bind (("<C-m> M-C-f" . mc/mark-next-sexps)
         ("<C-m> M-C-b" . mc/mark-previous-sexps)
         ("<C-m> <"     . mc/mark-all-above)
         ("<C-m> >"     . mc/mark-all-below)
         ("<C-m> C-d"   . mc/remove-current-cursor)
         ("<C-m> C-k"   . mc/remove-cursors-at-eol)
         ("<C-m> M-d"   . mc/remove-duplicated-cursors)
         ("<C-m> |"     . mc/move-to-column)
         ("<C-m> ~"     . mc/compare-chars)))
#+end_src

*** mc-freeze

#+begin_src emacs-lisp
(use-package mc-freeze
  :after multiple-cursors
  :bind ("<C-m> f" . mc/freeze-fake-cursors-dwim))
#+end_src

*** mc-rect

#+begin_src emacs-lisp
(use-package mc-rect
  :after multiple-cursors
  :bind ("<C-m> ]" . mc/rect-rectangle-to-multiple-cursors))
#+end_src

*** COMMENT phi-search

#+begin_src emacs-lisp
(use-package phi-search
  :custom
  (phi-search-limit 100000))
#+end_src

**** COMMENT phi-search-mc

#+begin_src emacs-lisp
(use-package phi-search-mc
  :after (phi-search multiple-cursors)
  :config
  (phi-search-mc/setup-keys)
  (add-hook 'isearch-mode-mode #'phi-search-from-isearch-mc/setup-keys))
#+end_src

*** ace-mc

#+begin_src emacs-lisp
(use-package ace-mc
  :bind (("<C-m> ."   . ace-mc-add-multiple-cursors)
         ("<C-m> M-." . ace-mc-add-single-cursor)))
#+end_src

*** mc-pretty-hydra

#+begin_src emacs-lisp
(use-package mc-pretty-hydra
  :no-require t
  :config
  (pretty-hydra-define
    multiple-cursors
    (:color teal :quit-key "q")
    ("Mark/Unmark"
     (("c"     mc/mark-all-dwim "DWIM")
      ("A"     mc/mark-all-in-region "in region")
      ("r"     mc/mark-all-regexp "regexp")
      ("%"     mc/mark-all-in-region-regexp "re in region")
      ("."     ace-mc-add-multiple-cursors "ace add")
      ("M-."   ace-mc-add-single-cursor "ace add sing")
      ("C-d"   mc/remove-current-cursor "remove current")
      ("C-k"   mc/remove-cursors-at-eol "remove at eol")
      ("M-d"   mc/remove-duplicated-cursors "remove dups")
      ("^"     mc/edit-beginnings-of-lines "line begin")
      ("`"     mc/edit-beginnings-of-lines "line begin")
      ("$"     mc/edit-ends-of-lines "line end")
      ("'"     mc/edit-ends-of-lines "line end")
      ("<"     mc/mark-all-above "longer above")
      (">"     mc/mark-all-below "longer below"))
     "Like This"
     (("a"     mc/mark-all-like-this-dwim "all DWIM")
      ("w"     mc/mark-next-like-this-word "next word")
      ("W"     mc/mark-all-words-like-this "all words")
      ("y"     mc/mark-next-like-this-symbol "next symbol")
      ("Y"     mc/mark-all-symbols-like-this "all symbols")
      ("x"     mc/mark-more-like-this-extended "extended")
      ("("     mc/mark-all-symbols-like-this-in-defun "syms in defun")
      ("C-("   mc/mark-all-words-like-this-in-defun "words in defun")
      ("M-("   mc/mark-all-like-this-in-defun "all in defun")
      ("M-C-f" mc/mark-next-sexps "next sexps")
      ("M-C-b" mc/mark-previous-sexps "prev sexps")
      ("= c"   mc-calc "calc")
      ("= ="   mc-calc-eval "eval")
      ("= g"   mc-calc-grab "grab")
      ("= b"   mc-calc-copy-to-buffer "copy"))
     "Utils"
     (("l"     mc/insert-letters "letters")
      ("n"     mc/insert-numbers "numbers")
      ("R"     mc/reverse-regions "reverse")
      ("S"     mc/sort-regions "sort")
      ("["     mc/vertical-align-with-space "align with space")
      ("{"     mc/vertical-align "align")
      ("|"     mc/move-to-column "-> col")
      ("~"     mc/compare-chars "cmp chr")
      ("s"     set-rectangular-region-anchor "rect anchor")
      ("C-y"   yank-rectangle "yank rect")
      ("]"     mc/rect-rectangle-to-multiple-cursors "rect to mult")
      ("t"     mc/mark-sgml-tag-pair "tag pair")
      ("C-x"   reactivate-mark "activate mark")
      ("C-SPC" mc/mark-pop "mark pop")
      ("f"     mc/freeze-fake-cursors-dwim "freeze fake")))))
#+end_src

** COMMENT names

[[https://github.com/Malabarba/names][names]] is designed as a practical, complete, robust, and debuggable tool which
writes your namespaces for you.

#+begin_src emacs-lisp
(use-package names)
#+end_src

** nov

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub\\'" . nov-mode)
  :custom
  (nov-save-place-file (user-data "nov-places")))
#+end_src

** COMMENT oauth2-auto

#+begin_src emacs-lisp
(use-package oauth2-auto
  :nix oauth2
  :custom
  (oauth2-auto-plstore (user-data "oauth2-auto.plist"))
  :config
  (defun oauth2-auto--insert-break-on-secret-entries (&rest args)))
#+end_src

** olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :commands olivetti-mode
  :custom
  (olivetti-hide-mode-line t))
#+end_src

** COMMENT 1password

[[https://github.com/justinbarclay/1password.el][1password.el]] integrates 1Password with auth-source. It enables lookups in your
1Password vault:

#+begin_example
(auth-source-search :host "GitHub")
#+end_example

to search only 1Password, include the type:

#+begin_example
(auth-source-search :type '1password :host "GitHub")
#+end_example

#+begin_src emacs-lisp
(use-package 1password
  :nix onepassword-el
  :custom
  (1password-results-formatter '1password-colour-formatter)
  :config
  (1password-enable-auth-source))
#+end_src

** operate-on-number

#+begin_src emacs-lisp
(use-package operate-on-number
  :bind ("C-c N N" . operate-on-number-at-point))
#+end_src

** COMMENT origami

A text folding minor mode for Emacs. With this minor mode enabled, you can
collapse and expand regions of text. The actual buffer contents are never
changed in any way. This works by using overlays to affect how the buffer is
presented. This also means that all of your usual editing commands should work
with folded regions. For example killing and yanking folded text works as you
would expect.

#+begin_src emacs-lisp
(use-package origami
  :commands (origami-mode)
  :bind (:map origami-mode-map
              ("C-' C-h" . origami-toggle-node))
  :hook (rust-mode . origami-mode)
  :custom
  ;; Highlights the line the fold starts on
  (origami-show-fold-header t)
  :preface
  (defun origami-header-overlay-range (fold-overlay)
    "Given a `fold-overlay', return the range that the corresponding
header overlay should cover. Result is a cons cell of (begin . end)."
    (with-current-buffer (overlay-buffer fold-overlay)
      (let ((fold-begin
             (save-excursion
               (goto-char (overlay-start fold-overlay))
               (line-beginning-position)))
            (fold-end
             ;; Find the end of the folded region -- include the following
             ;; newline if possible. The header will span the entire fold.
             (save-excursion
               (save-match-data
                 (goto-char (overlay-end fold-overlay))
                 (when (looking-at ".")
                   (forward-char 1)
                   (when (looking-at "\n")
                     (forward-char 1)))
                 (point)))))
        (cons fold-begin fold-end))))
  :config
  (add-to-list 'origami-parser-alist '(rust-mode . origami-c-style-parser)))
#+end_src

** outline

#+begin_src emacs-lisp
(use-package outline
  :diminish outline-minor-mode
  :hook ((emacs-lisp-mode LaTeX-mode) . outline-minor-mode))
#+end_src

** outline-indent

The [[https://github.com/jamescherti/outline-indent.el][outline-indent]] Emacs package provides a minor mode that enables code
folding and outlining based on indentation levels for various
indentation-based text files, such as YAML, Python, and other indented text
files.

In addition to code folding, =outline-indent= allows moving indented sub-trees
up and down, promoting and demoting sections to adjust indentation levels,
customizing the ellipsis, and inserting a new line with the same indentation
level as the current line, among other features.

The =outline-indent= package leverages the built-in /outline-minor-mode/, which is
maintained by the Emacs developers and has less chance of being abandoned like
/origami.el/.

#+begin_src emacs-lisp
(use-package outline-indent
  :commands outline-indent-minor-mode)
#+end_src

** COMMENT ovpn-mode

#+begin_src emacs-lisp
(use-package ovpn-mode
  :commands ovpn
  :custom
  (ovpn-mode-base-directory "~/.config/openvpn")
  :config
  (advice-add
   'ovpn-mode-pull-authinfo :around
   (lambda (ad-do-it config)
     (if (string= config "OpenVPN_PoC_2019_johnwiegley.ovpn")
         (list "johnwiegley"
               (concat (lookup-password "demonet OpenVPN" "johnwiegley" 80)
                       (password-store--run "otp" "demonet OpenVPN")))
       (funcall ad-do-it config)))))
#+end_src

** COMMENT osm

[[https://github.com/minad/osm][osm.el]] is a tile-based map viewer, with a responsive movable and zoomable
display. The map can be controlled with the keyboard or with the mouse. The
viewer fetches the map tiles in parallel from tile servers via the curl
program. The package comes with a list of multiple preconfigured tile servers.
You can bookmark your favorite locations using regular Emacs bookmarks or
create links from Org files to locations. Furthermore the package provides
commands to search for locations by name and to open and display GPX tracks.

#+begin_src emacs-lisp
(use-package osm
  :commands osm-home
  :bind ("C-c M" . osm-prefix-map))
#+end_src

** package-lint

#+begin_src emacs-lisp
(use-package package-lint
  :commands package-lint-current-buffer)
#+end_src

** pandoc-mode

#+begin_src emacs-lisp
(use-package pandoc-mode
  :hook (markdown-mode
         (pandoc-mode   . pandoc-load-default-settings)))
#+end_src

** paradox

#+begin_src emacs-lisp
(use-package paradox
  :commands paradox-list-packages)
#+end_src

** pass

#+begin_src emacs-lisp
(use-package pass
  :commands (pass pass-view-mode)
  :mode ("password-store/.*\\.gpg\\'" . pass-view-mode)
  :preface
  (defun insert-password ()
    (interactive)
    (shell-command "apg -m24 -x24 -a1 -n1" t))

  (add-hook 'pass-view-mode-hook #'pass-view--prepare-otp))
#+end_src

** password-store

#+begin_src emacs-lisp
(use-package password-store
  :commands (password-store-insert
             password-store-copy
             password-store-get)
  :custom
  (password-store-password-length 24)
  :functions (password-store--run)
  :config
  (defun password-store--run-edit (entry)
    (require 'pass)
    (find-file (concat (expand-file-name entry (password-store-dir)) ".gpg")))

  (defun password-store-insert (entry login password)
    "Insert a new ENTRY containing PASSWORD."
    (interactive (list (read-string "Password entry: ")
                       (read-string "Login: ")
                       (read-passwd "Password: " t)))
    (message "%s" (shell-command-to-string
                   (if (string= "" login)
                       (format "echo %s | %s insert -m -f %s"
                               (shell-quote-argument password)
                               password-store-executable
                               (shell-quote-argument entry))
                     (format "echo -e '%s\nlogin: %s' | %s insert -m -f %s"
                             password login password-store-executable
                             (shell-quote-argument entry)))))))
#+end_src

*** password-store-otp

#+begin_src emacs-lisp
(use-package password-store-otp
  :defer t
  :config
  (defun password-store-otp-append-from-image (entry)
    "Check clipboard for an image and scan it to get an OTP URI,
append it to ENTRY."
    (interactive (list (read-string "Password entry: ")))
    (let ((qr-image-filename (password-store-otp--get-qr-image-filename entry)))
      (when (not (zerop (call-process "screencapture" nil nil nil
                                      "-T5" qr-image-filename)))
        (error "Couldn't get image from clipboard"))
      (with-temp-buffer
        (condition-case nil
            (call-process "zbarimg" nil t nil "-q" "--raw"
                          qr-image-filename)
          (error
           (error "It seems you don't have `zbar-tools' installed")))
        (password-store-otp-append
         entry
         (buffer-substring (point-min) (point-max))))
      (when (not password-store-otp-screenshots-path)
        (delete-file qr-image-filename)))))
#+end_src

** pcomplete

#+begin_src emacs-lisp
(use-package pcomplete
  :defer t
  :custom
  (pcomplete-compare-entry-function 'file-newer-than-file-p))
#+end_src

** pcre2el

#+begin_src emacs-lisp
(use-package pcre2el
  :bind
  (:prefix-map
   pcre2el-map
   :prefix "C-c /"
   ;; a"Do-what-I-mean" commands:
   ("/" . rxt-explain)
   ("c" . rxt-convert-syntax)
   ("x" . rxt-convert-to-rx)
   (")" . rxt-convert-to-strings)
   ("%" . pcre-query-replace-regexp)
   ("t" . rxt-toggle-elisp-rx)

   ;; Commands that work on a PCRE regexp:
   :prefix-map
   pcre2el-pcre-map
   :prefix "C-c / p"
   ("e" . rxt-pcre-to-elisp)
   ("x" . rxt-pcre-to-rx)
   (")" . rxt-pcre-to-strings)
   ("/" . rxt-explain-pcre)

   ;; Commands that work on an Emacs regexp:
   :prefix-map
   pcre2el-elisp-map
   :prefix "C-c / e"
   ("/" . rxt-explain-elisp)
   ("p" . rxt-elisp-to-pcre)
   ("x" . rxt-elisp-to-rx)
   (")" . rxt-elisp-to-strings)
   ("t" . rxt-toggle-elisp-rx)))
#+end_src

** pdf-tools

#+begin_src emacs-lisp
(use-package pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :bind
  (:map
   pdf-view-mode-map
   ("O" . my/pdf-view-open-file))
  :custom
  (pdf-tools-handle-upgrades nil)
  :preface
  (defun my/pdf-view-open-file ()
    (interactive)
    (shell-command (format "open \"%s\"" (buffer-file-name))))
  :config
  (dolist
      (pkg
       '(pdf-annot pdf-cache pdf-dev pdf-history pdf-info pdf-isearch
                   pdf-links pdf-misc pdf-occur pdf-outline pdf-sync
                   pdf-util pdf-view pdf-virtual))
    (require pkg))
  (pdf-tools-install))
#+end_src

** pdfgrep

#+begin_src emacs-lisp
(use-package pdfgrep
  :commands pdfgrep
  :config
  (pdfgrep-mode))
#+end_src

** persistent-scratch

#+begin_src emacs-lisp
(use-package persistent-scratch
  :unless (or (null window-system)
              alternate-emacs
              noninteractive)
  :demand t
  :commands persistent-scratch-setup-default
  :custom
  (persistent-scratch-autosave-interval 30)
  (persistent-scratch-backup-directory nil)
  (persistent-scratch-save-file (user-data "persistent-scratch"))
  :config
  (persistent-scratch-autosave-mode)
  (with-demoted-errors "Error: %S"
    (persistent-scratch-setup-default)))
#+end_src

** persistent-soft

#+begin_src emacs-lisp
(use-package persistent-soft)
#+end_src

** personal

#+begin_src emacs-lisp
(use-package personal
  :nix nil
  :demand t
  :bind
  (("<C-M-backspace>" . backward-kill-sexp)
   ("C-c )"   . close-all-parentheses)
   ("C-c 0"   . recursive-edit-preserving-window-config-pop)
   ("C-c 1"   . recursive-edit-preserving-window-config)
   ("C-c C-0" . copy-current-buffer-name)
   ("C-c C-z" . delete-to-end-of-buffer)
   ("C-c M-;" . comment-and-copy)
   ("C-c M-q" . unfill-paragraph)
   ("C-c SPC" . cycle-spacing)
   ("C-c e 0" . profiler-start)
   ("C-c e 1" . profiler-stop)
   ("C-c e 2" . profiler-report)
   ("C-c e P" . check-papers)
   ("C-c e b" . do-eval-buffer)
   ("C-c e c" . cancel-debug-on-entry)
   ("C-c e d" . debug-on-entry)
   ("C-c e e" . toggle-debug-on-error)
   ("C-c e f" . emacs-lisp-byte-compile-and-load)
   ("C-c e j" . emacs-lisp-mode)
   ("C-c e r" . do-eval-region)
   ("C-c e s" . scratch)
   ("C-c e S" . my/elisp-scratch)
   ("C-c e z" . byte-recompile-directory)
   ("C-c f"   . flush-lines)
   ("C-c g"   . goto-line)
   ("C-c k"   . keep-lines)
   ("C-c m k" . kmacro-keymap)
   ("C-c m m" . emacs-toggle-size)
   ("C-c I"   . insert-user-timestamp)
   ("C-c q"   . fill-region)
   ("C-c s"   . replace-string)
   ;; ("C-c u"   . rename-uniquely) ; this is available at C-x x u
   ("C-h K"   . describe-keymap)
   ;; ("C-h e a" . apropos-value)
   ("C-h e e" . view-echo-area-messages)
   ("C-h e f" . find-function)
   ("C-h e k" . find-function-on-key)
   ("C-h e v" . find-variable)
   ("C-h h")
   ("C-h v"   . describe-variable)
   ("C-x C-d" . duplicate-line)
   ("C-x C-e" . pp-eval-last-sexp)
   ("C-x C-n" . next-line)
   ("C-x C-p" . previous-line)
   ("C-x C-v" . find-alternate-file-with-sudo)
   ("C-x K"   . delete-current-buffer-file)
   ("C-x R"   . rename-current-buffer-file)
   ("C-x M-q" . refill-paragraph)
   ("C-x d"   . delete-whitespace-rectangle)
   ("C-x t"   . toggle-truncate-lines)
   ("C-z"     . delete-other-windows)
   ("M-'"     . insert-pair)
   ("M-J"     . delete-indentation)
   ("M-L"     . mark-line)
   ("M-S"     . mark-sentence)
   ("M-U"     . unfill-region)
   ("M-W"     . kill-ring-save-no-newlines)
   ("M-\""    . insert-pair)
   ("M-`"     . other-frame)
   ("M-g c"   . goto-char)
   ("M-j"     . delete-indentation-forward))
  :hook
  (emacs-startup . (lambda () (eshell-toggle nil)))
  (emacs-startup . (lambda ()
                     (unless (eq display-name 'imac)
                       (display-battery-mode 1))))
  (before-save . sort-emacs-nix-file)
  (after-save . my/check-emacs-nix)
  :custom
  (user-initials "jww")
  :preface
  (defun my/elisp-scratch ()
    (interactive)
    (scratch "*scratch/elisp*")
    (emacs-lisp-mode))

  (defun my/check-emacs-nix ()
    (when (member (file-name-nondirectory (buffer-file-name))
                  '("init.org" "emacs.nix"))
      (review-emacs-nix-file)))

  (defconst display-name
    (pcase (display-pixel-width)
      (`3840 'dell-wide)
      (`6400 'imac)
      (`4480 'imac)
      (`3760 'imac)
      (`2560 'imac)
      (`1920 'macbook-pro-vga)
      (`1792 'macbook-pro-16)
      (`1512 'macbook-pro-14)
      ))

  (defsubst iawriter-duo-font (height)
    (format "-*-iA Writer Duo S-normal-normal-normal-*-%d*-*-*-*-p-0-iso10646-1" height))

  (defsubst bookerly-font (height)
    (format "-*-Bookerly-normal-normal-normal-*-%d-*-*-*-p-0-iso10646-1" height))

  (defsubst dejavu-sans-mono-font (height)
    (format "-*-DejaVu Sans Mono-normal-normal-normal-*-%d-*-*-*-m-0-iso10646-1" height))

  (defun emacs-min-font ()
    (pcase display-name
      ((guard alternate-emacs) (bookerly-font 18))
      (`imac (dejavu-sans-mono-font 18))
      (_     (dejavu-sans-mono-font 18))))

  (defun emacs-min-font-height ()
    (aref (font-info (emacs-min-font)) 3))

  (defun emacs-min-left ()
    (pcase display-name
      ((guard alternate-emacs)    0)
      (`dell-wide              1000)
      (`imac (pcase (emacs-min-font-height)
               (28  20)
               (24 116)
               (21 318)                 ; <--
               (_    0)))
      (`macbook-pro-vga         700)
      (`macbook-pro-16          672)
      (`macbook-pro-14          396)))

  (defun emacs-min-height ()
    (pcase display-name
      ((guard alternate-emacs)   58)
      (`dell-wide                64)
      (`imac (pcase (emacs-min-font-height)
               (28 50)
               (24 58)
               (21 67)                  ; <--
               (_  40)))
      (`macbook-pro-vga          55)
      (`macbook-pro-16           52)
      (`macbook-pro-14           43)))

  (defun emacs-min-width ()
    (pcase display-name
      ((guard alternate-emacs)   80)
      (`dell-wide               202)
      (`imac (pcase (emacs-min-font-height)
               (28 180)
               (24 202)
               (21 202)                 ; <--
               (_  100)))
      (`macbook-pro-vga         100)
      (`macbook-pro-16          100)
      (`macbook-pro-14          100)))

  (defun reset-font ()
    (interactive)
    (set-frame-font (emacs-min-font) nil t))

  (defun emacs-min ()
    (interactive)
    (cl-flet ((set-param (p v) (set-frame-parameter (selected-frame) p v)))
      (set-param 'fullscreen nil)
      (set-param 'vertical-scroll-bars nil)
      (set-param 'horizontal-scroll-bars nil))
    (and (emacs-min-left)
         (set-frame-position (selected-frame) (emacs-min-left) 0))
    (and (emacs-min-height)
         (set-frame-height (selected-frame) (emacs-min-height)))
    (and (emacs-min-width)
         (set-frame-width (selected-frame) (emacs-min-width)))
    (and (emacs-min-font)
         (set-frame-font (emacs-min-font) nil t)))

  (defun emacs-max ()
    (interactive)
    (cl-flet ((set-param (p v) (set-frame-parameter (selected-frame) p v)))
      (set-param 'fullscreen 'fullboth)
      (set-param 'vertical-scroll-bars nil)
      (set-param 'horizontal-scroll-bars nil))
    (and (emacs-min-font)
         (set-frame-font (emacs-min-font) nil t)))

  (defun emacs-toggle-size ()
    (interactive)
    (if (alist-get 'fullscreen (frame-parameters))
        (emacs-min)
      (emacs-max)))

  (defun emacs-post-startup-setup ()
    (delete-other-windows)
    (find-file "~/org/home.org")
    (magit-status "~/org")
    (when (quickping "imap.fastmail.com")
      (delete-other-windows)
      (call-interactively #'switch-to-gnus))
    (call-interactively #'org-ext-jump-to-agenda))
  :init
  (define-key key-translation-map (kbd "s-TAB") (kbd "C-TAB"))

  (add-hook 'window-setup-hook #'emacs-min t)
  ;; Make sure this runs last
  (add-hook 'window-setup-hook #'emacs-post-startup-setup 100))
#+end_src

** pgmacs

#+begin_src emacs-lisp
(use-package pgmacs
  :commands (pgmacs))
#+end_src

** plstore

#+begin_src emacs-lisp
(use-package plstore
  :custom
  (plstore-cache-passphrase-for-symmetric-encryption t)
  (plstore-encrypt-to "BA39EA53EFF3C20D"))
#+end_src

** COMMENT popper

[[https://github.com/karthink/popper][Popper]] is a minor-mode to tame the flood of ephemeral windows Emacs produces,
while still keeping them within arm’s reach.

Designate any buffer to “popup” status, and it will stay out of your way.
Disimss or summon it easily with one key. Cycle through all your “popups” or
just the ones relevant to your current buffer. Group popups automatically so
you’re presented with the most relevant ones. Useful for many things,
including toggling display of REPLs, documentation, compilation or shell
output: any buffer you need instant access to but want kept out of your way!

You can pre-designate any buffer (by name or major-mode) as a popup, and the
status will be automatically applied when Emacs creates it.

By default, your popups are displayed in a non-obtrusive way, but Popper
respects window rules for buffers that you might have in =display-buffer-alist=
or created using a window management package like =shackle.el=. Popper summons
windows defined by the user as “popups” by simply calling =display-buffer=.

#+begin_src emacs-lisp
(use-package popper
  :demand t
  :bind (("C-`"   . popper-toggle)
         ("M-~"   . popper-cycle)
         ("C-M-`" . popper-toggle-type))
  :custom
  (popper-reference-buffers
   '("\\*Messages\\*"
     "Output\\*$"
     "\\*Async Shell Command\\*"
     help-mode
     special-mode
     compilation-mode))
  :config
  (popper-mode +1)
  ;; (popper-echo-mode +1)
)
#+end_src

** popup-ruler

#+begin_src emacs-lisp
(use-package popup-ruler
  :commands popup-ruler)
#+end_src

** pp-c-l

#+begin_src emacs-lisp
(use-package pp-c-l
  :hook (prog-mode . pretty-control-l-mode)
  :custom
  (pp^L-^L-string "                                            "))
#+end_src

** COMMENT prescient

[[https://github.com/radian-software/prescient.el][prescient.el]] is a library which sorts and filters lists of candidates.

#+begin_src emacs-lisp
(use-package prescient
  :after (vertico orderless)
  :demand t
  :custom
  (prescient-persist-mode t)
  (prescient-save-file (user-data "prescient-save.el"))
  :config
  (face-spec-set
   'prescient-primary-highlight '((t (:foreground "magenta"))))

  (add-to-list 'completion-styles 'prescient)
  (add-to-list 'savehist-additional-variables 'prescient--history))
#+end_src

*** COMMENT vertico-prescient

#+begin_src emacs-lisp
(use-package vertico-prescient
  :after (prescient)
  :demand t
  :config
  (vertico-prescient-mode 1))
#+end_src

*** COMMENT corfu-prescient

#+begin_src emacs-lisp
(use-package corfu-prescient
  :after (prescient)
  :demand t
  :config
  (corfu-prescient-mode 1))
#+end_src

** prodigy

[[https://github.com/rejeep/prodigy.el][Prodigy]] manages external services from within Emacs.

#+begin_src emacs-lisp
(use-package prodigy
  :commands prodigy
  :config
  (use-package prodigy-services))
#+end_src

** projectile

#+begin_src emacs-lisp
(use-package projectile
  :diminish
  :bind* (("C-c TAB" . projectile-find-other-file)
          ("C-c P"   . (lambda () (interactive)
                         (projectile-cleanup-known-projects)
                         (projectile-discover-projects-in-search-path))))
  :bind-keymap ("C-c p" . projectile-command-map)
  :custom
  (projectile-cache-file (user-data "projectile.cache"))
  (projectile-enable-caching t)
  (projectile-file-exists-local-cache-expire 300)
  (projectile-globally-ignored-files '("TAGS"))
  (projectile-ignored-project-function
   (lambda
     (path)
     (string-match "\\(:?\\`/\\(:?nix\\|tmp\\)\\|/profiles\\|/\\.nix-profile\\)" path)))
  (projectile-keymap-prefix (kbd "C-c p"))
  (projectile-known-projects-file (user-data "projectile-bookmarks.eld"))
  (projectile-project-search-path '("~/src" "~/kadena" "~/doc"))
  (projectile-sort-order 'recentf)
  :preface
  (defun my-projectile-invalidate-cache (&rest _args)
    (projectile-invalidate-cache nil))
  :config
  (projectile-mode)

  (eval-after-load 'magit-branch
    '(progn
       (advice-add 'magit-checkout
                   :after #'my-projectile-invalidate-cache)
       (advice-add 'magit-branch-and-checkout
                   :after #'my-projectile-invalidate-cache))))
#+end_src

*** projectile-magit

#+begin_src emacs-lisp
(use-package projectile-magit
  :after projectile
  :no-require t
  :demand t
  :preface
  (defun my-projectile-switch-project-action ()
    (interactive)
    (if (vc-git-responsible-p default-directory)
        (call-interactively #'magit-status)))
  :custom
  (projectile-switch-project-action #'my-projectile-switch-project-action))
#+end_src

** ps-print

#+begin_src emacs-lisp
(use-package ps-print
  :defer t
  :custom
  (ps-font-size '(8 . 10))
  (ps-footer-font-size '(12 . 14))
  (ps-header-font-size '(12 . 14))
  (ps-header-title-font-size '(14 . 16))
  (ps-line-number-font-size 10)
  (ps-print-color-p nil)
  :preface
  (defun ps-spool-to-pdf (beg end &rest _ignore)
    (interactive "r")
    (let ((temp-file (concat (make-temp-name "ps2pdf") ".pdf")))
      (call-process-region beg end (executable-find "ps2pdf")
                           nil nil nil "-" temp-file)
      (call-process (executable-find "open") nil nil nil temp-file)))
  :config
  (setq ps-print-region-function 'ps-spool-to-pdf))
#+end_src

** rainbow-delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** rainbow-mode

#+begin_src emacs-lisp
(use-package rainbow-mode
  :commands rainbow-mode)
#+end_src

** re-builder

#+begin_src emacs-lisp
(use-package re-builder
  :bind (("C-c R" . re-builder))
  :config (setq reb-re-syntax 'string))
#+end_src

** recentf

#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :commands (recentf-mode
             recentf-add-file
             recentf-apply-filename-handlers)
  :custom
  (recentf-auto-cleanup 60)
  (recentf-exclude
   '("~\\'" "\\`out\\'" "\\.log\\'" "^/[^/]*:" "\\.el\\.gz\\'"))
  (recentf-max-saved-items 2000)
  (recentf-save-file (user-data "recentf"))
  :preface
  (defun recentf-add-dired-directory ()
    "Add directories visit by dired into recentf."
    (if (and dired-directory
             (stringp dired-directory)
             (file-directory-p dired-directory)
             (not (string= "/" dired-directory)))
        (let ((last-idx (1- (length dired-directory))))
          (recentf-add-file
           (if (= ?/ (aref dired-directory last-idx))
               (substring dired-directory 0 last-idx)
             dired-directory)))))
  :hook (dired-mode . recentf-add-dired-directory)
  :config
  (recentf-mode 1))
#+end_src

** rect

#+begin_src emacs-lisp
(use-package rect
  :bind ("C-c ]" . rectangle-mark-mode))
#+end_src

** reftex

#+begin_src emacs-lisp
(use-package reftex
  :after auctex
  :hook (LaTeX-mode . reftex-mode)
  :custom
  (reftex-plug-into-AUCTeX t)
  (reftex-trust-label-prefix t))
#+end_src

** regex-tool

#+begin_src emacs-lisp
(use-package regex-tool
  :load-path "lisp/regex-tool"
  :commands regex-tool
  :custom
  (regex-tool-backend 'perl))
#+end_src

** repeat

#+begin_src emacs-lisp
(use-package repeat
  :custom
  (repeat-mode t))
#+end_src

** COMMENT repl-toggle

#+begin_src emacs-lisp
(use-package repl-toggle)
#+end_src

** restclient

#+begin_src emacs-lisp
(use-package restclient
  :mode ("\\.rest\\'" . restclient-mode))
#+end_src

** reveal-in-osx-finder

#+begin_src emacs-lisp
(use-package reveal-in-osx-finder
  :no-require t
  :bind ("C-c M-v" .
         (lambda () (interactive)
           (call-process "/usr/bin/open" nil nil nil
                         "-R" (expand-file-name
                               (or (buffer-file-name)
                                   default-directory))))))
#+end_src

** savehist

#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :custom
  (savehist-additional-variables
   '(file-name-history
     kmacro-ring
     compile-history
     compile-command))
  (savehist-autosave-interval 60)
  (savehist-file (user-data "history"))
  (savehist-ignored-variables
   '(load-history
     flyspell-auto-correct-ring
     org-roam-node-history
     magit-revision-history
     org-read-date-history
     query-replace-history
     yes-or-no-p-history
     kill-ring))
  (savehist-mode t)
  :config
  (savehist-mode 1))
#+end_src

** COMMENT saveplace

#+begin_src emacs-lisp
(use-package saveplace
  :nix nil
  :unless noninteractive
  :custom
  (save-place-file (user-data "places"))
  :config
  (save-place-mode 1))
#+end_src

** sdcv-mode

#+begin_src emacs-lisp
(use-package sdcv-mode
  :bind ("C-c W" . my-sdcv-search)
  :config
  (defvar sdcv-index nil)

  (defun my-sdcv-search ()
    (interactive)
    (cl-letf
        (((symbol-function 'read-string)
          (lambda
            (prompt &optional initial-input history
                    default-value _inherit-input-method)
            (completing-read
             prompt
             (or sdcv-index
                 (with-temp-buffer
                   (insert-file-contents
                    "~/.local/share/dictionary/websters.index")
                   (goto-char (point-max))
                   (insert ")")
                   (goto-char (point-min))
                   (insert "(")
                   (goto-char (point-min))
                   (setq sdcv-index (read (current-buffer)))))
             nil
             nil
             initial-input
             history
             default-value ))))
      (call-interactively #'sdcv-search))))
#+end_src

** selected

#+begin_src emacs-lisp
(use-package selected
  :demand t
  :diminish selected-minor-mode
  :bind (:map selected-keymap
              ("[" . align-code)
              ("f" . fill-region)
              ("U" . unfill-region)
              ("d" . downcase-region)
              ("r" . reverse-region)
              ("S" . sort-lines))
  :config
  (selected-global-mode 1))
#+end_src

*** selected-mc

#+begin_src emacs-lisp
(use-package selected-mc
  :no-require t
  :demand t
  :after multiple-cursors
  :bind (:map
         selected-keymap
         ("c"   . mc/edit-lines)

         ("."   . mc/mark-next-like-this)
         (">"   . mc/skip-to-next-like-this)
         ("<"   . mc/unmark-next-like-this)

         (","   . mc/mark-previous-like-this)
         ("C-<" . mc/skip-to-previous-like-this)
         ("C->" . mc/unmark-previous-like-this)

         ("y"   . mc/mark-next-symbol-like-this)
         ("Y"   . mc/mark-previous-symbol-like-this)

         ("w"   . mc/mark-next-word-like-this)
         ("W"   . mc/mark-previous-word-like-this)))
#+end_src

** separedit

#+begin_src emacs-lisp
(use-package separedit
  :commands separedit
  :bind ("C-c C-'" . separedit-dwim))
#+end_src

** server

#+begin_src emacs-lisp
(use-package server
  :unless (or noninteractive
              alternate-emacs)
  :no-require
  :config
  (unless (file-exists-p "/tmp/johnw-emacs")
    (make-directory "/tmp/johnw-emacs")
    (chmod "/tmp/johnw-emacs" 448))
  (setq server-socket-dir "/tmp/johnw-emacs")
  :hook (after-init . server-start))
#+end_src

** COMMENT shackle

#+begin_src emacs-lisp
(use-package shackle
  :unless alternate-emacs
  :demand t
  :commands shackle-mode
  :custom
  (shackle-default-rule '(:select t))
  (shackle-rules
   '((compilation-mode :select nil :size 0.6)
     ("\\`\\*Messages" :select t :align t :size 0.6)
     ("\\`\\*company-coq:" :regexp t :noselect t)
     ("\\`\\*fetch" :regexp t :size 0.25 :noselect t :align bottom)
     ("\\`\\*Flycheck" :regexp t :size 0.2 :noselect t :align bottom)
     ("\\`\\*?magit-diff" :regexp t :align bottom :noselect t)))
  :config
  (shackle-mode 1))
#+end_src

** shell

#+begin_src emacs-lisp
(use-package shell
  :defer t
  :custom
  (explicit-shell-file-name (emacs-path "runshell")))
#+end_src

*** shell-toggle

#+begin_src emacs-lisp
(use-package shell-toggle
  :bind ("C-' C-z" . shell-toggle)
  :custom
  (shell-toggle-launch-shell 'shell))
#+end_src

** shift-number

#+begin_src emacs-lisp
(use-package shift-number
  :bind (("C-c +" . shift-number-up)
         ("C-c -" . shift-number-down)))
#+end_src

** sky-color-clock

#+begin_src emacs-lisp
(use-package sky-color-clock
  :commands sky-color-clock
  :custom
  (sky-color-clock-format "%-l:%M %p")
  (display-time-string-forms '((sky-color-clock)))
  :preface
  (eval-when-compile
    (require 'solar)
    (require 'time))
  :config
  (sky-color-clock-initialize calendar-latitude))
#+end_src

** COMMENT slack

#+begin_src emacs-lisp
(use-package slack
  :commands (slack-start)
  :bind (:map slack-mode-map
              (("@" . slack-message-embed-mention)
               ("#" . slack-message-embed-channel)))
  :custom
  (slack-buffer-emojify t)
  (slack-prefer-current-team t)
  (slack-thread-also-send-to-room nil)
  :config
  (use-package lui
    :after slack
    :custom
    (lui-fill-type 0))

  (slack-register-team
   :name "emacs-slack"
   :default t
   :token
   (lookup-password "kadena-io.slack.com" "john@kadena.io" 443)
   :cookie
   (lookup-password "kadena-io.slack.com^cookie" "john@kadena.io" 443)
   :subscribed-channels '(dev)
   :full-and-display-names t))
#+end_src

** COMMENT smart-mode-line

#+begin_src emacs-lisp
(use-package smart-mode-line
  :preface
  (defface mode-line-buffer-id
    '((((class color) (background dark))
       (:foreground "grey50" :italic t :strike-through t))
      (((class color) (background light))
       (:foreground "grey55" :italic t :strike-through t)))
    "Face defined to avoid compiler warnings."
    :group 'smart-mode)
  :config
  ;; See https://github.com/Malabarba/smart-mode-line/issues/217
  (setq mode-line-format (delq 'mode-line-position mode-line-format))
  (sml/setup)
  (sml/apply-theme 'light)
  (remove-hook 'display-time-hook 'sml/propertize-time-string))
#+end_src

** smart-newline

#+begin_src emacs-lisp
(use-package smart-newline
  :diminish
  :commands smart-newline-mode)
#+end_src

** smartparens

#+begin_src emacs-lisp
(use-package smartparens-config
  :commands smartparens-mode
  :custom
  (sp-highlight-pair-overlay nil))
#+end_src

** COMMENT smartscan

#+begin_src emacs-lisp
(use-package smartscan
  :defer 5
  :bind (:map smartscan-map
              ("C->" . smartscan-symbol-go-forward)
              ("C-<" . smartscan-symbol-go-backward)))
#+end_src

** smerge-mode

#+begin_src emacs-lisp
(use-package smerge-mode
  :commands smerge-mode)
#+end_src

** sort-words

#+begin_src emacs-lisp
(use-package sort-words
  :commands sort-words)
#+end_src

** sql

#+begin_src emacs-lisp
(use-package sql
  :defer t
  :custom
  (sql-sqlite-program "sqlite3"))
#+end_src

*** sql-indent

#+begin_src emacs-lisp
(use-package sql-indent
  :commands sqlind-minor-mode)
#+end_src

** string-inflection

#+begin_src emacs-lisp
(use-package string-inflection
  :bind ("C-c `" . string-inflection-toggle))
#+end_src

** sudo-edit

#+begin_src emacs-lisp
(use-package sudo-edit
  :after embark
  :bind
  (:map embark-file-map
        ("s" . sudo-edit-find-file))
  (:map embark-become-file+buffer-map
        ("s" . sudo-edit-find-file)))
#+end_src

** COMMENT sunrise-commander

This is currently broken due to undefined functions being called in the code.
It appears that maintenance has stopped.

#+begin_src emacs-lisp
(use-package sunrise
  :bind ("C-c j" . sunrise)
  :bind (:map sunrise-mode-map
              ("/"     . sunrise-sticky-isearch-forward)
              ("l"     . sunrise-dired-prev-subdir)
              ("^"     . sunrise-dired-prev-subdir)
              ("q"     . sunrise-quit)
              ("z"     . sunrise-quit)
              ("C-e")
              ("C-x t" . sunrise-toggle-truncate-lines)
              ("<backspace>" . sunrise-scroll-quick-view-down))
  :bind (:map sunrise-term-line-minor-mode-map
              ("M-<backspace>"))
  :config
  (use-package sunrise-modeline)

  (use-package sunrise-tree
    :demand t
    :bind (:map sunrise-tree-mode-map
                ("C-p")
                ("C-n")))

  (use-package sunrise-tabs
    :disabled t
    :bind (:map sunrise-tabs-mode-map
                ("C-p")
                ("C-n")
                ("M-[" . sunrise-tabs-prev)
                ("M-]" . sunrise-tabs-next)))

  (defun sunrise-browse-file (&optional file)
    "Display the selected file with the default application."
    (interactive)
    (setq file (or file (dired-get-filename)))
    (sunrise-save-selected-window
     (sunrise-select-viewer-window)
     (let ((buff (current-buffer))
           (fname (if (file-directory-p file)
                      file
                    (file-name-nondirectory file)))
           (app (cond
                 ((eq system-type 'darwin)       "open %s")
                 ((eq system-type 'windows-nt)   "open %s")
                 (t                              "xdg-open %s"))))
       (start-process-shell-command "open" nil (format app file))
       (unless (eq buff (current-buffer))
         (sunrise-scrollable-viewer (current-buffer)))
       (message "Opening \"%s\" ..." fname)))))
#+end_src

** COMMENT super-save

[[https://github.com/bbatsov/super-save][super-save]] auto-saves your buffers, when certain events happen - e.g. you
switch between buffers, an Emacs frame loses focus, etc. You can think of it
as both something that augments and replaces the standard auto-save-mode.

#+begin_src emacs-lisp
(use-package super-save
  :unless alternate-emacs
  :diminish
  :custom
  (super-save-auto-save-when-idle t)
  :config
  (super-save-mode 1))
#+end_src

** tagedit

A collection of paredit-like functions for editing in =html-mode=.

#+begin_src emacs-lisp
(use-package tagedit
  :commands tagedit-mode)
#+end_src

** templatel

#+begin_src emacs-lisp
(use-package templatel
  :functions (templatel-render-file
              templatel-render-string))
#+end_src

** term

#+begin_src emacs-lisp
(use-package term
  :bind (:map term-mode-map
              ("C-c C-y" . term-paste))
  :custom
  (term-buffer-maximum-size 0)
  (term-scroll-show-maximum-output t))
#+end_src

** text-mode

#+begin_src emacs-lisp
(use-package text-mode
  :defer t
  :preface
  (eval-when-compile
    (require 'diminish))
  :hook
  (text-mode . turn-on-auto-fill)
  (text-mode . (lambda ()
                 (ignore-errors
                   (diminish 'auto-fill-function)))))
#+end_src

** tidy

#+begin_src emacs-lisp
(use-package tidy
  :commands (tidy-buffer
             tidy-parse-config-file
             tidy-save-settings
             tidy-describe-options))
#+end_src

** time

#+begin_src emacs-lisp
(use-package time
  :custom
  (display-time-interval 60)
  (display-time-mode t)
  (display-time-use-mail-icon t))
#+end_src

** tramp

#+begin_src emacs-lisp
(use-package tramp
  :defer t
  :custom
  (tramp-default-method "ssh")
  (tramp-auto-save-directory "~/.local/share/emacs/backups")
  :config
  (add-to-list 'tramp-remote-path
               (expand-file-name "bin" (getenv "PROFILE_DIR")))

  ;; Without this change, tramp ends up sending hundreds of shell commands to
  ;; the remote side to ask what the temporary directory is.
  (put 'temporary-file-directory 'standard-value '("/tmp"))

  ;; Setting this with `:custom' does not take effect.
  (setq tramp-persistency-file-name (user-data "tramp")))
#+end_src

*** COMMENT tramp-sh

#+begin_src emacs-lisp
(use-package tramp-sh
  :nix nil
  :defer t
  :config
  (add-to-list 'tramp-remote-path "/run/current-system/sw/bin"))
#+end_src

** transient

#+begin_src emacs-lisp
(use-package transient
  :defer t
  :custom
  (transient-history-file (user-data "transient/history.el"))
  (transient-values-file (user-data "transient/values.el")))
#+end_src

** transpose-mark

#+begin_src emacs-lisp
(use-package transpose-mark
  :commands (transpose-mark
             transpose-mark-line
             transpose-mark-region))
#+end_src

** treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :commands treemacs)
#+end_src

** typo

[[https://github.com/jorgenschaefer/typoel][typo-mode]] is a buffer-specific minor mode that will change a number of normal
keys to make them insert typographically useful unicode characters. Some of
those keys can be used repeatedly to cycle through variations. This includes
in particular quotation marks and dashes.

=typo-global-mode= introduces a global minor mode which adds the =C-c 8= prefix to
complement Emacs’ default =C-x 8= prefix map.

#+begin_src emacs-lisp
(use-package typo
  :diminish
  :commands (typo-mode)
  :bind
  (:map typo-mode-map
        ("-" . self-insert-command)
        ("`" . self-insert-command))
  :hook
  ((org-mode markdown-mode gnus-message-setup) . typo-mode)
  :config
  (typo-global-mode 1))
#+end_src

** ultra-scroll

[[https://github.com/jdtsmith/ultra-scroll-mac][ultra-scroll-mac]] is a smooth-scrolling package for [[https://bitbucket.org/mituharu/emacs-mac][emacs-mac]]. It provides
highly optimized, pixel-precise smooth scrolling which can readily keep up
with the /very/ high event rates of modern trackpads and high-precision wheel
mice. You move your fingers, the page responds, instantly.

Importantly, it can cleanly /scroll right across/ tall images and other jumbo
lines – a perennial problem with scrolling packages to date. As a bonus, it
enables relatively smooth scrolling even with dumb third party mice.

#+begin_src emacs-lisp
(use-package ultra-scroll
  :nix ultra-scroll-mac
  :demand t
  :init
  (setq scroll-conservatively 101 ; important!
        scroll-margin 0)
  :config
  (ultra-scroll-mode 1))
#+end_src

** COMMENT undo-fu

Simple, stable linear undo with redo for Emacs.

[[https://codeberg.org/ideasman42/emacs-undo-fu][undo-fu]] is a light weight wrapper for Emacs built-in undo system, adding
convenient undo/redo without losing access to the full undo history, allowing
you to visit all previous states of the document if you need.

The changes compared Emacs undo are as follows:

- Redo will not pass the initial undo action.
- Redo will not undo /(unlike Emacs redo which traverses previous undo/redo
  steps)/ .
- These constraints can be temporarily disabled by pressing C-g before undo or
  redo.

Note that this doesn't interfere with Emacs internal undo data, which can be
error prone.

#+begin_src emacs-lisp
(use-package undo-fu
  :bind
  ("C-/"   . undo-fu-only-undo)
  ("C-S-/" . undo-fu-only-redo))
#+end_src

** undo-propose

#+begin_src emacs-lisp
(use-package undo-propose
  :commands undo-propose)
#+end_src

** unicode-fonts

#+begin_src emacs-lisp
(use-package unicode-fonts
  :after persistent-soft
  :custom
  (unicode-fonts-skip-font-groups
   '(arabic-naskh decorative low-quality-glyphs multicolor))
  :config
  (setq face-font-rescale-alist '((".*Scheher.*" . 1.5)))
  (dolist (font '("Arabic"
                  "Arabic Extended-A"
                  "Arabic Mathematical Alphabetic Symbols"
                  "Arabic Presentation Forms-A"
                  "Arabic Presentation Forms-B"
                  "Arabic Supplement"))
    (push "Scheherazade New"
          (cadr (assoc font unicode-fonts-block-font-mapping))))
  (unicode-fonts-setup))
#+end_src

** uniline

#+begin_src emacs-lisp
(use-package uniline
  :bind ("C-c M-u" . uniline-mode))
#+end_src

** uniquify

#+begin_src emacs-lisp
(use-package uniquify
  :custom
  (uniquify-buffer-name-style 'post-forward-angle-brackets))
#+end_src

** url

#+begin_src emacs-lisp
(use-package url
  :defer t
  :custom
  (url-configuration-directory (user-data "url/")))
#+end_src

*** url-cache

#+begin_src emacs-lisp
(use-package url-cache
  :defer t
  :custom
  (url-cache-directory (user-data "url/cache")))
#+end_src

*** COMMENT url-irc

#+begin_src emacs-lisp
(use-package url-irc
  :nix nil
  :defer t
  :custom
  (url-irc-function 'url-irc-erc))
#+end_src

** vagrant

#+begin_src emacs-lisp
(use-package vagrant
  :commands (vagrant-up
             vagrant-ssh
             vagrant-halt
             vagrant-status))
#+end_src

*** vagrant-tramp

#+begin_src emacs-lisp
(use-package vagrant-tramp
  :after tramp
  :functions (vagrant-tramp-add-method)
  :config
  (vagrant-tramp-add-method))
#+end_src

** vc

#+begin_src emacs-lisp
(use-package vc
  :defer t
  :custom
  (vc-command-messages t)
  (vc-follow-symlinks t)
  (vc-git-diff-switches '("-w" "-U3"))
  (vc-handled-backends '(Git SVN CVS Bzr Hg))
  (vc-make-backup-files t))
#+end_src

** vcard-mode

#+begin_src emacs-lisp
(use-package vcard-mode
  :mode "\\.vc\\(f\\|ard\\)\\'")
#+end_src

** vdiff

#+begin_src emacs-lisp
(use-package vdiff
  :commands (vdiff-files
             vdiff-files3
             vdiff-buffers
             vdiff-buffers3))
#+end_src

** vimish-fold

#+begin_src emacs-lisp
(use-package vimish-fold
  :bind (("C-c V f" . vimish-fold)
         ("C-c V d" . vimish-fold-delete)
         ("C-c V D" . vimish-fold-delete-all)))
#+end_src

** visual-fill-column

#+begin_src emacs-lisp
(use-package visual-fill-column
  :commands visual-fill-column-mode)
#+end_src

** visual-regexp

#+begin_src emacs-lisp
(use-package visual-regexp
  :bind (("C-c r"   . vr/replace)
         ("C-c %"   . vr/query-replace)
         ("<C-m> /" . vr/mc-mark)))
#+end_src

*** COMMENT visual-regexp-steroids

#+begin_src emacs-lisp
(use-package visual-regexp-steroids
  :bind (("C-r" . vr/isearch-backward)
         ("C-s" . vr/isearch-forward)))
#+end_src

** virtual-auto-fill

#+begin_src emacs-lisp
(use-package virtual-auto-fill
  :commands virtual-auto-fill-mode)
#+end_src

** vline

#+begin_src emacs-lisp
(use-package vline
  :commands vline-mode)
#+end_src

** vterm

#+begin_src emacs-lisp
(use-package vterm
  :defer t)
#+end_src

*** multi-vterm

#+begin_src emacs-lisp
(use-package multi-vterm
  :defer t)
#+end_src

*** COMMENT vterm-tmux

#+begin_src emacs-lisp
(use-package vterm-tmux
  :commands (vterm-tmux vterm-tmux-project))
#+end_src

** vundo

[[https://github.com/casouri/vundo][Vundo]] (visual undo) displays the undo history as a tree and lets you move in
the tree to go back to previous buffer states. To use vundo, type M-x vundo
RET in the buffer you want to undo.

#+begin_src emacs-lisp
(use-package vundo
  :bind (("C-c C-/" . vundo)))
#+end_src

** w3m

#+begin_src emacs-lisp
(use-package w3m
  :commands (w3m-browse-url w3m-find-file)
  :custom
  (w3m-cookie-accept-bad-cookies 'ask)
  (w3m-default-display-inline-images t)
  (w3m-fill-column 100)
  (w3m-use-cookies t))
#+end_src

** web-mode

#+begin_src emacs-lisp
(use-package web-mode
  :commands web-mode)
#+end_src

** wgrep

#+begin_src emacs-lisp
(use-package wgrep
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-enable-key ""))
#+end_src

** which-func

#+begin_src emacs-lisp
(use-package which-func
  :hook (c-mode-common . which-function-mode))
#+end_src

** COMMENT which-key

#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :diminish
  :config
  (which-key-mode))
#+end_src

** whitespace

#+begin_src emacs-lisp
(use-package whitespace
  :diminish (global-whitespace-mode
             whitespace-mode
             whitespace-newline-mode)
  :commands (whitespace-buffer
             whitespace-cleanup
             whitespace-mode
             whitespace-turn-off)
  :custom
  (whitespace-auto-cleanup t t)
  (whitespace-line-column 80)
  (whitespace-rescan-timer-time nil t)
  (whitespace-silent t t)
  (whitespace-style '(face trailing lines-tail space-before-tab))
  :custom-face
  (whitespace-line ((t (:background "yellow"))))
  :defines
  (whitespace-auto-cleanup
   whitespace-rescan-timer-time
   whitespace-silent)
  :preface
  (defvar normalize-hook nil)

  (defun normalize-file ()
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (whitespace-cleanup)
      (run-hook-with-args normalize-hook)
      (delete-trailing-whitespace)
      (goto-char (point-max))
      (delete-blank-lines)
      (set-buffer-file-coding-system 'unix)
      (goto-char (point-min))
      (while (re-search-forward "\r$" nil t)
        (replace-match ""))
      (set-buffer-file-coding-system 'utf-8)
      (let ((require-final-newline t))
        (save-buffer))))

  (defun maybe-turn-on-whitespace ()
    "depending on the file, maybe clean up whitespace."
    (when (and (not (or (memq major-mode '(markdown-mode))
                        (and buffer-file-name
                             (string-match "\\(\\.texi\\|COMMIT_EDITMSG\\)\\'"
                                           buffer-file-name))))
               (locate-dominating-file default-directory ".clean")
               (not (locate-dominating-file default-directory ".noclean")))
      (whitespace-mode 1)
      ;; For some reason, having these in settings.el gets ignored if
      ;; whitespace loads lazily.
      (setq whitespace-auto-cleanup t
            whitespace-line-column 80
            whitespace-rescan-timer-time nil
            whitespace-silent t
            whitespace-style '(face trailing lines space-before-tab empty))
      (add-hook 'write-contents-functions
                (lambda () (ignore (whitespace-cleanup))) nil t)
      (whitespace-cleanup)))

  :init
  (add-hook 'find-file-hook #'maybe-turn-on-whitespace t)

  :config
  (remove-hook 'find-file-hook 'whitespace-buffer)
  (remove-hook 'kill-buffer-hook 'whitespace-buffer))
#+end_src

*** whitespace-cleanup-mode

#+begin_src emacs-lisp
(use-package whitespace-cleanup-mode
  :demand t
  :diminish
  :commands whitespace-cleanup-mode
  :config
  (global-whitespace-cleanup-mode 1))
#+end_src

** window-purpose

#+begin_src emacs-lisp
(use-package window-purpose
  :commands purpose-mode)
#+end_src

** winner

#+begin_src emacs-lisp
(use-package winner
  :nix nil
  :unless noninteractive
  :demand t
  :bind (("M-N" . winner-redo)
         ("M-P" . winner-undo))
  :config
  (winner-mode 1))
#+end_src

** word-count

#+begin_src emacs-lisp
(use-package word-count
  :nix word-count-mode
  :bind ("C-c \"" . word-count-mode))
#+end_src

** writeroom-mode

#+begin_src emacs-lisp
(use-package writeroom-mode
  :commands writeroom-mode
  :bind* ("C-c C-M-\\" . writeroom-mode)
  :hook
  (writeroom-mode-enable . set-buffer-writing-font)
  (writeroom-mode-disable . unset-buffer-writing-font)
  :custom
  (writeroom-width 80)
  :preface
  (defface my-writing-face
    '((t (:height 1.5 :family "ia Writer Duo S")))
    "A face used for writing"
    :group 'emacs)

  (defun set-buffer-writing-font ()
    "Sets font in current buffer"
    (interactive)
    (buffer-face-set 'my-writing-face)
    (setq line-spacing 4))

  (defun unset-buffer-writing-font ()
    "Sets font in current buffer"
    (interactive)
    (buffer-face-set 'default)
    (setq line-spacing nil)))
#+end_src

** xr

#+begin_src emacs-lisp
(use-package xr
  :defer t
  :commands (xr))
#+end_src

** xray

#+begin_src emacs-lisp
(use-package xray
  :bind
  (
   :prefix-map my-xray-map
   :prefix "C-h x"
   ("b" . xray-buffer)
   ("f" . xray-faces)
   ("F" . xray-features)
   ("R" . xray-frame)
   ("h" . xray-hooks)
   ("m" . xray-marker)
   ("o" . xray-overlay)
   ("p" . xray-position)
   ("S" . xray-screen)
   ("s" . xray-symbol)
   ("w" . xray-window))
  )
#+end_src

** COMMENT yaoddmuse

#+begin_src emacs-lisp
(use-package yaoddmuse
  :bind (("C-c w f" . yaoddmuse-browse-page-default)
         ("C-c w e" . yaoddmuse-edit-default)
         ("C-c w p" . yaoddmuse-post-library-default))
  :custom
  (yaoddmuse-directory (emacs-path "doc")))
#+end_src

** zoom

[[https://github.com/cyrus-and/zoom][zoom]] takes care of managing the window sizes by enforcing a fixed and
automatic balanced layout where the currently selected window is resized
according to =zoom-size= which can be an absolute value in lines/columns, a
ratio between the selected window and frame size or even a custom callback.

#+begin_src emacs-lisp
(use-package zoom
  :bind ("C-x +" . zoom)
  :custom
  (zoom-size 'size-callback)
  :preface
  (defun size-callback ()
    (cond ((> (frame-pixel-width) 1280) '(90 . 0.75))
          (t '(0.5 . 0.5)))))
#+end_src

** ztree-diff

#+begin_src emacs-lisp
(use-package ztree-diff
  :nix ztree
  :commands ztree-diff)
#+end_src

** Completions

*** completion-preview

#+begin_src emacs-lisp
(use-package completion-preview
  :demand t
  :if (version<= "30.1" emacs-version)
  :diminish completion-preview-mode
  :config
  (global-completion-preview-mode 1))
#+end_src

*** corfu

[[https://github.com/minad/corfu][corfu]] enhances completion at point with a small completion popup. The current
candidates are shown in a popup below or above the point. Corfu is the
minimalistic =completion-in-region= counterpart of the [[https://github.com/minad/vertico][Vertico]] minibuffer UI.

Corfu is a small package, which relies on the Emacs completion facilities and
concentrates on providing a polished completion UI. Completions are either
provided by commands like =dabbrev-completion= or by pluggable backends
(=completion-at-point-functions=, Capfs). Most programming language major modes
implement a Capf. The Emacs language server clients use Capfs, which retrieve
completions from the server via the language server protocol (LSP). Corfu does
not include its own completion backends. The Emacs built-in Capfs and the
Capfs provided by other programming language packages are usually sufficient.
A few additional Capfs and completion utilities are provided by the [[https://github.com/minad/cape][Cape]]
package.

*NOTE*: Corfu uses child frames to show the popup and falls back to the default
setting of the =completion-in-region-function= on non-graphical displays. If you
want to use Corfu in the terminal, install the package [[https://codeberg.org/akib/emacs-corfu-terminal][corfu-terminal]], which
provides an alternative overlay-based display.

#+begin_src emacs-lisp
(use-package corfu
  :demand t
  :bind (("M-/" . completion-at-point)
         :map corfu-map
         ("C-n"      . corfu-next)
         ("C-p"      . corfu-previous)
         ("<escape>" . corfu-quit)
         ("<return>" . corfu-insert)
         ("M-d"      . corfu-info-documentation)
         ("M-l"      . corfu-info-location)
         ("M-."      . corfu-move-to-minibuffer))
  :custom
  ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
  ;; want to perform completion
  (tab-always-indent 'complete)
  (completion-cycle-threshold nil)      ; Always show candidates in menu

  ;; Only use `corfu' when calling `completion-at-point' or
  ;; `indent-for-tab-command'
  (corfu-auto nil)
  (corfu-auto-prefix 2)
  (corfu-auto-delay 0.25)

  (corfu-min-width 80)
  (corfu-max-width corfu-min-width)     ; Always have the same width
  (corfu-count 14)
  (corfu-scroll-margin 4)
  (corfu-cycle nil)

  ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
  ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
  ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
  ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
  ;; configuration already has pre-prepared). Necessary for manual corfu usage with
  ;; orderless, otherwise first component is ignored, unless `corfu-separator'
  ;; is inserted.
  (corfu-quit-at-boundary nil)
  (corfu-separator ?\s)            ; Use space
  (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
  (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
  (corfu-preselect-first t)        ; Preselect first candidate?

  ;; Other
  (corfu-echo-documentation nil)        ; Already use corfu-popupinfo
  :preface
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
                (bound-and-true-p vertico--input))
      (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
      (corfu-mode 1)))

  (defun corfu-move-to-minibuffer ()
    (interactive)
    (pcase completion-in-region--data
      (`(,beg ,end ,table ,pred ,extras)
       (let ((completion-extra-properties extras)
             completion-cycle-threshold completion-cycling)
         (consult-completion-in-region beg end table pred)))))

  (defun corfu-hide-popup ()
    (interactive)
    (corfu--hide-frame corfu--frame))
  :config
  (global-corfu-mode)

  (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)

  ;; Enable Corfu more generally for every minibuffer, as long as no other
  ;; completion UI is active. If you use Mct or Vertico as your main
  ;; minibuffer completion UI. From
  ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1))
#+end_src

**** corfu-popupinfo

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :nix nil
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :bind (:map corfu-map
              ("M-n" . corfu-popupinfo-scroll-up)
              ("M-p" . corfu-popupinfo-scroll-down)
              ([remap corfu-show-documentation] . corfu-popupinfo-toggle))
  :custom
  (corfu-popupinfo-delay 0.5)
  (corfu-popupinfo-max-width 70)
  (corfu-popupinfo-max-height 20)
  ;; Also here to be extra-safe that this is set when `corfu-popupinfo' is
  ;; loaded. I do not want documentation shown in both the echo area and in
  ;; the `corfu-popupinfo' popup.
  (corfu-echo-documentation nil))
#+end_src

*** cape

[[https://github.com/minad/cape][cape]] provides Completion At Point Extensions which can be used in combination
with the [[https://github.com/minad/corfu][Corfu]] completion UI or the default completion UI. The completion
backends used by =completion-at-point= are so called
=completion-at-point-functions= (Capfs). In principle, the Capfs provided by
Cape can also be used by [[https://github.com/company-mode/company-mode][Company]].

Cape has the super power to transform Company backends into Capfs and merge
multiple Capfs into a Super-Capf! These transformers allow you to still take
advantage of Company backends even if you are not using Company as frontend.

#+begin_src emacs-lisp
(use-package cape
  :demand t
  :bind (:prefix-map
         my-cape-map
         :prefix "C-c ."
         ("p" . completion-at-point)
         ("t" . complete-tag)
         ("d" . cape-dabbrev)
         ("h" . cape-history)
         ("f" . cape-file)
         ("k" . cape-keyword)
         ("s" . cape-elisp-symbol)
         ("a" . cape-abbrev)
         ("l" . cape-line)
         ("w" . cape-dict)
         ("\\" . cape-tex)
         ("_" . cape-tex)
         ("^" . cape-tex)
         ("&" . cape-sgml)
         ("r" . cape-rfc1345))
  :init
  ;; Add `completion-at-point-functions', used by `completion-at-point'.
  (add-all-to-list 'completion-at-point-functions
                   #'cape-dabbrev
                   #'cape-file
                   #'cape-abbrev))
#+end_src

*** elisp-mode-cape

#+begin_src emacs-lisp
(use-package elisp-mode-cape
  :no-require t
  :after (cape elisp-mode)
  :hook (emacs-lisp-mode . my/setup-elisp)
  :preface
  (defun my/setup-elisp ()
    (setq-local completion-at-point-functions
                `(,(cape-capf-super
                    #'elisp-completion-at-point
                    #'cape-dabbrev)
                  cape-file)
                cape-dabbrev-min-length 5)))
#+end_src

*** marginalia

[[https://github.com/minad/marginalia][marginalia]] provides =marginalia-mode= which adds marginalia to the minibuffer
completions. [[https://en.wikipedia.org/wiki/Marginalia][Marginalia]] are marks or annotations placed at the margin of the
page of a book or in this case helpful colorful annotations placed at the
margin of the minibuffer for your completion candidates. Marginalia can only
add annotations to the completion candidates. It cannot modify the appearance
of the candidates themselves, which are shown unaltered as supplied by the
original command.

The annotations are added based on the completion category. For example
=find-file= reports the =file= category and =M-x= reports the =command= category. You
can cycle between more or less detailed annotators or even disable the
annotator with command =marginalia-cycle=.

It is recommended to use Marginalia together with either the [[https://github.com/minad/vertico][Vertico]], [[https://github.com/protesilaos/mct][Mct]],
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]] or the default completion UI. Furthermore Marginalia can be combined
with [[https://github.com/oantolin/embark][Embark]] for action support and [[https://github.com/minad/consult][Consult]], which provides many useful
commands.

#+begin_src emacs-lisp
(use-package marginalia
  ;; Either bind `marginalia-cycle' globally or only in the minibuffer
  :bind (("M-A" . marginalia-cycle)
         :map minibuffer-local-map
         ("M-A" . marginalia-cycle))
  :custom
  (marginalia-annotators
   '(
     (bookmark marginalia-annotate-bookmark builtin none)
     (buffer marginalia-annotate-buffer marginalia-annotate-multi-category builtin none)
     (charset marginalia-annotate-charset builtin none)
     (coding-system marginalia-annotate-coding-system builtin none)
     (color marginalia-annotate-color builtin none)
     (command marginalia-annotate-command marginalia-annotate-binding builtin none)
     (customize-group marginalia-annotate-customize-group builtin none)
     (embark-keybinding marginalia-annotate-embark-keybinding builtin none)
     (environment-variable marginalia-annotate-environment-variable builtin none)
     (face marginalia-annotate-face builtin none)
     (file marginalia-annotate-file builtin none)
     (function marginalia-annotate-function builtin none)
     (imenu marginalia-annotate-imenu builtin none)
     (input-method marginalia-annotate-input-method builtin none)
     (library marginalia-annotate-library builtin none)
     (minor-mode marginalia-annotate-minor-mode builtin none)
     (multi-category marginalia-annotate-multi-category builtin none)
     (package marginalia-annotate-package builtin none)
     (project-file marginalia-annotate-project-file builtin none)
     (symbol marginalia-annotate-symbol builtin none)
     (tab marginalia-annotate-tab builtin none)
     (theme marginalia-annotate-theme builtin none)
     (unicode-name marginalia-annotate-char builtin none)
     (variable marginalia-annotate-variable builtin none)
     ))
  ;; The :init configuration is always executed (Not lazy!)
  :config
  ;; Must be in the :init section of use-package such that the mode gets
  ;; enabled right away. Note that this forces loading the package.
  (marginalia-mode))
#+end_src

*** orderless

[[https://github.com/oantolin/orderless][orderless]] provides an =orderless= /completion style/ that divides the pattern into
space-separated components, and matches candidates that match all of the
components in any order. Each component can match in any one of several ways:
literally, as a regexp, as an initialism, in the flex style, or as multiple
word prefixes. By default, regexp and literal matches are enabled.

A completion style is a back-end for completion and is used from a front-end
that provides a completion UI. Any completion style can be used with the
default Emacs completion UI (sometimes called minibuffer tab completion), with
the built-in Icomplete package (which is similar to the more well-known Ido
Mode), the icomplete-vertical variant from Emacs 28 (see the external
[[https://github.com/oantolin/icomplete-vertical][icomplete-vertical]] package to get that functionality on earlier versions of
Emacs), or with some third party minibuffer completion frameworks such as [[https://gitlab.com/protesilaos/mct][Mct]],
[[https://github.com/minad/vertico][Vertico]], or [[https://github.com/raxod502/selectrum][Selectrum]] (in its default configuration).

All the completion UIs just mentioned are for minibuffer completion, used when
Emacs commands prompt the user in the minibuffer for some input, but there is
also completion at point in normal buffers, typically used for identifiers in
programming languages. Completion styles can also be used for that purpose by
completion at point UIs such as [[https://github.com/minad/corfu][Corfu]], [[https://company-mode.github.io/][Company]] or the function
=consult-completion-in-region= from [[https://github.com/minad/consult][Consult]].

To use a completion style with any of the above mentioned completion UIs
simply add it as an entry in the variables =completion-styles= and
=completion-category-overrides= (see their documentation). You may also want to
modify the =completion-category-defaults= variable, which serves as a default
value for =completion-category-overrides=: if you want to use =orderless=
exclusively, set both variables to =nil=.

#+begin_src emacs-lisp
(use-package orderless
  :demand t
  :custom
  (completion-category-overrides
   '((file (styles basic partial-completion))))
  :config
  (add-to-list 'completion-styles 'orderless))
#+end_src

*** vertico

[[https://github.com/minad/vertico][vertico]] provides a performant and minimalistic vertical completion UI based on
the default completion system. The focus of Vertico is to provide a UI which
behaves /correctly/ under all circumstances. By reusing the built-in facilities
system, Vertico achieves /full compatibility/ with built-in Emacs completion
commands and completion tables. Vertico only provides the completion UI but
aims to be highly flexible, extendable and modular. Additional enhancements
are available as extensions or complementary packages. The code base is small
and maintainable. The main =vertico.el= package is only about 600 lines of code
without white space and comments.

- Vertical display with arrow key navigation. See the extensions for
  additional display modes.
- Prompt shows the current candidate index and the total number of candidates.
- The current candidate is inserted with =TAB= and selected with =RET=.
- Non-existing candidates can be submitted with =M-RET= or by moving the point
  to the prompt.
- Configurable sorting by history position, length and alphabetically.
- Long candidates with newlines are formatted to take up less space.
- Deferred completion style highlighting for performance.
- Annotations are displayed next to the candidates (=annotation-= and
  =affixation-function=).
- Support for candidate grouping and group cycling commands (=group-function=).

#+begin_src emacs-lisp
(use-package vertico
  :after cape                           ; because this defines C-c .
  :demand t
  :bind (:map vertico-map
              ("C-j"   . vertico-exit-input)
              ("C-M-n" . vertico-next-group)
              ("C-M-p" . vertico-previous-group))
  :hook
  (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :custom
  (vertico-count 10)
  (vertico-resize nil)
  (vertico-cycle t)
  ;; (vertico-sort-function #'my/sort-by-mtime)
  ;; (vertico-sort-override-function
  ;;  (lambda (files)
  ;;    (if (and (eq minibuffer-history-variable 'file-name-history)
  ;;             (not (eq (car-safe minibuffer-completion-table) 'boundaries)))
  ;;        (my/sort-by-mtime files)
  ;;      (vertico-sort-history-length-alpha files))))
  :preface
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))

  (defsubst time-greater-p (a b)
    (time-less-p b a))

  (defun my/sort-by-mtime (files)
    "Sort FILES by modification time (newest first)."
    (sort-on files
             #'time-greater-p
             (lambda (a) (file-attribute-modification-time (file-attributes a)))))
  :config
  (vertico-mode)

  ;;(define-key vertico-map (kbd "C-k") (kmacro "M-. k"))

  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))

  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  ;; Hide commands in M-x which do not work in the current mode. Vertico
  ;; commands are hidden in normal buffers.
  (setq read-extended-command-predicate
        #'command-completion-default-include-p)

  (use-package vertico-repeat
    :demand t
    :bind
    (("C-c . ." . vertico-repeat)
     :map vertico-map
     ("M-P" . vertico-repeat-previous)
     ("M-N" . vertico-repeat-next))
    :hook
    (minibuffer-setup . vertico-repeat-save))

  (use-package vertico-directory
    :demand t
    :bind (:map vertico-map
                ("<backspace>"   . vertico-directory-delete-char)
                ("C-w"           . vertico-directory-delete-word)
                ("C-<backspace>" . vertico-directory-delete-word)
                ;; ("RET" .           vertico-directory-enter)
                ))

  (use-package vertico-quick
    :demand t
    :bind (:map vertico-map
                ("C-." . vertico-quick-exit)
                ("<S-return>" . vertico-quick-exit)
                ("M->" . vertico-quick-embark))
    :preface
    (defun vertico-quick-embark (&optional arg)
      "Embark on candidate using quick keys."
      (interactive)
      (when (vertico-quick-jump)
        (embark-act arg))))

  (use-package vertico-multiform
    :demand t
    :bind (:map vertico-map
                ("C-i"   . vertico-multiform-vertical)
                ("M-G"   . vertico-multiform-grid)
                ("M-B"   . vertico-multiform-buffer)
                ("<tab>" . vertico-insert))
    :custom
    (vertico-multiform-commands
     '((consult-imenu buffer)
       (consult-line buffer)
       (consult-grep buffer)
       (consult-git-grep buffer)
       (consult-ripgrep buffer)
       (consult-yank-pop)
       (embark-bindings grid)
       (xref-find-references buffer)))
    (vertico-multiform-categories
     '((embark-keybinding grid)
       (t unobtrusive)))
    :config
    (vertico-multiform-mode 1)))
#+end_src

*** embark

[[https://github.com/oantolin/embark][embark]] makes it easy to choose a command to run based on what is near point,
both during a minibuffer completion session (in a way familiar to Helm or
Counsel users) and in normal buffers. Bind the command =embark-act= to a key and
it acts like prefix-key for a keymap of /actions/ (commands) relevant to the
/target/ around point. With point on an URL in a buffer you can open the URL in
a browser or eww or download the file it points to. If while switching buffers
you spot an old one, you can kill it right there and continue to select
another. Embark comes preconfigured with over a hundred actions for common
types of targets such as files, buffers, identifiers, s-expressions,
sentences; and it is easy to add more actions and more target types. Embark
can also collect all the candidates in a minibuffer to an occur-like buffer or
export them to a buffer in a major-mode specific to the type of candidates,
such as dired for a set of files, ibuffer for a set of buffers, or customize
for a set of variables.

#+begin_src emacs-lisp
(use-package embark
  :bind (("M-."   . embark-act)
         ("C-M-." . embark-act-all)
         ("C-h b" . embark-bindings) ;; alternative for `describe-bindings'
         ("C-c v" . embark-dwim)
         :map embark-collect-mode-map
         ("C-c C-a" . embark-collect-direct-action-minor-mode))
  :custom
  (embark-indicators
   '(embark-minimal-indicator
     embark-highlight-indicator
     embark-isearch-highlight-indicator))
  :init
  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
  ;; strategy, if you want to see the documentation from multiple providers.
  (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)

  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src

**** embark-consult

[[https://github.com/oantolin/embark/blob/master/embark-consult.el][embark-consult]] provides integration between Embark and Consult. The package
will be loaded automatically by Embark.

Some of the functionality here was previously contained in Embark itself:

- Support for =consult-buffer=, so that you get the correct actions for each
  type of entry in =consult-buffer='s list.

- Support for =consult-line=, =consult-outline=, =consult-mark= and
  =consult-global-mark=, so that the insert and save actions don't include a
  weird unicode character at the start of the line, and so you can export from
  them to an occur buffer (where =occur-edit-mode= works!).

Just load this package to get the above functionality, no further
configuration is necessary.

Additionally this package contains some functionality that has never been in
Embark: access to Consult preview from auto-updating Embark Collect buffer
that is associated to an active minibuffer for a Consult command. For
information on Consult preview, see Consult's info manual or its readme on
GitHub.

#+begin_src emacs-lisp
(use-package embark-consult
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** consult

[[https://github.com/minad/consult][consult]] provides search and navigation commands based on the Emacs completion
function [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html][completing-read]]. Completion allows you to quickly select an item from
a list of candidates. Consult offers asynchronous and interactive =consult-grep=
and =consult-ripgrep= commands, and the line-based search command =consult-line=.
Furthermore Consult provides an advanced buffer switching command
=consult-buffer= to switch between buffers, recently opened files, bookmarks and
buffer-like candidates from other sources. Some of the Consult commands are
enhanced versions of built-in Emacs commands. For example the command
=consult-imenu= presents a flat list of the Imenu with live preview, grouping
and narrowing. Please take a look at the full list of commands.

Consult is fully compatible with completion systems centered around the
standard Emacs =completing-read= API, notably the default completion system,
[[https://github.com/minad/vertico][Vertico]], [[https://github.com/protesilaos/mct][Mct]], and [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]].

This package keeps the completion system specifics to a minimum. The ability
of the Consult commands to work well with arbitrary completion systems is one
of the main advantages of the package. Consult fits well into existing setups
and it helps you to create a full completion environment out of small and
independent components.

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :bind (;; C-c bindings (mode-specific-map)
         ("C-c M-x" . consult-mode-command)
         ("C-c K"   . consult-kmacro)
         ("C-c e i" . consult-info)
         ([remap Info-search] . consult-info)

         ("C-c e l" . find-library)
         ("C-c e q" . set-variable)
         ("C-h e l" . find-library)

         ;; C-x bindings (ctl-x-map)
         ("C-x M-:" . consult-complex-command)
         ("C-x b"   . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("C-x r b" . consult-bookmark)
         ("C-x r j" . consult-register)
         ("C-x 4 j" . consult-bookmark-other-window)
         ("C-x p f" . project-find-file)
         ("C-x p b" . consult-project-buffer)
         ;; Other custom bindings
         ("M-y"     . consult-yank-pop)
         ;; M-g bindings (goto-map)
         ("M-g e"   . consult-compile-error)
         ("M-g g"   . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g l"   . consult-goto-line)
         ([remap goto-line] . consult-goto-line)
         ("M-g o"   . consult-org-heading)
         ("M-g m"   . consult-mark)
         ("M-g k"   . consult-global-mark)
         ("M-g i"   . consult-imenu)
         ("M-g I"   . consult-imenu-multi)
         ;; M-s bindings (search-map)
         ;; ("M-s f"   . consult-find)
         ("M-s f"   . consult-fd)
         ("M-s M-g" . consult-grep)
         ("M-s g"   . consult-ripgrep)
         ("M-s G"   . consult-git-grep)
         ("M-s H"   . consult-history)
         ("M-s i"   . consult-info)
         ("M-s r"   . consult-ripgrep)
         ("M-s l"   . consult-line)
         ("M-s L"   . consult-line-multi)
         ("M-s k"   . consult-keep-lines)
         ("M-s u"   . consult-focus-lines)
         ;; Isearch integration
         ("M-s e"   . consult-isearch-history)
         :map isearch-mode-map
         ("M-e"     . consult-isearch-history)
         ("M-s e"   . consult-isearch-history)
         ("M-s o"   . consult-line)
         ("M-s l"   . consult-line)
         ("M-s L"   . consult-line-multi)
         ;; Minibuffer history
         :map minibuffer-local-map
         ;; ("M-s"     . consult-history)
         ("M-r"     . consult-history))

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  :custom
  ;; (consult-preview-key "M-i")
  (consult-narrow-key "<")

  :custom-face
  (consult-file ((t (:inherit font-lock-string-face))))

  :functions
  (consult-register-format
   consult-register-window
   consult-xref)

  :preface
  (defun consult-bookmark-other-window (name)
    "If bookmark NAME exists, open it, otherwise create a new bookmark with NAME.

  The command supports preview of file bookmarks and narrowing.  See the
  variable `consult-bookmark-narrow' for the narrowing configuration."
    (interactive
     (list
      (let* ((consult--buffer-display #'switch-to-buffer-other-window)
             (narrow (cl-loop for (x y . _) in consult-bookmark-narrow collect (cons x y))))
        (consult--read
         (consult--bookmark-candidates)
         :prompt "Bookmark: "
         :state (consult--bookmark-preview)
         :category 'bookmark
         :history 'bookmark-history
         ;; Add default names to future history.
         ;; Ignore errors such that `consult-bookmark' can be used in
         ;; buffers which are not backed by a file.
         :add-history (ignore-errors (bookmark-prop-get (bookmark-make-record) 'defaults))
         :group (consult--type-group narrow)
         :narrow (consult--type-narrow narrow)))))
    (bookmark-maybe-load-default-file)
    (if (assoc name bookmark-alist)
        (bookmark-jump name #'switch-to-buffer-other-window)
      (bookmark-set name)))

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Optionally configure the register formatting. This improves the register
  ;; preview for `consult-register', `consult-register-load',
  ;; `consult-register-store' and the Emacs built-ins.
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  ;; This adds thin lines, sorting and hides the mode line of the window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config
  (use-package consult-xref)

  (consult-customize
   consult-theme
   :preview-key '(:debounce 0.2 any)
   consult-ripgrep
   consult-git-grep
   consult-grep
   consult-bookmark
   consult-recent-file
   consult-xref
   consult--source-bookmark
   consult--source-file-register
   consult--source-recent-file
   consult--source-project-recent-file
   :preview-key '(:debounce 0.4 any))

  (autoload 'projectile-project-root "projectile")
  (setq consult-project-function (lambda (_) (projectile-project-root)))

  (with-eval-after-load 'eshell
    (define-key eshell-mode-map (kbd "C-r") 'consult-history))
  (with-eval-after-load 'eshell-rebind
    (add-hook 'eshell-rebind-mode-hook
              (lambda ()
                (define-key eshell-rebind-mode-map (kbd "C-r")
                            'consult-history))))

  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-commands '(consult-org-heading)))
#+end_src

**** consult-dir

[[https://github.com/karthink/consult-dir][consult-dir]] allows you to easily insert directory paths into the minibuffer
prompt in Emacs.

When using the minibuffer, you can switch - with completion and filtering
provided by your completion setup - to any directory you've visited recently,
or to a project, a bookmarked directory or even a remote host via tramp. The
minibuffer prompt will be replaced with the directory you choose.

Why would you want to do this? To avoid “navigating” long distances when
picking a file or directory in any Emacs command that requires one.

Think of it like the shell tools [[https://github.com/wting/autojump][autojump]], [[https://github.com/clvv/fasd][fasd]] or z but for Emacs. See the
demos section below for many more examples. =consult-dir= works with all Emacs
commands that require you to specify file paths, and with [[https://github.com/oantolin/embark][Embark actions]] on
files.

The directory candidates are collected from user bookmarks, Projectile project
roots (if available), project.el project roots (if available) and recentf file
locations. The =default-directory= variable is not changed in the process.

#+begin_src emacs-lisp
(use-package consult-dir
  :bind (("M-g d"   . consult-dir)
         :map minibuffer-local-completion-map
         ("M-s f" . consult-dir-jump-file)
         ("M-g d" . consult-dir)))
#+end_src

**** consult-dir-vertico

#+begin_src emacs-lisp
(use-package consult-dir-vertico
  :no-require t
  :after (consult-dir vertico)
  :defines (vertico-map)
  :bind (:map vertico-map
              ("C-x C-j" . consult-dir)
              ("M-g d"   . consult-dir)
              ("M-s f"   . consult-dir-jump-file)))
#+end_src

**** consult-projectile

#+begin_src emacs-lisp
(use-package consult-projectile)
#+end_src

**** consult-company

#+begin_src emacs-lisp
(use-package consult-company
  :after company-mode
  :bind (:map company-mode-map
              ([remap completion-at-point] . consult-company)))
#+end_src

**** COMMENT consult-flycheck

#+begin_src emacs-lisp
(use-package consult-flycheck
  :bind ("M-g f" . consult-flycheck))
#+end_src

**** COMMENT consult-git-log-grep

#+begin_src emacs-lisp
(use-package consult-git-log-grep
  :custom
  (consult-git-log-grep-open-function #'magit-show-commit))
#+end_src

**** consult-hoogle

#+begin_src emacs-lisp
(use-package consult-hoogle
  :after (consult vertico-multiform)
  :commands consult-hoogle
  :config
  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-commands '(consult-hoogle buffer)))
#+end_src

**** COMMENT consult-lsp

#+begin_src emacs-lisp
(use-package consult-lsp
  :bind (:map lsp-mode-mode
              ([remap xref-find-apropos] . consult-lsp-symbols)))
#+end_src

**** consult-gh

#+begin_src emacs-lisp
(use-package consult-gh
  :after consult
  :commands
  (consult-gh
   consult-gh-auth-switch
   consult-gh-repo-list
   consult-gh-issue-list
   consult-gh-pr-list
   consult-gh-search-repos
   consult-gh-search-issues
   consult-gh-search-prs
   consult-gh-search-code
   consult-gh-find-file
   consult-gh-favorite-repos
   consult-gh-user-repos
   consult-gh-repo-clone
   consult-gh-repo-fork
   consult-gh-repo-create
   consult-gh-issue-create
   consult-gh-pr-create
   consult-gh-dashboard
   consult-gh-notifications)
  :custom
  (consult-gh-default-clone-directory "~/src")
  (consult-gh-confirm-before-clone nil)
  (consult-gh-show-preview t)
  (consult-gh-preview-key "C-o")
  (consult-gh-repo-action #'consult-gh--repo-browse-files-action)
  (consult-gh-issue-action #'consult-gh--issue-view-action)
  (consult-gh-pr-action #'consult-gh--pr-view-action)
  (consult-gh-code-action #'consult-gh--code-view-action)
  (consult-gh-file-action #'consult-gh--files-view-action)
  (consult-gh-notifications-action #'consult-gh--notifications-action)
  (consult-gh-dashboard-action #'consult-gh--dashboard-action)
  (consult-gh-large-file-warning-threshold 2500000)
  (consult-gh-prioritize-local-folder 'suggest)
  (consult-gh-favorite-orgs-list '("kadena-io" "ekmett" "karthink" "jwiegley" "ledger"))
  :config
  (add-to-list 'savehist-additional-variables 'consult-gh--known-orgs-list)
  (add-to-list 'savehist-additional-variables 'consult-gh--known-repos-list)

  (consult-gh-enable-default-keybindings)

  (use-package consult-gh-transient
    :after consult-gh
    :bind
    ("M-H" . consult-gh-transient)
    :commands (consult-gh-transient))

  (add-all-to-list 'vertico-multiform-commands
                   '(consult-gh)
                   '(consult-gh-auth-switch)
                   '(consult-gh-repo-list)
                   '(consult-gh-issue-list)
                   '(consult-gh-pr-list)
                   '(consult-gh-search-repos)
                   '(consult-gh-search-issues)
                   '(consult-gh-search-prs)
                   '(consult-gh-search-code)
                   '(consult-gh-find-file)
                   '(consult-gh-favorite-repos)
                   '(consult-gh-user-repos)
                   '(consult-gh-repo-clone)
                   '(consult-gh-repo-fork)
                   '(consult-gh-repo-create)
                   '(consult-gh-issue-create)
                   '(consult-gh-pr-create)
                   '(consult-gh-dashboard)
                   '(consult-gh-notifications)))
#+end_src

***** consult-gh-embark

#+begin_src emacs-lisp
(use-package consult-gh-embark
  :after consult-gh
  :diminish
  :config
  (consult-gh-embark-mode +1))
#+end_src

***** consult-gh-forge

#+begin_src emacs-lisp
(use-package consult-gh-forge
  :after consult-gh
  :diminish
  :custom
  (consult-gh-forge-timeout-seconds 20)
  :config
  (consult-gh-forge-mode +1))
#+end_src

***** consult-gh-with-pr-review

#+begin_src emacs-lisp
(use-package consult-gh-with-pr-review
  :after consult-gh)
#+end_src

*** COMMENT company

#+begin_src emacs-lisp
(use-package company
  :demand t
  :diminish
  :commands (company-mode company-indent-or-complete-common)
  :custom
  (company-frontends
   '(company-pseudo-tooltip-unless-just-one-frontend
     company-echo-metadata-frontend
     company-preview-frontend))
  (company-idle-delay nil)
  (company-quickhelp-use-propertized-text t)
  (company-show-numbers t)
  (company-show-quick-access t)
  (company-tooltip-align-annotations t)
  :preface
  (defun company-mode/backend-with-yas (backend)
    (if (and (listp backend) (member 'company-yasnippet backend))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
  :config
  (setq company-backends
        (mapcar #'company-mode/backend-with-yas company-backends)))
#+end_src

**** company-math

#+begin_src emacs-lisp
(use-package company-math
  :defer t)
#+end_src

*** yasnippet

#+begin_src emacs-lisp
(use-package yasnippet
  :demand t
  :diminish yas-minor-mode
  :commands yas-minor-mode-on
  :bind (("C-c y d" . yas-load-directory)
         ("C-c y i" . yas-insert-snippet)
         ("C-c y f" . yas-visit-snippet-file)
         ("C-c y n" . yas-new-snippet)
         ("C-c y t" . yas-tryout-snippet)
         ("C-c y l" . yas-describe-tables)
         ("C-c y g" . yas-global-mode)
         ("C-c y m" . yas-minor-mode)
         ("C-c y r" . yas-reload-all)
         ("C-c y x" . yas-expand)
         :map yas-keymap
         ("C-i" . yas-next-field-or-maybe-expand))
  :mode ("/\\.emacs\\.d/snippets/" . snippet-mode)
  :hook (prog-mode . yas-minor-mode-on)
  :custom
  (yas-prompt-functions '(yas-completing-prompt yas-no-prompt))
  (yas-snippet-dirs (list (emacs-path "snippets")))
  (yas-triggers-in-field t)
  (yas-wrap-around-region t)
  :custom-face
  (yas-field-highlight-face ((t (:background "#e4edfc"))))
  :config
  (yas-load-directory (emacs-path "snippets")))
#+end_src

**** consult-yasnippet

#+begin_src emacs-lisp
(use-package consult-yasnippet
  :after (consult yasnippet))
#+end_src

**** auto-yasnippet

#+begin_src emacs-lisp
(use-package auto-yasnippet
  :after yasnippet
  :bind (("C-c y a" . aya-create)
         ("C-c y e" . aya-expand)
         ("C-c y o" . aya-open-line)))
#+end_src

** Languages

*** adoc-mode

#+begin_src emacs-lisp
(use-package adoc-mode
  :mode "\\.adoc\\'"
  :hook (adoc-mode . turn-on-auto-fill))
#+end_src

*** agda2-mode

#+begin_src emacs-lisp
(use-package agda2-mode
  :mode ("\\.agda\\'" "\\.lagda.md\\'")
  :bind (:map agda2-mode-map
              ("C-c C-i" . agda2-insert-helper-function))
  :custom
  (agda2-backend "MAlonzo")
  (agda2-include-dirs
   (list "."
         (expand-file-name "share/agda-prelude" (getenv "PROFILE_DIR"))
         (expand-file-name "share/agda" (getenv "PROFILE_DIR"))))
  :preface
  (defun agda2-insert-helper-function (&optional _prefix)
    (interactive "P")
    (let ((func-def (with-current-buffer "*Agda information*"
                      (buffer-string))))
      (save-excursion
        (forward-paragraph)
        (let ((name (car (split-string func-def " "))))
          (insert "  where\n    " func-def "    " name " x = ?\n"))))))
#+end_src

*** auctex

#+begin_src emacs-lisp
(use-package latex
  :nix auctex
  :mode ("\\.tex\\'" . LaTeX-mode)
  :bind (:map
         LaTeX-mode-map
         ("C-x SPC" . (lambda () (interactive) (insert "\N{THIN SPACE}")))
         ("C-x A"   . (lambda () (interactive) (insert "ٰ")))
         ("s-َ"      . (lambda () (interactive) (insert "أ")))
         ("s-."      . (lambda () (interactive) (insert "إ")))
         ("s-ا"      . (lambda () (interactive) (insert "ٰ")))
         ("s-ز"     . (lambda () (interactive) (insert "ژ")))
         ("s-ي"     . (lambda () (interactive) (insert "ئ")))
         ("s-س"     . (lambda () (interactive) (insert "ٱ")))
         ("s-ه"     . (lambda () (interactive) (insert "ۀ")))
         ("s-د"     . (lambda () (interactive) (insert "ذ")))
         ("s-ت"     . (lambda () (interactive) (insert "ة"))))
  :hook (LaTeX-mode . abbrev-mode)
  :custom
  (TeX-PDF-mode t)
  (TeX-auto-save t)
  (TeX-auto-untabify t)
  (TeX-electric-escape t)
  (TeX-engine 'xetex)
  (TeX-parse-self t)
  (TeX-view-program-selection
   '(((output-dvi style-pstricks)
      "dvips and gv")
     (output-dvi "xdvi")
     (output-html "xdg-open")))
  :defines
  (latex-help-cmd-alist
   latex-help-file)
  :preface
  (defvar latex-prettify-symbols-alist
    '(("\N{THIN SPACE}" . ?\⟷)))
  :config
  (require 'preview)

  (defun latex-help-get-cmd-alist ()    ;corrected version:
    "Scoop up the commands in the index of the latex info manual.
   The values are saved in `latex-help-cmd-alist' for speed."
    ;; mm, does it contain any cached entries
    (if (not (assoc "\\begin" latex-help-cmd-alist))
        (save-window-excursion
          (setq latex-help-cmd-alist nil)
          (Info-goto-node (concat latex-help-file "Command Index"))
          (goto-char (point-max))
          (while (re-search-backward "^\\* \\(.+\\): *\\(.+\\)\\." nil t)
            (let ((key (buffer-substring (match-beginning 1) (match-end 1)))
                  (value (buffer-substring (match-beginning 2)
                                           (match-end 2))))
              (add-to-list 'latex-help-cmd-alist (cons key value))))))
    latex-help-cmd-alist)

  (info-lookup-add-help :mode 'LaTeX-mode
                        :regexp ".*"
                        :parse-rule "\\\\?[a-zA-Z]+\\|\\\\[^a-zA-Z]"
                        :doc-spec '(("(latex2e)Concept Index")
                                    ("(latex2e)Command Index")))

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (setq-local prettify-symbols-alist latex-prettify-symbols-alist)
              (prettify-symbols-mode 1)))

  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer))
#+end_src

*** boogie-friends

#+begin_src emacs-lisp
(use-package boogie-friends
  :commands boogie-friends-verify)
#+end_src

**** dafny-mode

#+begin_src emacs-lisp
(use-package dafny-mode
  :defer t
  :custom
  (dafny-prover-args '("/compile:0" "/vcsCores:4"))
  (dafny-prover-background-args
   '("/timeLimit:20" "/autoTriggers:1" "/printTooltips" "/vcsCores:4")))
#+end_src

*** cc-mode

#+begin_src emacs-lisp
(use-package cc-mode
  :nix nil
  :mode (("\\.h\\(h?\\|xx\\|pp\\)\\'" . c++-mode)
         ("\\.m\\'" . c-mode)
         ("\\.mm\\'" . c++-mode))
  :hook (c-mode-common . my-c-mode-common-hook)
  :bind (:map c++-mode-map
              ("<" . self-insert-command)
              (">" . self-insert-command))
  :bind (:map c-mode-base-map
              ("#" . self-insert-command)
              ("{" . self-insert-command)
              ("}" . self-insert-command)
              ("/" . self-insert-command)
              ("*" . self-insert-command)
              (";" . self-insert-command)
              ("," . self-insert-command)
              (":" . self-insert-command)
              ("(" . self-insert-command)
              (")" . self-insert-command)
              ("<return>" . newline-and-indent)
              ("M-q" . c-fill-paragraph)
              ("M-j"))
  :custom
  (c-default-style '((java-mode . "gnu") (awk-mode . "awk") (other . "gnu")))
  :preface
  (defun my-c-mode-common-hook ()
    (set (make-local-variable 'parens-require-spaces) nil)

    (let ((bufname (buffer-file-name)))
      (when bufname
        (cond
         ((string-match "/ledger/" bufname)
          (c-set-style "ledger"))
         (t))))

    (font-lock-add-keywords
     'c++-mode '(("\\<\\(assert\\|DEBUG\\)(" 1 font-lock-warning-face t))))
  :config
  (add-to-list
   'c-style-alist
   '("ledger"
     (indent-tabs-mode . nil)
     (c-basic-offset . 2)
     (c-comment-only-line-offset . (0 . 0))
     (c-hanging-braces-alist
      . ((substatement-open before after)
         (arglist-cont-nonempty)))
     (c-offsets-alist
      . ((statement-block-intro . +)
         (knr-argdecl-intro . 5)
         (substatement-open . 0)
         (substatement-label . 0)
         (label . 0)
         (case-label . 0)
         (statement-case-open . 0)
         (statement-cont . +)
         (arglist-intro . +)
         (arglist-close . +)
         (inline-open . 0)
         (brace-list-open . 0)
         (topmost-intro-cont
          . (first c-lineup-topmost-intro-cont
                   c-lineup-gnu-DEFUN-intro-cont))))
     (c-special-indent-hook . c-gnu-impose-minimum)
     (c-block-comment-prefix . ""))))
#+end_src

*** cmake-mode

#+begin_src emacs-lisp
(use-package cmake-mode
  :mode ("CMakeLists.txt" "\\.cmake\\'"))
#+end_src

**** cmake-font-lock

#+begin_src emacs-lisp
(use-package cmake-font-lock
  :hook (cmake-mode . cmake-font-lock-activate))
#+end_src

*** css-mode

#+begin_src emacs-lisp
(use-package css-mode
  :mode "\\.css\\'")
#+end_src

*** csv-mode

#+begin_src emacs-lisp
(use-package csv-mode
  :mode "\\.csv\\'"
  :preface
  (defun csv-remove-commas ()
    (interactive)
    (goto-char (point-min))
    (while (re-search-forward "\"\\([^\"]+\\)\"" nil t)
      (replace-match (replace-regexp-in-string "," "" (match-string 1))))))
#+end_src

*** eglot

#+begin_src emacs-lisp
(use-package eglot
  :commands eglot
  :bind
  (:map eglot-mode-map
        ("M-^"     . eglot-find-implementation)
        ("C-c C-." . eglot-code-actions))
  :custom
  (eglot-autoshutdown t)
  :config
  (setq read-process-output-max (* 1024 1024))

  (add-to-list 'eglot-server-programs
               '((python-mode python-ts-mode) .
                 ("basedpyright-langserver" "--stdio")))

  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              ;; Show flymake diagnostics first.
              (setq eldoc-documentation-functions
                    (cons #'flymake-eldoc-function
                          (remove #'flymake-eldoc-function
                                  eldoc-documentation-functions))))))
#+end_src

**** eglot-booster

The [[https://github.com/blahgeek/emacs-lsp-booster][emacs-lsp-booster]] project provides a rust-based wrapper program which
substantially speeds up emacs' interactions with lsp servers. eglot-booster
enables [[https://github.com/joaotavora/eglot][eglot]] to use it.

#+begin_src emacs-lisp
(use-package eglot-booster
  :after eglot
  :config
  (eglot-booster-mode))
#+end_src

**** eglot-orderless

#+begin_src emacs-lisp
(use-package eglot-orderless
  :no-require t
  :after (eglot orderless)
  :config
  (add-to-list 'completion-category-overrides
               '(eglot (styles orderless basic))))
#+end_src

**** consult-eglot-embark

#+begin_src emacs-lisp
(use-package consult-eglot-embark
  :after (consult eglot embark))
#+end_src

*** lisp-mode

#+begin_src emacs-lisp
(use-package lisp-mode
  :defer t
  :hook ((emacs-lisp-mode lisp-mode)
         . (lambda () (add-hook 'after-save-hook #'check-parens nil t)))
  :custom
  (parens-require-spaces t)
  :init
  (dolist (mode '(ielm-mode
                  inferior-emacs-lisp-mode
                  inferior-lisp-mode
                  lisp-interaction-mode
                  lisp-mode
                  emacs-lisp-mode))
    (font-lock-add-keywords
     mode
     '(("(\\(lambda\\)\\>"
        (0 (ignore
            (compose-region (match-beginning 1)
                            (match-end 1) ?λ))))
       ("(\\(ert-deftest\\)\\>[         '(]*\\(setf[    ]+\\sw+\\|\\sw+\\)?"
        (1 font-lock-keyword-face)
        (2 font-lock-function-name-face
           nil t))))))
#+end_src

**** eldoc

#+begin_src emacs-lisp
(use-package eldoc
  :diminish
  :hook ((c-mode-common emacs-lisp-mode) . eldoc-mode)
  :custom
  (eldoc-echo-area-use-multiline-p 3)
  (eldoc-echo-area-display-truncation-message nil))
#+end_src

**** elint

#+begin_src emacs-lisp
(use-package elint
  :commands (elint-initialize elint-current-buffer)
  :bind ("C-c e E" . my-elint-current-buffer)
  :preface
  (defun my-elint-current-buffer ()
    (interactive)
    (elint-initialize)
    (elint-current-buffer))
  :config
  (add-all-to-list 'elint-standard-variables
                   'current-prefix-arg
                   'command-line-args-left
                   'buffer-file-coding-system
                   'emacs-major-version
                   'window-system))
#+end_src

**** elisp-depend

#+begin_src emacs-lisp
(use-package elisp-depend
  :commands elisp-depend-print-dependencies)
#+end_src

**** elisp-docstring-mode

#+begin_src emacs-lisp
(use-package elisp-docstring-mode
  :commands elisp-docstring-mode)
#+end_src

**** elisp-slime-nav

#+begin_src emacs-lisp
(use-package elisp-slime-nav
  :diminish
  :commands (elisp-slime-nav-mode
             elisp-slime-nav-find-elisp-thing-at-point))
#+end_src

**** elmacro

#+begin_src emacs-lisp
(use-package elmacro
  :bind (("C-c m e" . elmacro-mode)
         ("C-x C-)" . elmacro-show-last-macro)))
#+end_src

**** ielm

#+begin_src emacs-lisp
(use-package ielm
  :commands ielm
  :bind (:map ielm-map ("<return>" . my-ielm-return))
  :config
  (defun my-ielm-return ()
    (interactive)
    (let ((end-of-sexp (save-excursion
                         (goto-char (point-max))
                         (skip-chars-backward " \t\n\r")
                         (point))))
      (if (>= (point) end-of-sexp)
          (progn
            (goto-char (point-max))
            (skip-chars-backward " \t\n\r")
            (delete-region (point) (point-max))
            (call-interactively #'ielm-return))
        (call-interactively #'paredit-newline)))))
#+end_src

**** lispy

#+begin_src emacs-lisp
(use-package lispy
  :commands lispy-mode
  :bind (:map lispy-mode-map
              ("M-j"))
  :bind (:map emacs-lisp-mode-map
              ("C-!"     . lispy-describe-inline)
              ("C-@"     . lispy-arglist-inline)
              ("C-c C-j" . lispy-goto)))
#+end_src

**** paredit

#+begin_src emacs-lisp
(use-package paredit
  :diminish
  :hook
  ((lisp-mode emacs-lisp-mode) . paredit-mode)
  (paredit-mode . my-paredit-init)
  :bind (:map
         paredit-mode-map
         ("[")
         ("M-r")
         ("M-s")
         ("M-k"     . paredit-raise-sexp)
         ("M-I"     . paredit-splice-sexp)
         ("C-M-l"   . paredit-recentre-on-sexp)
         :prefix-map my-paredit-map
         :prefix "C-c ("
         ("n" . paredit-add-to-next-list)
         ("p" . paredit-add-to-previous-list)
         ("j" . paredit-join-with-next-list)
         ("J" . paredit-join-with-previous-list)
         :map
         lisp-mode-map
         ("M-r")
         ("<return>" . paredit-newline)
         :map
         emacs-lisp-mode-map
         ("M-r")
         ("<return>" . paredit-newline))
  :preface
  (defun my-paredit-init ()
    (unbind-key "M-r" 'paredit-mode-map)
    (unbind-key "M-s" 'paredit-mode-map)))
#+end_src

***** paredit-eldoc

#+begin_src emacs-lisp
(use-package paredit-eldoc
  :no-require t
  :after (paredit eldoc)
  :config
  (eldoc-add-command 'paredit-backward-delete
                     'paredit-close-round))
#+end_src

***** paredit-ext

#+begin_src emacs-lisp
(use-package paredit-ext
  :after paredit)
#+end_src

**** redshank

#+begin_src emacs-lisp
(use-package redshank
  :diminish
  :hook ((lisp-mode emacs-lisp-mode) . redshank-mode))
#+end_src

**** slime

#+begin_src emacs-lisp
(use-package slime
  :commands slime
  :custom
  (slime-kill-without-query-p t)
  (slime-repl-history-file (user-data "slime-history.eld"))
  (slime-startup-animation nil)
  :init
  (setq inferior-lisp-program "sbcl"
        slime-contribs '(slime-fancy)))
#+end_src

**** inspector

#+begin_src emacs-lisp
(use-package inspector
  :commands
  (inspector-inspect
   inspector-inspect-expression
   inspector-inspect-expression)
  :init
  (defalias 'inspect #'inspector-inspect))
#+end_src

***** tree-inspector

#+begin_src emacs-lisp
(use-package tree-inspector
  :after inspector
  :commands
  (tree-inspector-inspect-expression
   tree-inspector-inspect-expression))
#+end_src

**** easky

#+begin_src emacs-lisp
(use-package easky
  :commands (easky)
  :custom
  (easky-show-tip nil))
#+end_src

*** COMMENT fetchmail-mode

#+begin_src emacs-lisp
(use-package fetchmail-mode
  :nix nil
  :commands fetchmail-mode)
#+end_src

*** graphviz-dot-mode

#+begin_src emacs-lisp
(use-package graphviz-dot-mode
  :mode "\\.dot\\'")
#+end_src

*** haskell-mode

#+begin_src emacs-lisp
(use-package haskell-mode
  :mode (("\\.hs\\(c\\|-boot\\)?\\'" . haskell-mode)
         ("\\.lhs\\'" . haskell-literate-mode)
         ("\\.cabal\\'" . haskell-cabal-mode))
  :bind (:map
         haskell-mode-map
         ("C-c C-h" . my-haskell-hoogle)
         ("C-c C-," . haskell-navigate-imports)
         ("C-c C-." . haskell-mode-format-imports)
         ("C-c C-u" . my-haskell-insert-undefined)
         ("C-c C-z" . haskell-interactive-switch)
         ("M-s")
         ("M-t"))
  :hook
  (haskell-mode . my-haskell-mode-hook)
  :custom
  (haskell-compile-cabal-build-command
   "cd %s && cabal new-build --ghc-option=-ferror-spans")
  (haskell-hasktags-arguments '("-e"))
  (haskell-tags-on-save t)
  (haskell-hoogle-command nil)
  (haskell-indent-spaces 2)
  (haskell-indentation-ifte-offset 2)
  (haskell-indentation-layout-offset 2)
  (haskell-indentation-left-offset 2)
  (haskell-indentation-starter-offset 2)
  (haskell-indentation-where-post-offset 2)
  (haskell-indentation-where-pre-offset 0)
  (haskell-process-args-cabal-repl
   '("--ghc-option=-ferror-spans"
     "--repl-options=-Wno-missing-home-modules"
     "--repl-options=-ferror-spans"))
  (haskell-process-load-or-reload-prompt t)
  :functions
  (haskell-check-remove-overlays
   haskell-goto-next-error
   haskell-goto-prev-error
   haskell-process-consume
   haskell-process-errors-warnings
   haskell-process-extract-modules
   haskell-process-import-modules
   haskell-process-reload-with-fbytecode
   haskell-process-response-cursor
   haskell-process-set-response-cursor
   haskell-session-name)
  :preface
  (defun my-haskell-insert-undefined ()
    (interactive) (insert "undefined"))

  (defun snippet (name)
    (interactive "sName: ")
    (find-file (expand-file-name (concat name ".hs")
                                 "~/src/notes/haskell"))
    (haskell-mode)
    (goto-char (point-min))
    (when (eobp)
      (insert "hdr")
      (yas-expand)))

  (defvar hoogle-server-process nil)

  (defun my-haskell-hoogle (query &optional _arg)
    "Do a Hoogle search for QUERY."
    (interactive
     (let ((def (haskell-ident-at-point)))
       (if (and def (symbolp def)) (setq def (symbol-name def)))
       (list (read-string (if def
                              (format "Hoogle query (default %s): " def)
                            "Hoogle query: ")
                          nil nil def)
             current-prefix-arg)))
    (let ((pe process-environment)
          (ep exec-path)
          ;; (default-hoo (expand-file-name
          ;;               "default.hoo"
          ;;               (locate-dominating-file "." "default.hoo")))
          )
      (unless (and hoogle-server-process
                   (process-live-p hoogle-server-process))
        (message "Starting local Hoogle server on port 8687...")
        (with-current-buffer (get-buffer-create " *hoogle-web*")
          (cd temporary-file-directory)
          (let ((process-environment pe)
                (exec-path ep))
            (setq hoogle-server-process
                  (start-process "hoogle-web" (current-buffer)
                                 (executable-find "hoogle")
                                 "server"
                                 ;; (concat "--database=" default-hoo)
                                 "--local" "--port=8687"))))
        (sit-for 1)
        (message "Starting local Hoogle server on port 8687...done")))
    (browse-url
     (format "http://127.0.0.1:8687/?hoogle=%s"
             (replace-regexp-in-string
              " " "+" (replace-regexp-in-string "\\+" "%2B" query)))))

  (defvar haskell-prettify-symbols-alist
    '(("::"     . ?∷)
      ("forall" . ?∀)
      ("exists" . ?∃)
      ("->"     . ?→)
      ("<-"     . ?←)
      ("=>"     . ?⇒)
      ("~>"     . ?⇝)
      ("<~"     . ?⇜)
      ("<>"     . ?⨂)
      ("msum"   . ?⨁)
      ("\\"     . ?λ)
      ("not"    . ?¬)
      ("&&"     . ?∧)
      ("||"     . ?∨)
      ("/="     . ?≠)
      ("<="     . ?≤)
      (">="     . ?≥)
      ("<<<"    . ?⋘)
      (">>>"    . ?⋙)

      ("`elem`"             . ?∈)
      ("`notElem`"          . ?∉)
      ("`member`"           . ?∈)
      ("`notMember`"        . ?∉)
      ("`union`"            . ?∪)
      ("`intersection`"     . ?∩)
      ("`isSubsetOf`"       . ?⊆)
      ("`isNotSubsetOf`"    . ?⊄)
      ("`isSubsequenceOf`"  . ?⊆)
      ("`isProperSubsetOf`" . ?⊂)
      ("undefined"          . ?⊥)))

  (defun my-update-cabal-repl (&rest _args)
    (let ((it (getenv "CABAL_REPL")))
      (when it
        (let ((args (nthcdr 2 (split-string it))))
          (setq-local haskell-process-args-cabal-repl
                      (delete-dups
                       (append haskell-process-args-cabal-repl args)))))))

  (eval-when-compile
    (require 'diminish))

  (defun my-haskell-mode-hook ()
    (haskell-indentation-mode)
    (whitespace-mode 1)
    (bug-reference-prog-mode 1)

    (setq-local prettify-symbols-alist haskell-prettify-symbols-alist)
    (prettify-symbols-mode 1)

    (advice-add 'direnv-update-directory-environment
                :after #'my-update-cabal-repl)

    (when (executable-find "ormolu")
      (require 'format-all)
      (define-format-all-formatter
       ormolu
       (:executable "ormolu")
       (:install "stack install ormolu")
       (:languages "Haskell" "Literate Haskell")
       (:features)
       (:format
        (format-all--buffer-easy
         executable
         (when (buffer-file-name)
           (list "--stdin-input-file" (buffer-file-name))))))
      (format-all--set-chain "Haskell" '(ormolu))
      ;; (format-all-mode 1)
      ))
  :config
  (use-package align
    :defer t
    :config
    (add-to-list
     'align-rules-list
     (mapcar (lambda (x)
               `(,(car x)
                 (regexp . ,(cdr x))
                 (modes quote (haskell-mode haskell-literate-mode))))
             '((haskell-types       . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
               (haskell-assignment  . "\\(\\s-+\\)=\\s-+")
               (haskell-arrows      . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
               (haskell-left-arrows . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+"))))))
#+end_src

**** haskell-edit

#+begin_src emacs-lisp
(use-package haskell-edit
  :load-path "lisp/haskell-config"
  :after haskell-mode
  :bind (:map haskell-mode-map
              ("C-c M-q" . haskell-edit-reformat)))
#+end_src

**** haskell-eglot

#+begin_src emacs-lisp
(use-package haskell-eglot
  :no-require t
  :demand t
  :after (eglot)
  :config
  (add-to-list 'eglot-server-programs
               '(haskell-mode . ("haskell-language-server" "--lsp")))
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (setq-local eldoc-documentation-strategy
                          #'eldoc-documentation-default))
            t))
#+end_src

*** hcl-mode

#+begin_src emacs-lisp
(use-package hcl-mode
  :mode "\.nomad\\'")
#+end_src

*** json-mode

#+begin_src emacs-lisp
(use-package json-mode
  :mode "\\.json\\'")
#+end_src

**** json-reformat

#+begin_src emacs-lisp
(use-package json-reformat
  :after json-mode)
#+end_src

**** json-snatcher

#+begin_src emacs-lisp
(use-package json-snatcher
  :after json-mode)
#+end_src

*** ledger-mode

#+begin_src emacs-lisp
(use-package ledger-mode
  :load-path "~/src/ledger/lisp"
  :mode "\\.ledger\\'"
  :commands ledger-mode
  :bind ("C-c L" . my-ledger-start-entry)
  :custom
  (ledger-binary-path "ledger")
  (ledger-file "/Volumes/Files/Accounts/ledger.dat")
  :preface
  (defun my-ledger-start-entry (&optional _arg)
    (interactive "p")
    (find-file-other-window "/Volumes/Files/Accounts/ledger.dat")
    (goto-char (point-max))
    (skip-syntax-backward " ")
    (if (looking-at "\n\n")
        (goto-char (point-max))
      (delete-region (point) (point-max))
      (insert ?\n)
      (insert ?\n))
    (insert (format-time-string "%Y/%m/%d ")))

  (defun ledger-matchup ()
    (interactive)
    (while (re-search-forward "\\(\\S-+Unknown\\)\\s-+\\$\\([-,0-9.]+\\)"
                              nil t)
      (let ((account-beg (match-beginning 1))
            (account-end (match-end 1))
            (amount (match-string 2))
            account answer)
        (goto-char account-beg)
        (set-window-point (get-buffer-window) (point))
        (recenter)
        (redraw-display)
        (with-current-buffer (get-buffer "nrl-mastercard-old.dat")
          (goto-char (point-min))
          (when (re-search-forward (concat "\\(\\S-+\\)\\s-+\\$" amount)
                                   nil t)
            (setq account (match-string 1))
            (goto-char (match-beginning 1))
            (set-window-point (get-buffer-window) (point))
            (recenter)
            (redraw-display)
            (setq answer
                  (read-char (format "Is this a match for %s (y/n)? "
                                     account)))))
        (when (eq answer ?y)
          (goto-char account-beg)
          (delete-region account-beg account-end)
          (insert account))
        (forward-line))))

  (defun my-ledger-add-symbols ()
    (interactive)
    (while (re-search-forward " \\(BOT\\|SOLD\\) [+-][0-9,]+ \\(\\S-+\\) " nil t)
      (forward-line 2)
      (goto-char (line-beginning-position))
      (insert "    ; Symbol: " (match-string 2) ?\n)))
  :config
  (add-hook 'ledger-mode-hook (lambda () (auto-fill-mode -1))))
#+end_src

*** COMMENT lsp-bridge

#+begin_src emacs-lisp
(use-package lsp-bridge
  :commands (global-lsp-bridge-mode)
  :custom
  (lsp-bridge-enable-log nil))
#+end_src

*** COMMENT lsp-mode

#+begin_src emacs-lisp
(use-package lsp-mode
  :commands lsp
  :custom
  (lsp-completion-enable t)
  (lsp-eldoc-enable-hover nil)
  (lsp-eldoc-render-all t)
  (lsp-enable-eldoc nil)
  (lsp-haskell-process-args-hie '("-l" "/tmp/hie.log"))
  (lsp-headerline-breadcrumb-enable nil)
  (lsp-highlight-symbol-at-point nil)
  (lsp-idle-delay 0.6)
  (lsp-inhibit-message t)
  (lsp-prefer-capf t)
  (lsp-prefer-flymake nil)
  ;; what to use when checking on-save. "check" is default, I prefer clippy
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-rust-analyzer-server-display-inlay-hints t)
  (lsp-rust-clippy-preference "on")
  (lsp-rust-features ["test"])
  (lsp-server-install-dir (user-data ".cache/lsp"))
  (lsp-session-file (user-data ".lsp-session-v1"))
  :config
  (use-package lsp-lens)
  (use-package lsp-headerline)
  (setq read-process-output-max 16384))
#+end_src

**** lsp-mode-corfu

#+begin_src emacs-lisp
(use-package lsp-mode-corfu
  :no-require t
  :after (corfu lsp-mode)
  :custom
  (lsp-completion-provider :none)) ;; we use corfu
#+end_src

**** lsp-mode-orderless

#+begin_src emacs-lisp
(use-package lsp-mode-orderless
  :no-require t
  :after (orderless lsp-mode)
  :hook
  (lsp-completion-mode . my/lsp-mode-setup-completion)
  :preface
  (defun my/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))))
#+end_src

**** lsp-haskell

#+begin_src emacs-lisp
(use-package lsp-haskell
  :after lsp-mode
  :config
  (setq lsp-haskell-server-path "haskell-language-server"))
#+end_src

**** lsp-ui

#+begin_src emacs-lisp
(use-package lsp-ui
  :after lsp-mode
  :bind (:map
         lsp-ui-mode-map
         ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
         ([remap xref-find-references]  . lsp-ui-peek-find-references))
  :hook (lsp-mode . lsp-ui-mode)
  :custom
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-max-height 60)
  (lsp-ui-doc-text-scale-level 4)
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-sideline-show-diagnostics nil)
  (lsp-ui-sideline-show-hover t))
#+end_src

*** lua-mode

#+begin_src emacs-lisp
(use-package lua-mode
  :mode "\\.lua\\'"
  :interpreter "lua")
#+end_src

*** mhtml-mode

#+begin_src emacs-lisp
(use-package mhtml-mode
  :bind (:map html-mode-map
              ("<return>" . newline-and-indent)))
#+end_src

*** nginx-mode

#+begin_src emacs-lisp
(use-package nginx-mode
  :commands nginx-mode)
#+end_src

*** nix-mode

#+begin_src emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'"
  :custom
  (nix-indent-function 'nix-indent-line))
#+end_src

**** nix-update

#+begin_src emacs-lisp
(use-package nix-update
  :load-path "lisp/nix-update"
  :bind ("C-c U" . nix-update-fetch))
#+end_src

*** nroff-mode

#+begin_src emacs-lisp
(use-package nroff-mode
  :commands nroff-mode
  :preface
  (defun update-nroff-timestamp ()
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^\\.Dd " nil t)
        (let ((stamp (format-time-string "%B %e, %Y")))
          (unless (looking-at stamp)
            (delete-region (point) (line-end-position))
            (insert stamp)
            (let (after-save-hook)
              (save-buffer)))))))
  :config
  (add-hook 'nroff-mode-hook
            (lambda () (add-hook 'after-save-hook
                            #'update-nroff-timestamp nil t))))
#+end_src

*** nxml-mode

#+begin_src emacs-lisp
(use-package nxml-mode
  :commands nxml-mode
  :bind (:map nxml-mode-map
              ("<return>" . newline-and-indent)
              ("C-c M-h"  . tidy-xml-buffer))
  :custom
  (nxml-sexp-element-flag t)
  (nxml-slash-auto-complete-flag t)
  :preface
  (defun tidy-xml-buffer ()
    (interactive)
    (save-excursion
      (call-process-region (point-min) (point-max) "tidy" t t nil
                           "-xml" "-i" "-wrap" "0" "-omit" "-q" "-utf8")))
  :init
  (defalias 'xml-mode 'nxml-mode)
  :config
  (autoload 'sgml-skip-tag-forward "sgml-mode")
  (add-to-list 'hs-special-modes-alist
               '(nxml-mode
                 "<!--\\|<[^/>]*[^/]>"
                 "-->\\|</[^/>]*[^/]>"
                 "<!--"
                 sgml-skip-tag-forward
                 nil)))
#+end_src

*** pact-mode

#+begin_src emacs-lisp
(use-package pact-mode
  :mode "\\.pact\\'"
  :commands (pact-compile)
  :defines (pact-mode pact-mode-hook)
  :preface
  (eval-when-compile
    (defvar slime-mode-map))
  :bind (:map slime-mode-map
              ("C-c C-c" . (lambda () (interactive)
                             (save-excursion
                               (call-interactively #'pact-compile)))))
  :config
  (use-package slime))
#+end_src

**** pact-mode-eglot

#+begin_src emacs-lisp
(use-package pact-mode-eglot
  :no-require t
  :after eglot
  :hook (pact-mode . eglot-ensure)
  :config
  (add-to-list 'eglot-server-programs '(pact-mode . ("pact-lsp"))))
#+end_src

*** plantuml-mode

#+begin_src emacs-lisp
(use-package plantuml-mode
  :mode "\\.plantuml\\'"
  :custom
  (plantuml-default-exec-mode 'executable)
  (plantuml-jar-path (expand-file-name "lib/plantuml.jar" (getenv "PROFILE_DIR"))))
#+end_src

*** COMMENT po-mode

#+begin_src emacs-lisp
(use-package po-mode
  :mode "\\.\\(po\\'\\|po\\.\\)")
#+end_src

*** proof-general

#+begin_src emacs-lisp
(use-package proof-site
  :custom
  (proof-auto-action-when-deactivating-scripting 'retract)
  (proof-autosend-enable nil)
  (proof-electric-terminator-enable t)
  (proof-fast-process-buffer nil)
  (proof-script-fly-past-comments t)
  (proof-shell-fiddle-frames nil)
  (proof-splash-enable nil)
  (proof-sticky-errors t)
  (proof-tidy-response t)
  :custom-face
  (proof-eager-annotation-face ((t nil)))
  (proof-locked-face ((t (:background "#180526"))))
  (proof-omitted-proof-face ((t (:extend t :background "#23103c"))))
  (proof-queue-face ((t (:background "#431807"))))
  (proof-script-sticky-error-face ((t (:background "#50110e"))))
  (proof-warning-face ((t (:background "orange4"))))
  :functions
  (proof-layout-windows
   proof-prf)
  :preface
  (defun my-layout-proof-windows ()
    (interactive)
    (proof-layout-windows)
    (proof-prf))
  :config
  (use-package coq-mode
    :bind (:map coq-mode-map
                ("M-RET"       . proof-goto-point)
                ("RET"         . newline-and-indent)
                ("C-c h")
                ("C-c C-p"     . my-layout-proof-windows)
                ("C-c C-a C-s" . coq-Search)
                ("C-c C-a C-a" . coq-Search)
                ("C-c C-a C-r" . coq-SearchRewrite))
    :custom
    (coq-compile-auto-save 'save-coq)
    (coq-compile-before-require t)
    (coq-compile-parallel-in-background t)
    (coq-holes-minor-mode nil)
    (coq-maths-menu-enable t)
    (coq-one-command-per-line nil)
    (coq-prefer-top-of-conclusion t)
    (coq-prog-args '("-emacs"))
    :custom-face
    (coq-symbol-face ((t (:inherit default-face))))
    :preface
    (eval-when-compile (defvar proof-assistant nil))
    :config
    (add-hook
     'coq-mode-hook
     (lambda ()
       (set-input-method "Agda")
       (holes-mode -1)
       (abbrev-mode -1)

       (bind-key "s-g" (lambda () (interactive) (insert "Γ")) 'coq-mode-map)
       (bind-key "s-t" (lambda () (interactive) (insert "τ")) 'coq-mode-map)
       (bind-key "s-r" (lambda () (interactive) (insert "ρ")) 'coq-mode-map)
       (bind-key "s-k" (lambda () (interactive) (insert "κ")) 'coq-mode-map)

       (set (make-local-variable 'fill-nobreak-predicate)
            (lambda ()
              (pcase (get-text-property (point) 'face)
                ('font-lock-comment-face nil)
                ((and (pred listp)
                      x (guard (memq 'font-lock-comment-face x)))
                 nil)
                (_ t)))))))

  (use-package pg-user
    :defer t
    :config
    (advice-add 'proof-retract-buffer :around
                (lambda (oldfun &rest args)
                  (condition-case err
                      (apply oldfun args)
                    (error (shell-command "killall coqtop")))))))
#+end_src

**** company-coq

#+begin_src emacs-lisp
(use-package company-coq
  :after coq
  :commands company-coq-mode
  :bind (:map company-coq-map
              ;; ("<tab>" . company-complete)
              ("M-<return>"))
  :bind (:map coq-mode-map
              ("C-M-h" . company-coq-toggle-definition-overlay))
  :hook (coq-mode . company-coq-mode)
  :custom
  (company-coq-disabled-features
   '(hello prettify-symbols smart-subscripts dynamic-symbols-backend))
  (company-coq-prettify-symbols-alist
   '(("|-"     . 8866)
     ("True"   . 8868)
     ("False"  . 8869)
     ("->"     . 8594)
     ("-->"    . 10230)
     ("<-"     . 8592)
     ("<--"    . 10229)
     ("<->"    . 8596)
     ("<-->"   . 10231)
     ("==>"    . 10233)
     ("<=="    . 10232)
     ("++>"    . 10239)
     ("<++"    . 11059)
     ("fun"    . 955)
     ("forall" . 8704)
     ("exists" . 8707)
     ("/\\"    . 8743)
     ("\\/"    . 8744)
     ("~"      . 172)
     ("+-"     . 177)
     ("<="     . 8804)
     (">="     . 8805)
     ("<>"     . 8800)
     ("*"      . 215)
     ("++"     . 10746)
     ("nat"    . 120029)
     ("Z"      . 8484)
     ("N"      . 8469)
     ("Q"      . 8474)
     ("Real"   . 8477)
     ("bool"   . 120121)
     ("Prop"   . 120031)))
  :custom-face
  (company-coq-features/code-folding-bullet-face ((t (:weight bold))))
  :functions (cape-company-to-capf)
  :config
  (add-hook 'company-coq-mode-hook
            (lambda ()
              ;; (company-mode -1)
              (require 'cape)
              (setq-local completion-at-point-functions
                          (mapcar #'cape-company-to-capf
                                  company-coq-enabled-backends)))))
#+end_src

**** coq-lookup

#+begin_src emacs-lisp
(use-package coq-lookup
  :bind ("C-h q" . coq-lookup)
  :custom
  (coq-lookup-browse-pdf-function
   '(lambda (pdf page) (call-process "open" nil nil nil pdf)))
  (coq-lookup-pdf "~/.local/share/coq/coq-8.19.2-reference-manual.pdf"))
#+end_src

**** prover

#+begin_src emacs-lisp
(use-package prover
  :after coq)
#+end_src

*** protobuf-mode

#+begin_src emacs-lisp
(use-package protobuf-mode
  :mode "\\.proto\\'")
#+end_src

*** python-mode

#+begin_src emacs-lisp
(use-package python-mode
  :mode "\\.py\\'"
  :interpreter "python"
  :bind (:map
         python-mode-map
         ("C-c c")
         ("C-c C-z" . run-python))
  :preface
  (defvar python-mode-initialized nil)

  (defun my-python-mode-hook ()
    (interactive)
    (unless python-mode-initialized
      (setq python-mode-initialized t)

      (info-lookup-add-help
       :mode 'python-mode
       :regexp "[a-zA-Z_0-9.]+"
       :doc-spec
       '(("(python)Python Module Index" )
         ("(python)Index"
          (lambda
            (item)
            (cond
             ((string-match
               "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
              (format "%s.%s" (match-string 2 item)
                      (match-string 1 item)))))))))

    (set (make-local-variable 'parens-require-spaces) nil)
    (setq indent-tabs-mode nil))
  :config
  (add-hook 'python-mode-hook #'my-python-mode-hook))
#+end_src

*** elpy

#+begin_src emacs-lisp
(use-package elpy
  :after (python-mode)
  :demand t
  ;; :hook
  ;; (python-mode . elpy-enable)
  :custom
  (elpy-test-runner 'elpy-test-pytest-runner))
#+end_src

*** riscv-mode

#+begin_src emacs-lisp
(use-package riscv-mode
  :commands riscv-mode)
#+end_src

*** ruby-mode

#+begin_src emacs-lisp
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :bind (:map ruby-mode-map
              ("<return>" . my-ruby-smart-return))
  :preface
  (defun my-ruby-smart-return ()
    (interactive)
    (when (memq (char-after) '(?\| ?\" ?\'))
      (forward-char))
    (call-interactively #'newline-and-indent)))
#+end_src

*** rust-mode

#+begin_src emacs-lisp
(use-package rust-mode
  :mode "\\.rs\\'"
  :bind (:map rust-mode-map
              ("C-c C-c v" . (lambda ()
                               (interactive)
                               (shell-command "rustdocs std"))))
  :hook (rust-mode . yas-minor-mode-on)
  :custom
  (rust-format-on-save t)
  :preface
  (defun my-rust-project-find-function (dir)
    (let ((root (locate-dominating-file dir "Cargo.toml")))
      (and root (cons 'transient root))))
  :init
  (with-eval-after-load 'project
    (add-to-list 'project-find-functions 'my-rust-project-find-function)))
#+end_src

**** rust-mode-eglot

#+begin_src emacs-lisp
(use-package rust-mode-eglot
  :no-require t
  :after eglot
  :hook (rust-mode . eglot-ensure)
  :config
  (add-to-list 'eglot-server-programs '(rust-mode "rust-analyzer")))
#+end_src

**** cargo

#+begin_src emacs-lisp
(use-package cargo
  :commands cargo-minor-mode
  :bind (:map cargo-mode-map
              ("C-c C-c C-y" . cargo-process-clippy))
  :hook (rust-mode . my-rust-mode-cargo-init)
  :custom
  (cargo-process--command-clippy "clippy")
  :preface
  (defun my-update-cargo-path (&rest _args)
    (setq cargo-process--custom-path-to-bin
          (executable-find "cargo")))

  (defun my-cargo-target-dir (path)
    (replace-regexp-in-string "kadena" "Products" path))

  (defun my-update-cargo-args (ad-do-it name command &optional last-cmd opens-external)
    (let* ((cmd (car (split-string command)))
           (new-args
            (if (member cmd '("build" "check" "clippy" "doc" "test"))
                (let ((args
                       (format "--target-dir=%s -j8"
                               (my-cargo-target-dir
                                (replace-regexp-in-string
                                 "target" "target--custom"
                                 (regexp-quote (getenv "CARGO_TARGET_DIR")))))))
                  (if (member cmd '("build"))
                      (concat "--message-format=short " args)
                    args))
              ""))
           (cargo-process--command-flags
            (pcase (split-string cargo-process--command-flags " -- ")
              (`(,before ,after)
               (concat before " " new-args " -- " after))
              (_ (concat cargo-process--command-flags new-args)))))
      (funcall ad-do-it name command last-cmd opens-external)))

  (defun my-rust-mode-cargo-init ()
    (advice-add 'direnv-update-directory-environment
                :after #'my-update-cargo-path)
    (advice-add 'cargo-process--start
                :around #'my-update-cargo-args)
    (advice-add 'cargo-process-clippy
                :around #'my-cargo-process-clippy-advice)
    (cargo-minor-mode 1))

  (defun my-cargo-process-clippy-advice (orig-fun &rest args)
    (let ((cargo-process--command-flags
           (concat cargo-process--command-flags
                   "--all-targets "
                   "--all-features "
                   "-- "
                   "-D warnings "
                   "-D clippy::all "
                   "-D clippy::mem_forget "
                   "-C debug-assertions=off")))
      (apply orig-fun args)))

  (defun cargo-fix ()
    (interactive)
    (async-shell-command
     (concat "cargo fix"
             " --clippy --tests --benches --allow-dirty --allow-staged"))))
#+end_src

*** sbt-mode

#+begin_src emacs-lisp
(use-package sbt-mode
  :mode "\\.sbt\\'")
#+end_src

*** scala-mode

#+begin_src emacs-lisp
(use-package scala-mode
  :mode "\\.scala\\'")
#+end_src

*** sh-script

#+begin_src emacs-lisp
(use-package sh-script
  :defer t
  :preface
  (defvar sh-script-initialized nil)

  (defun initialize-sh-script ()
    (unless sh-script-initialized
      (setq sh-script-initialized t)
      (info-lookup-add-help :mode 'shell-script-mode
                            :regexp ".*"
                            :doc-spec '(("(bash)Index")))))
  :init
  (add-hook 'shell-mode-hook #'initialize-sh-script))
#+end_src

*** swift-mode

#+begin_src emacs-lisp
(use-package swift-mode
  :commands swift-mode)
#+end_src

*** terraform-mode

#+begin_src emacs-lisp
(use-package terraform-mode
  :mode "\.tf\\'")
#+end_src

*** texinfo

#+begin_src emacs-lisp
(use-package texinfo
  :mode ("\\.texi\\'" . texinfo-mode)
  :preface
  (defun my-texinfo-mode-hook ()
    (dolist (mapping '((?b . "emph")
                       (?c . "code")
                       (?s . "samp")
                       (?d . "dfn")
                       (?o . "option")
                       (?x . "pxref")))
      (local-set-key (vector (list 'super (car mapping)))
                     `(lambda () (interactive)
                        (TeX-insert-macro ,(cdr mapping))))))
  :config
  (add-hook 'texinfo-mode-hook #'my-texinfo-mode-hook)

  (defun texinfo-outline-level ()
    ;; Calculate level of current texinfo outline heading.
    (require 'texinfo)
    (save-excursion
      (if (bobp)
          0
        (forward-char 1)
        (let* ((word (buffer-substring-no-properties
                      (point) (progn (forward-word) (point))))
               (entry (assoc word texinfo-section-list)))
          (if entry
              (nth 1 entry)
            5))))))
#+end_src

*** tla-mode

#+begin_src emacs-lisp
(use-package tla-mode
  :mode "\\.tla\\'"
  :config
  (add-hook 'tla-mode-hook
            (lambda ()
              (setq-local comment-start nil)
              (setq-local comment-end ""))))
#+end_src

*** tuareg

#+begin_src emacs-lisp
(use-package tuareg
  :mode (("\\.ml[4ip]?\\'" . tuareg-mode)
         ("\\.eliomi?\\'"  . tuareg-mode)))
#+end_src

*** typescript-mode

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\.ts\\'")
#+end_src

*** wat-mode

#+begin_src emacs-lisp
(use-package wat-mode
  :mode "\\.was?t\\'")
#+end_src

*** COMMENT x86-lookup

#+begin_src emacs-lisp
(use-package x86-lookup
  :bind ("C-h X" . x86-lookup)
  :custom
  (x86-lookup-browse-pdf-function
   (lambda
     (pdf page)
     (org-pdfview-open
      (concat pdf "::" page))))
  (x86-lookup-pdf "~/.local/share/x86/325462-sdm-vol-1-2abcd-3abcd.pdf"))
#+end_src

*** yaml-mode

#+begin_src emacs-lisp
(use-package yaml-mode
  :mode "\\.\\(ya?ml\\|poet\\)\\'")
#+end_src

*** z3-mode

#+begin_src emacs-lisp
(use-package z3-mode
  :mode "\\.smt\\'"
  :bind (:map z3-mode-map
              ("C-c C-c" . z3-execute-region))
  :custom
  (z3-solver-cmd "z3"))
#+end_src

*** z3

#+begin_src emacs-lisp
(use-package z3
  :load-path "lisp/emacs-z3"
  :commands (z3-get-model))
#+end_src

** Gnus

#+begin_src emacs-lisp
(use-package gnus-start
  :nix nil
  :commands (gnus)
  :bind ("M-G" . switch-to-gnus)
  :custom
  (gnus-activate-level 2)
  (gnus-always-read-dribble-file t)
  (gnus-asynchronous t)
  (gnus-check-new-newsgroups nil)
  (gnus-default-adaptive-score-alist
   '((gnus-saved-mark
      (subject 250)
      (from 50))
     (gnus-dormant-mark
      (subject 150)
      (from 50))
     (gnus-forwarded-mark
      (subject 100)
      (from 25))
     (gnus-replied-mark
      (subject 75)
      (from 15))
     (gnus-ticked-mark
      (subject 0)
      (from 0))
     (gnus-read-mark
      (subject 30)
      (from 5))
     (gnus-del-mark
      (subject 5)
      (from 0))
     (gnus-recent-mark
      (subject 0)
      (from 0))
     (gnus-killed-mark
      (subject -5)
      (from -5))
     (gnus-catchup-mark
      (subject -150)
      (from 0))
     (gnus-duplicate-mark
      (subject -150)
      (from 0))
     (gnus-expirable-mark
      (subject -250)
      (from 0))
     (gnus-spam-mark
      (subject -10)
      (from -150))))
  (gnus-gcc-mark-as-read t)
  (gnus-generate-tree-function 'gnus-generate-horizontal-tree)
  (gnus-interactive-exit 'quiet)
  (gnus-large-newsgroup 4000)
  (gnus-local-domain "newartisans.com")
  (gnus-mailing-list-groups "\\`\\(list\\|wg21\\)\\.")
  (gnus-mark-unpicked-articles-as-read t)
  (gnus-message-archive-group "Sent")
  (gnus-message-replysign t)
  (gnus-novice-user nil)
  (gnus-parameters
   '(
     ;; Emacs     spam pos: Spam[unread] -> Spam[read] -> IsSpam
     ;; Emacs     spam fls: Spam[unread] -> TrainGood -> IsGood
     ;; Emacs     good fls: INBOX -> TrainSpam -> IsSpam
     ;; Fastmail  spam pos: Spam[unread] -> Spam[read] -> IsSpam
     ;; Fastmail  spam fls: Spam[unread] -> TrainGood -> IsGood
     ;; SpamSieve spam fls: Spam[unread] -> INBOX
     ;; Fastmail  good fls: INBOX -> TrainSpam -> IsSpam
     ;; SpamSieve good fls: INBOX -> IsSpam
     ;;
     ;; The only reason to have both Spam and TrainSpam, is that the Remote
     ;; Training script used with SpamSieve only consider read messages in
     ;; Spam, but both read and unread messages in TrainSpam. Otherwise, all
     ;; other details are the same.
     ("Spam"
      (total-expire . t)
      (expiry-wait . 31)
      (expiry-target . delete)
      (ham-process-destination . "TrainGood")
      (spam-process-destination . "TrainSpam"))
     ("TrainSpam"
      (spam-contents gnus-group-spam-classification-spam))
     ("Good"
      (gcc-self . t)
      (gnus-use-scoring nil)
      (spam-process-destination . "TrainSpam"))
     ("IsGood"
      (total-expire . t)
      (expiry-wait . 1.1)
      (expiry-target . "INBOX"))
     ("\\(mail/\\|INBOX\\)"
      (total-expire . t)
      (expiry-wait . 90)
      (expiry-target . "Archive")
      (gcc-self . t)
      (gnus-use-scoring nil)
      (spam-process-destination . "TrainSpam"))
     ("list/"
      (subscribed . t)
      (gcc-self . nil)
      (spam-process-destination . "TrainSpam"))
     ("list/\\(github\\|misc\\|haskell\\|emacs\\|bahai/tarjuman\\)$"
      (total-expire . t)
      (expiry-wait . 90)
      (expiry-target . delete))
     ("list/ledger/devel"
      (to-list . "ledger-cli@googlegroups.com"))
     ("list/bahai/tarjuman"
      (to-list . "tarjuman@bahai-library.com")
      (list-identifier . "\\[tj\\]"))
     ("list/bahai/assembly"
      (gcc-self . t)
      (to-list . "carmichaellsa@gmail.com"))
     ("list/emacs/devel$"
      (to-list . "emacs-devel@gnu.org"))
     ("list/emacs/tangents$"
      (to-list . "emacs-tangents@gnu.org"))
     ("list/emacs/bugs$"
      (to-list . "bug-gnu-emacs@gnu.org"))
     ("list/emacs/sources"
      (to-list . "gnu-emacs-sources@gnu.org"))
     ("list/emacs/org-mode"
      (to-list . "emacs-orgmode@gnu.org")
      (list-identifier . "\\[O\\]"))
     ("list/haskell/infrastructure"
      (to-list . "haskell-infrastructure@community.galois.com")
      (list-identifier . "\\[Haskell-infrastructure\\]"))))
  (gnus-permanently-visible-groups "INBOX")
  (gnus-read-active-file nil)
  (gnus-read-newsrc-file nil)
  (gnus-refer-article-method
   '(current
     (nnregistry)
     ;; (nnir "nnimap:imap.fastmail.com")
     ;; (nntp "LocalNews"
     ;;       (nntp-address "localhost")
     ;;       (nntp-port-number 9119))
     ;; (nntp "Gmane"
     ;;       (nntp-address "news.gmane.org"))
     ;; (nntp "Eternal September"
     ;;       (nntp-address "news.eternal-september.org")
     ;;       (nntp-authinfo-user "jwiegley"))
     ))
  (gnus-registry-max-entries 9000)
  (gnus-registry-ignored-groups '(("nntp" t) ("^INBOX" t)))
  (gnus-save-killed-list nil)
  (gnus-save-newsrc-file nil)
  (gnus-signature-separator '("^-- $" "^-- *$" "^_____+$"))
  (gnus-simplify-subject-functions '(gnus-simplify-subject-fuzzy))
  (gnus-split-methods
   '((gnus-save-site-lisp-file)
     (gnus-article-archive-name)
     (gnus-article-nndoc-name)))
  (gnus-subscribe-newsgroup-method 'gnus-subscribe-topics)
  (gnus-suppress-duplicates t)
  (gnus-topic-display-empty-topics nil)
  (gnus-topic-line-format "%i[ %A: %(%{%n%}%) ]%v\n")
  (gnus-tree-minimize-window nil)
  (gnus-uncacheable-groups "^nnml")
  (gnus-use-adaptive-scoring '(line))
  (gnus-use-cache nil)
  (gnus-verbose 4)
  (ssl-certificate-verification-policy 1)
  :hook
  (kill-emacs . exit-gnus-on-exit)
  (gnus-after-getting-new-news . gnus-group-list-groups)
  (gnus-after-getting-new-news . gnus-group-save-newsrc)
  (gnus-after-getting-new-news . gnus-display-time-event-handler)
  (gnus-select-group . gnus-group-set-timestamp)
  (gnus-started . (lambda () (run-hooks 'gnus-after-getting-new-news-hook)))
  (gnus-suspend-gnus . gnus-group-save-newsrc)
  :functions
  (gnus-group-read-ephemeral-search-group
   gnus-summary-next-page)
  :preface
  (setq gnus-home-directory "~/.local/share/gnus/"
        gnus-startup-file (expand-file-name ".newsrc" gnus-home-directory))

  (defun activate-gnus ()
    (unless (get-buffer "*Group*")
      (gnus)))

  (defun switch-to-gnus (&optional arg)
    (interactive "P")
    (push-window-configuration)
    (let* ((alist '("\\`\\*unsent" "\\`\\*Summary" "\\`\\*Group"))
           (candidate
            (catch 'found
              (dolist (regexp alist)
                (dolist (buf (buffer-list))
                  (if (string-match regexp (buffer-name buf))
                      (throw 'found buf)))))))
      (if candidate
          (progn
            (switch-to-buffer candidate)
            (if (string-match "Group" (buffer-name candidate))
                (gnus-group-get-new-news)))
        (gnus)
        (gnus-group-list-groups gnus-activate-level)
        (gnus-group-get-all-new-news))))

  (defun gnus-goto-article (message-id)
    (activate-gnus)
    ;; (gnus-summary-read-group "Archive" 15 t)
    (gnus-group-read-ephemeral-search-group
     t (list
        (cons
         'search-query-spec
         (list (cons 'query
                     (concat "HEADER \"Message-ID\" \"<" message-id ">\""))
               '(raw)))
        (cons
         'search-group-spec
         '(("nnimap:imap.fastmail.com" "INBOX")
           ("nnimap:imap.fastmail.com" "mail/kadena")))))
    (gnus-summary-next-page))

  (defun exit-gnus-on-exit ()
    (if (and (fboundp 'gnus-group-exit)
             (gnus-alive-p))
        (with-current-buffer (get-buffer "*Group*")
          (let (gnus-interactive-exit)
            (gnus-group-exit)))))
  :init
  (setq gnus-select-method
        '(nnimap "imap.fastmail.com"
                 (nnimap-user "johnw@newartisans.com")
                 (nnimap-inbox "INBOX")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))

  :config
  (gnus-registry-initialize))
#+end_src

*** gnus-group

#+begin_src emacs-lisp
(use-package gnus-group
  :after gnus
  :hook
  (gnus-group-mode . gnus-topic-mode)
  (gnus-group-mode . hl-line-mode)
  :custom
  (gnus-group-default-list-level 2)
  (gnus-group-line-format "%S%p%P%M%5y: %(%B%G%B%)\n")
  (gnus-group-mode-hook '(gnus-topic-mode hl-line-mode))
  (gnus-group-use-permanent-levels t))
#+end_src

**** gnus-score

#+begin_src emacs-lisp
(use-package gnus-score
  :after gnus-group
  :custom
  (gnus-score-default-duration 'p)
  (gnus-score-expiry-days 30)
  (gnus-score-interactive-default-score 10))
#+end_src

**** my-gnus-score

#+begin_src emacs-lisp
(use-package my-gnus-score
  :after gnus-group
  :commands (my-gnus-score-groups my-gnus-score-followup)
  :bind (:map gnus-group-mode-map
              ("v g" . gnus-group-get-all-new-news))
  :custom
  (my-gnus-thread-sort-functions
   '(gnus-thread-sort-by-most-recent-date gnus-thread-sort-by-total-score))
  (my-gnus-score-groups-regex
   "\\`\\(list\\.\\|\\(Is\\)?Spam\\)")
  :preface
  (defun gnus-group-get-all-new-news (&optional arg)
    (interactive "P")
    (gnus-group-get-new-news 5)
    (gnus-group-list-groups (or arg 4))
    (my-gnus-score-groups)
    (gnus-group-list-groups (or arg 3))
    (gnus-group-save-newsrc t)))
#+end_src

*** gnus-sum

#+begin_src emacs-lisp
(use-package gnus-sum
  :bind (:map gnus-summary-mode-map
              ("F"             . gnus-summary-wide-reply-with-original)
              ("M-q"           . gnus-article-fill-long-lines)
              ("B <delete>"    . gnus-summary-delete-article)
              ("B <backspace>" . my-gnus-trash-article)
              ("X m"           . my-gnus-summary-save-parts))
  :hook
  (gnus-summary-mode . hl-line-mode)
  :custom
  (gnus-sum-thread-tree-false-root nil)
  (gnus-sum-thread-tree-single-indent nil)
  (gnus-sum-thread-tree-root nil)
  (gnus-sum-thread-tree-vertical "│ ")
  (gnus-sum-thread-tree-leaf-with-other "├—— ")
  (gnus-sum-thread-tree-single-leaf "└—— ")
  (gnus-sum-thread-tree-indent " ")
  (gnus-sum-thread-tree-single-indent nil)
  (gnus-summary-expunge-below -100)
  (gnus-summary-line-format "%«%3t %U%R %uS %ur %»%(%*%-14,14f   %«%B%»%)\n")
  (gnus-summary-mark-below -100)
  (gnus-summary-pick-line-format "%U%R %uS %ur %(%*%-14,14f  %B%s%)\n")
  (gnus-summary-prepared-hook '(gnus-summary-hide-all-threads))
  (gnus-summary-save-parts-default-mime ".*")
  (gnus-thread-expunge-below -1000)
  (gnus-thread-hide-subtree t)
  (gnus-thread-ignore-subject nil)
  (gnus-thread-score-function 'max)
  (gnus-thread-sort-functions '((not gnus-thread-sort-by-number)))
  (gnus-ignored-from-addresses my-mail-address-regexp)
  :custom-face
  (gnus-summary-normal-ticked ((t (:foreground "pink4"))))
  :preface
  (defconst my-mail-address-regexp
    "\\(jwiegley\\|johnw?\\)@\\(\\(gmail\\|newartisans\\)\\.com\\|gnu\\.org\\|kadena\\.io\\)")

  (defface gnus-summary-expirable-face
    '((((class color) (background dark))
       (:foreground "grey50" :italic t :strike-through t))
      (((class color) (background light))
       (:foreground "grey55" :italic t :strike-through t)))
    "Face used to highlight articles marked as expirable."
    :group 'gnus-summary-visual)

  (defun my-gnus-summary-save-parts (&optional arg)
    (interactive "P")
    (let ((directory "~/Downloads"))
      (message "Saving all MIME parts to %s..." directory)
      (gnus-summary-save-parts ".*" directory arg)
      (message "Saving all MIME parts to %s...done" directory)))

  (defun my-gnus-trash-article (arg)
    (interactive "P")
    (if (string-match "\\(drafts\\|queue\\|delayed\\)" gnus-newsgroup-name)
        (gnus-summary-delete-article arg)
      (gnus-summary-move-article arg "Trash")))

  (defsubst dot-gnus-tos (time)
    "Convert TIME to a floating point number."
    (+ (* (car time) 65536.0)
       (cadr time)
       (/ (or (car (cdr (cdr time))) 0) 1000000.0)))

  (defun gnus-user-format-function-S (header)
    "Return how much time it's been since something was sent."
    (condition-case err
        (let ((date (mail-header-date header)))
          (if (> (length date) 0)
              (let*
                  ((then (dot-gnus-tos
                          (apply 'encode-time (parse-time-string date))))
                   (now (dot-gnus-tos (current-time)))
                   (diff (- now then))
                   (str
                    (cond
                     ((>= diff (* 86400.0 7.0 52.0))
                      (if (>= diff (* 86400.0 7.0 52.0 10.0))
                          (format "%3dY" (floor (/ diff (* 86400.0 7.0 52.0))))
                        (format "%3.1fY" (/ diff (* 86400.0 7.0 52.0)))))
                     ((>= diff (* 86400.0 30.0))
                      (if (>= diff (* 86400.0 30.0 10.0))
                          (format "%3dM" (floor (/ diff (* 86400.0 30.0))))
                        (format "%3.1fM" (/ diff (* 86400.0 30.0)))))
                     ((>= diff (* 86400.0 7.0))
                      (if (>= diff (* 86400.0 7.0 10.0))
                          (format "%3dw" (floor (/ diff (* 86400.0 7.0))))
                        (format "%3.1fw" (/ diff (* 86400.0 7.0)))))
                     ((>= diff 86400.0)
                      (if (>= diff (* 86400.0 10.0))
                          (format "%3dd" (floor (/ diff 86400.0)))
                        (format "%3.1fd" (/ diff 86400.0))))
                     ((>= diff 3600.0)
                      (if (>= diff (* 3600.0 10.0))
                          (format "%3dh" (floor (/ diff 3600.0)))
                        (format "%3.1fh" (/ diff 3600.0))))
                     ((>= diff 60.0)
                      (if (>= diff (* 60.0 10.0))
                          (format "%3dm" (floor (/ diff 60.0)))
                        (format "%3.1fm" (/ diff 60.0))))
                     (t
                      (format "%3ds" (floor diff)))))
                   (stripped
                    (replace-regexp-in-string "\\.0" "" str)))
                (concat (cond
                         ((= 2 (length stripped)) "  ")
                         ((= 3 (length stripped)) " ")
                         (t ""))
                        stripped))))
      (error "    ")))

  (eval-when-compile
    (defvar recipients)
    (defvar to-address))

  (defun gnus-user-format-function-X (header)
    (if (and recipients to-address (not (member to-address recipients)))
        (propertize "X" 'face 'font-lock-warning-face)
      " "))

  (defvar gnus-count-recipients-threshold 5
    "*Number of recipients to consider as large.")

  (defun gnus-user-format-function-r (header)
    "Given a Gnus message header, returns priority mark.
Here are the meanings:

The first column represent my relationship to the To: field.  It can be:

         I didn't appear (and the letter had one recipient)
   :     I didn't appear (and the letter had more than one recipient)
   <     I was the sole recipient
   +     I was among a few recipients
   ,*     There were many recipients

The second column represents the Cc: field:

         I wasn't mentioned, nor was anyone else
    .    I wasn't mentioned, but one other was
    :    I wasn't mentioned, but others were
    ^    I was the only Cc mentioned
    &    I was among a few Cc recipients
    %    I was among many Cc recipients
    X    This is a mailing list, but it wasn't on the recipients list

These can combine in some ways to tell you at a glance how visible the message
is:

   <.    Someone wrote to me and one other
    &    I was copied along with several other people
   ,*:    Mail to lots of people in both the To and Cc!"
    (ignore-errors
      (let* ((to (or (cdr (assoc 'To (mail-header-extra header))) ""))
             (cc (or (cdr (assoc 'Cc (mail-header-extra header))) ""))
             (to-len (length (split-string to "\\s-*,\\s-*")))
             (cc-len (length (split-string cc "\\s-*,\\s-*")))
             (msg-recipients (concat to (and to cc ", ") cc))
             (recipients
              (mapcar 'mail-strip-quoted-names
	              (message-tokenize-header msg-recipients)))
             (to-address
              (alist-get 'to-address
                         (gnus-parameters-get-parameter gnus-newsgroup-name)))
             (privatized
              (and recipients to-address (not (member to-address recipients)))))
        (cond ((string-match gnus-ignored-from-addresses to)
               (cond ((= to-len 1)
                      (cond (privatized "<X")
                            ((string= cc "") "< ")
                            ((= cc-len 1) "<.")
                            (t "<:")))
                     ((< to-len gnus-count-recipients-threshold)
                      (cond (privatized "+X")
                            ((string= cc "") "+ ")
                            ((= cc-len 1) "+.")
                            (t "+:")))
                     (t
                      (cond (privatized "*X")
                            ((string= cc "") "* ")
                            ((= cc-len 1) "*.")
                            (t "*:")))))

              ((string-match gnus-ignored-from-addresses cc)
               (cond (privatized " X")
                     ((= cc-len 1)
                      (cond ((= to-len 1) " ^")
                            (t ":^")))
                     ((< cc-len gnus-count-recipients-threshold)
                      (cond ((= to-len 1) " &")
                            (t ":&")))
                     (t
                      (cond ((= to-len 1) " %")
                            (t ":%")))))
              (t "  ")))))
  :config
  ;; Redefined, in order to ignore errors while running.
  (defun gnus-summary-mark-read-and-unread-as-read (&optional new-mark)
    "Intended to be used by `gnus-mark-article-hook'."
    (let ((mark (gnus-summary-article-mark)))
      (when (or (gnus-unread-mark-p mark)
	        (gnus-read-mark-p mark))
        (ignore-errors
          (gnus-summary-mark-article gnus-current-article
                                     (or new-mark gnus-read-mark))))))

  (push '((eq mark gnus-expirable-mark) . gnus-summary-expirable-face)
        gnus-summary-highlight))
#+end_src

**** rs-gnus-summary

#+begin_src emacs-lisp
(use-package rs-gnus-summary
  :after gnus-sum
  :preface
  (defvar gnus-balloon-face-0)
  (defvar gnus-balloon-face-1)
  :config
  (defalias 'gnus-user-format-function-size
    'rs-gnus-summary-line-message-size)

  (setq gnus-balloon-face-0 'rs-gnus-balloon-0)
  (setq gnus-balloon-face-1 'rs-gnus-balloon-1))
#+end_src

*** gnus-art

#+begin_src emacs-lisp
(use-package gnus-art
  :bind (:map gnus-article-mode-map
              ("F"   . gnus-article-wide-reply-with-original)
              ("M-q" . gnus-article-fill-long-lines))
  :custom
  (gnus-article-date-lapsed-new-header t)
  (gnus-article-update-date-headers nil)
  (gnus-default-article-saver 'gnus-summary-save-in-mail)
  (gnus-treat-date-lapsed 'head)
  (gnus-treat-hide-citation-maybe t)
  (gnus-treat-strip-cr t)
  (gnus-treat-strip-leading-blank-lines t)
  (gnus-treat-strip-multiple-blank-lines t)
  (gnus-treat-strip-trailing-blank-lines t)
  (gnus-treat-unsplit-urls t)
  (gnus-ignored-mime-types
   '("application/x-pkcs7-signature"
     "application/ms-tnef"
     "text/x-vcard")))
#+end_src

*** gnus-recent

#+begin_src emacs-lisp
(use-package gnus-recent
  :after gnus-group
  :bind (:map gnus-summary-mode-map
         ("l" . gnus-recent-goto-previous)
         :map gnus-group-mode-map
         ("C-c L" . gnus-recent-goto-previous)))
#+end_src

*** nnmail

#+begin_src emacs-lisp
(use-package nnmail
  :defer t
  :custom
  (nnmail-crosspost nil)
  (nnmail-expiry-wait 30)
  (nnmail-extra-headers '(To Cc Newsgroups))
  (nnmail-scan-directory-mail-source-once t))
#+end_src

*** message

#+begin_src emacs-lisp
(use-package message
  :bind ("C-x m" . compose-mail)        ; defined in `simple.el'
  :hook
  (message-header-setup . my-message-header-setup-hook)
  (message-setup . message-check-recipients)
  (message-mode . (lambda () (set-fill-column 78)))
  (message-mode . abbrev-mode)
  (message-mode . footnote-mode)
  (message-mode . jinx-mode)
  (message-mode . turn-on-auto-fill)
  (message-send . queue-message-if-not-connected)
  ;; (message-send . (lambda () (ignore-errors (jinx-correct 4))))
  (message-sent . gnus-score-followup-thread)
  (message-sent . my-gnus-score-followup)
  :custom
  (message-alternative-emails my-mail-address-regexp)
  (message-directory (expand-file-name "Mail/" gnus-home-directory))
  (message-dont-reply-to-names my-mail-address-regexp)
  (message-fill-column 78)
  (message-interactive t)
  (message-mail-alias-type nil)
  ;; (message-send-mail-function 'message-send-mail-with-sendmail)
  (message-send-mail-function 'message-smtpmail-send-it)
  (message-send-mail-partially-limit nil)
  (message-sendmail-envelope-from 'header)
  (message-sendmail-extra-arguments '("--read-envelope-from"))
  (message-sendmail-f-is-evil t)
  (message-signature-separator "^-- *$")
  (message-subscribed-address-functions '(gnus-find-subscribed-addresses))
  :custom-face
  (message-cited-text-1 ((((class color)) (:foreground "Blue"))))
  (message-header-cc ((((class color)) (:bold t :foreground "green2"))))
  (message-header-name ((((class color)) (:bold nil :foreground "Blue"))))
  (message-header-other ((((class color)) (:foreground "Firebrick"))))
  (message-header-xheader ((((class color)) (:foreground "Blue"))))
  (message-mml ((((class color)) (:foreground "DarkGreen"))))
  (message-separator ((((class color)) (:foreground "Tan"))))
  :preface
  (defun my-message-header-setup-hook ()
    (message-remove-header "From")
    (let ((gcc (message-field-value "Gcc")))
      (when (or (null gcc)
                (string-match "nnfolder\\+archive:" gcc))
        (message-remove-header "Bcc")
        (message-remove-header "Gcc")
        ;; (message-add-header (format "Bcc: %s" user-mail-address))
        ;; (message-add-header
        ;;  (format "Gcc: %s"
        ;;          (if (string-match "\\`list\\." (or gnus-newsgroup-name ""))
        ;;              "Sent"
        ;;            "INBOX")))
        )))

  (defvar gnus-agent-queue-mail)

  (defun queue-message-if-not-connected ()
    (set (make-local-variable 'gnus-agent-queue-mail)
         (if (quickping "smtp.gmail.com") t 'always)))
  :config
  (advice-add 'gnus-summary-resend-message-edit
              :after 'my-message-header-setup-hook)))
#+end_src

**** COMMENT sendmail

#+begin_src emacs-lisp
(use-package sendmail
  :nix nil
  :after message
  :custom
  (mail-envelope-from 'header)
  (mail-host-address "newartisans.com")
  (mail-self-blind t)
  (mail-setup-with-from nil)
  (mail-source-delete-incoming t)
  (mail-source-delete-old-incoming-confirm nil)
  (mail-source-report-new-mail-interval 15)
  (mail-sources '((file :path "/var/mail/johnw")))
  (mail-specify-envelope-from t)
  (send-mail-function 'sendmail-send-it)
  (sendmail-program "msmtp"))
#+end_src

**** smtpmail

#+begin_src emacs-lisp
(use-package smtpmail
  :after message
  :custom
  (smtpmail-smtp-server "smtp.fastmail.com")
  (smtpmail-smtp-user "johnw@newartisans.com")
  (smtpmail-servers-requiring-authorization "fastmail")
  (smtpmail-smtp-service 587)
  (smtpmail-stream-type 'starttls))
#+end_src

**** mm-decode

#+begin_src emacs-lisp
(use-package mm-decode
  :defer t
  :custom
  (mm-attachment-override-types
   '("text/x-vcard"
     "application/pkcs7-mime"
     "application/x-pkcs7-mime"
     "application/pkcs7-signature"
     "application/x-pkcs7-signature"
     "image/.*"))
  (mm-decrypt-option 'always)
  (mm-discouraged-alternatives
   '("application/msword"
     "text/richtext"))
  (mm-enable-external 'ask)
  (mm-inline-text-html-with-images t)
  (mm-text-html-renderer 'gnus-w3m)
  (mm-verify-option 'always)
  (mm-w3m-safe-url-regexp nil))
#+end_src

**** mml

#+begin_src emacs-lisp
(use-package mml
  :after message
  :custom
  (mml-secure-openpgp-sign-with-sender t)
  :preface
  (defvar mml-signing-attachment nil)

  (defun mml-sign-attached-file (file &optional _type _description _disposition)
    (unless (or mml-signing-attachment
                (null current-prefix-arg))
      (let ((signature
             (expand-file-name (concat (file-name-nondirectory file) ".sig")
                               temporary-file-directory))
            (mml-signing-attachment t))
        (message "Signing %s..." file)
        (if t
            (call-process epg-gpg-program file nil nil
                          "--output" signature "--detach-sign" file)
          (with-temp-file signature
            (setq buffer-file-coding-system 'raw-text-unix)
            (call-process epg-gpg-program file t nil "--detach-sign")))
        (message "Signing %s...done" file)
        (mml-attach-file signature))))
  :config
  (advice-add 'mml-attach-file :after #'mml-sign-attached-file))
#+end_src

**** supercite

#+begin_src emacs-lisp
(use-package supercite
  :after message
  :commands sc-cite-original
  :hook
  (mail-citation . sc-cite-original)
  (mail-citation . sc-remove-existing-signature)
  (sc-attribs-postselect . sc-remove-if-not-mailing-list)
  :custom
  (sc-citation-leader "")
  (sc-confirm-always-p nil)
  (sc-default-attribution "")
  (sc-default-cite-frame
   '((begin
      (progn
        (sc-fill-if-different)
        (setq sc-tmp-nested-regexp
              (sc-cite-regexp "")
              sc-tmp-nonnested-regexp
              (sc-cite-regexp)
              sc-tmp-dumb-regexp
              (concat "\\("
                      (sc-cite-regexp "")
                      "\\)"
                      (sc-cite-regexp sc-citation-nonnested-root-regexp)))))
     ("^[       ]*$"
      (if sc-cite-blank-lines-p
          (sc-cite-line)
        (sc-fill-if-different "")))
     ((and
       (looking-at "^-- ?$")
       (not
        (save-excursion
          (goto-char
           (match-end 0))
          (re-search-forward "^-- ?$" nil t))))
      (sc-fill-if-different ""))
     (sc-reference-tag-string
      (if
          (string= sc-reference-tag-string "")
          (list 'continue)
        nil))
     (sc-tmp-dumb-regexp
      (sc-cite-coerce-dumb-citer))
     (sc-tmp-nested-regexp
      (sc-add-citation-level))
     (sc-tmp-nonnested-regexp
      (sc-cite-coerce-cited-line))
     (sc-nested-citation-p
      (sc-add-citation-level))
     (t
      (sc-cite-line))
     (end
      (sc-fill-if-different ""))))
  (sc-preferred-attribution-list '("initials"))
  (sc-use-only-preference-p t)
  :preface
  (defun sc-remove-existing-signature ()
    (save-excursion
      (goto-char (region-beginning))
      (when (re-search-forward message-signature-separator (region-end) t)
        (delete-region (match-beginning 0) (region-end)))))

  (eval-when-compile
    (defvar attribution)
    (defvar citation))

  (defun sc-remove-if-not-mailing-list ()
    (unless (assoc "list-id" sc-mail-info)
      (setq attribution sc-default-attribution
            citation (concat sc-citation-delimiter
                             sc-citation-separator))))
  :config
  (defun sc-fill-if-different (&optional prefix)
    "Fill the region bounded by `sc-fill-begin' and point.
Only fill if optional PREFIX is different than
`sc-fill-line-prefix'.  If `sc-auto-fill-region-p' is nil, do not
fill region.  If PREFIX is not supplied, initialize fill
variables.  This is useful for a regi `begin' frame-entry."
    (if (not prefix)
        (setq sc-fill-line-prefix ""
              sc-fill-begin (line-beginning-position))
      (if (and sc-auto-fill-region-p
               (not (string= prefix sc-fill-line-prefix)))
          (let ((fill-prefix sc-fill-line-prefix))
            (unless (or (string= fill-prefix "")
                        (save-excursion
                          (goto-char sc-fill-begin)
                          (or (looking-at ">+  +")
                              (< (length
                                  (buffer-substring (point)
                                                    (line-end-position)))
                                 65))))
              (fill-region sc-fill-begin (line-beginning-position)))
            (setq sc-fill-line-prefix prefix
                  sc-fill-begin (line-beginning-position)))))
    nil))
#+end_src

**** gnus-alias

#+begin_src emacs-lisp
(use-package gnus-alias
  :after gnus
  :commands (gnus-alias-determine-identity
             gnus-alias-select-identity
             gnus-alias-use-identity)
  :bind (:map message-mode-map
              ("C-c C-f C-p" . gnus-alias-select-identity))
  :hook (message-setup . my-gnus-alias-determine-identity)
  :custom
  (gnus-alias-allow-forward-as-reply t)
  (gnus-alias-default-identity "Gmail")
  (gnus-alias-identity-alist
   '(("Gnu" "" "\"John Wiegley\" <johnw@gnu.org>" "" nil ""
      "John Wiegley                  GPG fingerprint = 4710 CF98 AF9B 327B B80F
http://newartisans.com                          60E1 46C4 BD1A 7AC1 4BA2")
     ("Kadena" "" "\"John Wiegley\" <john@kadena.io>" "" nil "" "")
     ("Gmail" "" "\"John Wiegley\" <jwiegley@gmail.com>" "" nil "" "")
     ("C2G" "" "\"John Wiegley\" <john.wiegley@coppertogold.org>" "" nil "" "")
     ("NewArtisans" "" "\"John Wiegley\" <johnw@newartisans.com>"
      "New Artisans LLC" nil ""
      "John Wiegley                  GPG fingerprint = 4710 CF98 AF9B 327B B80F
http://newartisans.com                          60E1 46C4 BD1A 7AC1 4BA2")))
  (gnus-alias-identity-rules
   '(("Kadena Mail"
      ("To" "kadena" current)
      "Kadena")
     ("Copper to Gold Mail"
      ("To" "copper\\(to\\|2\\)gold" current)
      "C2G")
     ("Ledger Mailing List"
      ("To" "ledger-cli@googlegroups\\.com" current)
      "Gmail")
     ("Emacs Mailing Lists"
      ("Cc" "\\(emacs\\|debbugs\\)" current)
      "Gnu")
     ("Emacs Mailing Lists"
      ("To" "\\(emacs\\|debbugs\\)" current)
      "Gnu")
     ("Emacs Newsgroups"
      ("Newsgroups" "emacs" current)
      "Gnu")
     ("Tarjuman"
      ("To" "\\(tarjuman\\)" current)
      "NewArtisans")
     ("Haskell Groups"
      ("Newsgroups"
       "\\(haskell\\|ghc\\|nix\\|coq\\|acl2\\|idris\\|agda\\|ssreflect\\|risc-v\\)"
       current)
      "NewArtisans")
     ("Haskell Mailing Lists"
      ("To"
       "\\(haskell\\|ghc\\|nix\\|coq\\|acl2\\|idris\\|agda\\|ssreflect\\|risc-v\\)"
       current)
      "NewArtisans")))
  (gnus-alias-override-user-mail-address t)
  (gnus-alias-unknown-identity-rule 'error)
  :preface
  (defsubst match-in-strings (re strs)
    (cl-some (apply-partially #'string-match re) strs))

  (defun my-gnus-alias-determine-identity ()
    (let ((addrs
           (ignore-errors
             (with-current-buffer (gnus-copy-article-buffer)
               (apply #'nconc
                      (mapcar
                       (lambda (x)
                         (split-string (or (gnus-fetch-field x) "") ","))
                       '("To" "Cc" "From" "Reply-To")))))))
      (cond
       ((or (match-in-strings "johnw@gnu\\.org" addrs)
            (match-in-strings "emacs-.*@gnu" addrs)
            (string-match "\\(gnu\\|emacs\\)" gnus-newsgroup-name))
        (gnus-alias-use-identity "Gnu"))
       ((or (match-in-strings "jwiegley@gmail\\.com" addrs)
            (match-in-strings "@baesystems\\.com" addrs)
            (string-match "\\(brass\\|safe\\|riscv\\)" gnus-newsgroup-name))
        (gnus-alias-use-identity "Gmail"))
       ((or (match-in-strings "john\\.wiegley@coppertogold\\.com" addrs)
            (string-match "\\(c2g\\)" gnus-newsgroup-name))
        (gnus-alias-use-identity "C2G"))
       ((or (match-in-strings "johnw@newartisans\\.com" addrs)
            (string-match "\\(haskell\\|coq\\|agda\\|idris\\|acl2\\)"
                          gnus-newsgroup-name))
        (gnus-alias-use-identity "NewArtisans"))
       ((match-in-strings "john\\.wiegley@baesystems\\.com" addrs)
        (gnus-alias-use-identity "BAE"))
       (t
        (gnus-alias-determine-identity))))))
#+end_src

**** gnus-harvest

#+begin_src emacs-lisp
(use-package gnus-harvest
  :load-path "lisp/gnus-harvest"
  :after gnus
  :custom
  (gnus-harvest-sender-alist
   '((".*@gnu\\.org\\'"   . "johnw@gnu.org")
     (".*@kadena\\.io\\'" . "john@kadena.io")
     (".*@coppertogold\\.org\\'" . "john.wiegley@coppertogold.org")))
  (gnus-harvest-query-limit 50000)
  ;; :hook
  ;; (message-setup . gnus-harvest-set-from)
  ;; (message-mode  . gnus-harvest-setup-completion-at-point)
  )

#+end_src

*** COMMENT gnus-sieve

#+begin_src emacs-lisp
(use-package gnus-sieve
  :nix nil
  :defer t
  :custom
  (gnus-sieve-file "~/.config/gnus/dovecot.sieve")
  (gnus-sieve-select-method "nnimap:imap.fastmail.com"))
#+end_src

*** gnus-agent

#+begin_src emacs-lisp
(use-package gnus-agent
  :defer t
  :custom
  (gnus-agent-cache t)
  (gnus-agent-expire-all t)
  (gnus-agent-expire-days 31)
  (gnus-agent-go-online t)
  (gnus-agent-mark-unread-after-downloaded nil)
  (gnus-agent-synchronize-flags t)
  :config
  (setq gnus-agent-predicate 'true))
#+end_src

*** gnus-demon

#+begin_src emacs-lisp
(use-package gnus-demon
  :after gnus
  :preface
  (defun save-gnus-newsrc ()
    (if (and (fboundp 'gnus-group-exit)
             (gnus-alive-p))
        (with-current-buffer (get-buffer "*Group*")
          (gnus-save-newsrc-file))))
  :config
  (gnus-demon-add-handler 'save-gnus-newsrc nil 1)
  ;; (gnus-demon-add-handler 'gnus-demon-close-connections nil 3)
  )
#+end_src

*** gnus-dired

#+begin_src emacs-lisp
(use-package gnus-dired
  :hook (dired-mode . gnus-dired-mode))
#+end_src

*** spam

#+begin_src emacs-lisp
(use-package spam
  :after gnus
  :custom
  (spam-mark-ham-unread-before-move-from-spam-group t))
#+end_src

** Org-mode

*** org

#+begin_src emacs-lisp
(use-package org
  ;; :load-path "lisp/org-mode/lisp"
  :demand t
  :commands org-resolve-clocks
  :bind* (("C-c S" . org-store-link)
          ("C-c l" . org-insert-link))
  :bind (:map
         org-mode-map
         ("C-c .")
         ("C-c #"       . org-priority)
         ("C-c ,"       . org-priority)
         ("C-c <"       . org-time-stamp)
         ("C-c <tab>"   . org-table-toggle-column-width)
         ("C-c SPC"     . org-table-blank-field)
         ("C-c ["       . org-time-stamp-inactive)
         ("C-c x"       . org-todo)
         ("C-c C-x $"   . visible-mode)
         ("C-c C-x C-x" . org-update-statistics-cookies)
         ("C-c C-x SPC" . org-reset-checkbox-state-subtree)
         ("C-c C-x Y"   . yank-media)
         ("C-c C-x r"   . org-clock-report)
         ("C-c C-x t"   . org-toggle-link-display)
         ("M-n"         . org-next-link)
         ("M-p"         . org-previous-link)
         ([return]        . (lambda () (interactive) (org-return t)))
         ([(control return)])
         ([(control meta return)] . org-insert-heading-after-current))
  :hook
  (org-mode . abbrev-mode)
  (org-mode . turn-on-auto-fill)
  ;; (org-mode . turn-on-flyspell)
  (org-mode . (lambda () (modify-syntax-entry ?’ "w")))
  (org-mode . (lambda () (set-input-method "Agda")))
  ;; (org-mode . (lambda ()
  ;;               (maybe-turn-on-whitespace)
  ;;               (setq whitespace-line-column 256
  ;;                     whitespace-style
  ;;                     '(face trailing space-before-tab empty))))
  (org-log-buffer-setup . abbrev-mode)
  (org-log-buffer-setup . turn-on-auto-fill)
  ;; (org-log-buffer-setup . turn-on-flyspell)
  (org-log-buffer-setup . (lambda () (setq-local fill-column (- 78 2))))
  :custom
  (org-M-RET-may-split-line '((headline) (default . t)))
  (org-adapt-indentation nil)
  (org-beamer-frame-default-options "fragile")
  ;; C-c C-r (org-reveal) will display where the point is if it is buried in
  ;; invisible text to allow editing again.
  (org-catch-invisible-edits 'error)
  (org-clock-clocked-in-display nil)
  (org-clock-idle-time 10)
  (org-clock-in-resume t)
  (org-clock-in-switch-to-state "DOING")
  (org-clock-into-drawer "LOGBOOK")

  (org-clock-mode-line-total 'current)
  (org-clock-out-remove-zero-time-clocks t)
  (org-clock-out-switch-to-state nil)
  (org-clock-persist t)
  (org-clock-persist-file (user-data "org-clock-save.el"))
  (org-clock-resolve-expert t)
  (org-clone-delete-id nil)
  (org-columns-default-format "%TODO %64ITEM(Task) %NEXT_REVIEW")
  (org-confirm-babel-evaluate nil)
  (org-cycle-global-at-bob t)
  (org-cycle-inline-images-display t)
  (org-deadline-warning-days 14)
  (org-default-notes-file org-constants-todo-path)
  (org-depend-tag-blocked nil)
  (org-directory org-constants-directory)
  (org-ditaa-jar-path
   (expand-file-name "lib/ditaa.jar" (getenv "PROFILE_DIR")))
  (org-drawers '("PROPERTIES" "CLOCK" "LOGBOOK" "OUTPUT"))
  (org-edit-src-content-indentation 0)
  ;; (org-ellipsis "…")
  (org-enforce-todo-dependencies t)
  (org-export-backends '(ascii html icalendar latex md))
  (org-export-latex-classes
   '(("article" "\\documentclass[11pt]{article}"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
     ("linalg" "\\documentclass{article}
\\usepackage{linalgjh}
[DEFAULT-PACKAGES]
[EXTRA]
[PACKAGES]"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
     ("report" "\\documentclass[11pt]{report}"
      ("\\part{%s}" . "\\part*{%s}")
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
     ("book" "\\documentclass[11pt]{book}"
      ("\\part{%s}" . "\\part*{%s}")
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
     ("beamer" "\\documentclass{beamer}" org-beamer-sectioning)))
  (org-export-use-babel nil)
  (org-extend-today-until 4)
  (org-use-effective-time t)
  (org-fast-tag-selection-single-key 'expert)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-fontify-whole-heading-line t)
  (org-footnote-define-inline t)
  (org-footnote-section nil)
  (org-fold-catch-invisible-edits 'smart)
  (org-global-properties
   '(("Effort_ALL" . "0:05 0:15 0:30 1:00 2:00 3:00 4:00 6:00 8:00")))
  (org-hide-emphasis-markers t)
  (org-hide-leading-stars t)
  (org-highlight-sparse-tree-matches nil)
  (org-icalendar-combined-agenda-file (org-file "org.ics"))
  (org-icalendar-timezone "America/Los_Angeles")
  (org-image-actual-width 800)
  (org-imenu-depth 4)
  (org-insert-heading-respect-content t)
  (org-irc-link-to-logs t t)
  (org-latex-default-packages-alist
   '(("T1" "fontenc" t)
     ("" "fixltx2e" nil)
     ("" "graphicx" t)
     ("" "longtable" nil)
     ("" "float" nil)
     ("" "wrapfig" nil)
     ("" "rotating" nil)
     ("normalem" "ulem" t)
     ("" "amsmath" t)
     ("" "textcomp" t)
     ("" "marvosym" t)
     ("" "wasysym" t)
     ("" "amssymb" t)
     ("" "hyperref" nil)
     "\\tolerance=1000"))
  (org-latex-minted-options
   '(("fontsize" "\\footnotesize")
     ("linenos" "true")
     ("xleftmargin" "0em")))
  (org-latex-pdf-process
   '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
     "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-latex-src-block-backend 'minted)
  (org-link-elisp-confirm-function nil)
  (org-link-shell-confirm-function nil)
  (org-list-allow-alphabetical t)
  (org-log-state-notes-insert-after-drawers t)
  (org-mime-preserve-breaks nil)
  (org-plantuml-jar-path
   (expand-file-name "lib/plantuml.jar" (getenv "PROFILE_DIR")))
  (org-pretty-entities t)
  (org-priority-faces
   '((65 :foreground "White" :weight bold)
     (66 . "White")
     (67 :foreground "grey90" :slant italic)))
  (org-read-date-force-compatible-dates nil)
  (org-outline-path-complete-in-steps nil)
  (org-return-follows-link nil)
  (org-reverse-note-order t)
  (org-special-ctrl-a/e t)
  (org-special-ctrl-k t)
  (org-src-fontify-natively nil)
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-startup-folded 'show3levels)
  (org-startup-with-inline-images t)
  (org-subject-transforms
   '(("\\`\\(Re\\|Fwd\\): " . "")
     ("\\`{ledger} " . "")
     ("([Ww]as: .+)\\'" . "")
     ("\\`\\[[a-z-]+\\] " . "")
     ("\\`bug#\\([0-9]+\\):" . "[[x-debbugs-gnu:\\1][#\\1]]")))
  (org-tag-persistent-alist
   '(("Call" . 99)
     ("Errand" . 101)
     ("Home" . 104)))
  (org-tags-column -97)
  (org-time-clocksum-use-fractional t)
  (org-todo-keywords
   '((sequence "DRAFT(a)" "TODO(t@/!)" "DOING(s!/!)"
               "WAIT(w@/!)" "DEFER(r!/!)"
               "TASK(g@/!)" "HABIT(h@/!)"
               "|" "DONE(d@/!)" "CANCELED(x@/!)" "PASS(p@/!)")
     (sequence "|" "SCRAP(A)" "NOTE(n)" "LINK(l)")))
  (org-todo-keyword-faces
   `(
     ("DRAFT"    :foreground "grey80"                 :weight bold)
     ("SCRAP"    :foreground "grey20"                 :weight bold)
     ("TODO"     :foreground ,palette-slate-blue      :weight bold)
     ("DOING"    :foreground ,palette-yellow          :weight bold)
     ("WAIT"     :foreground ,palette-red             :weight bold)
     ("TASK"     :foreground ,palette-blue            :weight bold)
     ("DEFER"    :foreground ,palette-slate-blue-dark :weight bold)
     ("DONE"     :foreground ,palette-green-dark      :weight bold)
     ("CANCELED" :foreground "grey50"                 :weight bold :strike-through t)
     ("PASS"     :foreground "grey50"                 :weight bold :strike-through t)
     ("HABIT"    :foreground ,palette-orange          :weight bold)
     ("LINK"     :foreground ,palette-orange-dark     :weight bold)
     ("NOTE"     :foreground ,palette-red-dark        :weight bold)
     ))
  (org-tag-faces
   `(("Call"     :foreground "grey50")
     ("Errand"   :foreground "grey50")
     ("Home"     :foreground "grey50")
     ("FILE"     :foreground ,palette-purple          :weight bold)
     ("LINK"     :foreground ,palette-purple          :weight bold)))
  (org-todo-repeat-to-state "TODO")
  (org-treat-S-cursor-todo-selection-as-state-change nil)
  (org-use-fast-todo-selection 'expert)
  (org-use-speed-commands
   (lambda () (and (looking-at org-outline-regexp) (looking-back "^\**"))))
  (org-use-sub-superscripts nil)
  (org-use-tag-inheritance
   '("Noon" "Day" "Eve" "Night" "Home" "Call" "Errand"
     "assembly"
     "kadena"))
  (org-use-property-inheritance '("OVERLAY"))
  (org-yank-adjusted-subtrees t)
  :custom-face
  (org-done ((t (:foreground "ForestGreen" :weight bold))))
  (org-headline-done ((t (:foreground "grey75" :slant italic))))
  (org-level-4 ((t (:foreground "green"))))
  (org-scheduled ((((class color) (min-colors 88) (background light)) nil)))
  (org-upcoming-deadline
   ((((class color) (min-colors 88) (background light)) (:foreground "Brown"))))
  (org-document-title
   ((t (:foreground "pale turquoise" :weight bold :height 1.5 :family "DejaVu Sans"))))
  (org-block ((t (:inherit shadow :extend t :background "#090011"))))
  (org-block-begin-line ((t (:inherit org-meta-line :extend t :background "grey10"))))
  :defines
  (org-archive-save-context-info)
  :preface
  (defsubst org-file (path)
    (expand-file-name path org-directory))

  ;; Used by Org-mode and Org-roam templates
  (defun generate-uuid ()
    (with-temp-buffer
      (uuidgen nil)
      (upcase (buffer-string))))

  ;; Used by Org-mode and Org-roam templates
  (defun created-stamp (&optional for-scheduled inactive)
    (format-time-string
     (org-time-stamp-format (not for-scheduled)
                            (or inactive (not for-scheduled)))))
  :config
  (setq org-archive-save-context-info '(time file olpath olid category itags))

  (eval-when-compile (require 'info))
  (add-to-list 'Info-additional-directory-list
               (expand-file-name "~/.emacs.d/lisp/org-mode/doc"))

  (org-link-set-parameters "copy"
                           :follow #'kill-new
                           :export (lambda (_ desc &rest _) desc))

  (advice-add 'org-paste-subtree :before
              (lambda (&rest _) (delete-blank-lines)))

  (font-lock-add-keywords
   'org-mode
   '(("^ *\\(-\\) "
      (0 (ignore (compose-region (match-beginning 1) (match-end 1) "•")))))))
#+end_src

*** org-agenda

#+begin_src emacs-lisp
(use-package org-agenda
  :nix nil
  :commands org-agenda-list
  :bind* ("C-c a" . org-agenda)
  :bind (:map
         org-agenda-mode-map
         ("SPC" . my/org-agenda-show-and-scroll-up)
         ;; (" "   . org-agenda-tree-to-indirect-buffer)
         (">"   . org-agenda-filter-by-top-headline)
         ("C-n" . next-line)
         ("C-p" . previous-line)
         ("F"   . org-agenda-follow-mode)
         ("M-m")
         ("M-n" . org-agenda-later)
         ("M-p" . org-agenda-earlier)
         ("b"   . org-agenda-date-earlier)
         ("f"   . org-agenda-date-later)
         ("q"   . bury-buffer)
         ("x"   . org-agenda-todo)
         ("X"   . org-agenda-todo-yesterday)
         ("w"   . org-agenda-refile)
         ("z"   . pop-window-configuration)
         :prefix-map
         my/org-review-map
         :prefix "t"
         ("N"   . my/org-toggle-time-noon)
         ("d"   . my/org-toggle-time-day)
         ("e"   . my/org-toggle-time-eve)
         ("n"   . my/org-toggle-time-night))
  :custom
  (org-agenda-auto-exclude-function 'my/org-auto-exclude-function)
  (org-agenda-cmp-user-defined 'my/org-compare-todo-age)
  (org-agenda-compact-blocks t)
  (org-agenda-deadline-leaders '("!D!:" "D%02d:" "D-%02d:"))
  (org-agenda-default-appointment-duration 60)
  (org-agenda-files org-constants-agenda-base-files)
  (org-agenda-fontify-priorities t)
  (org-agenda-include-diary nil)
  (org-agenda-hide-tags-regexp
   "\\`\\(Noon\\|Day\\|Eve\\|Night\\|assembly\\|kadena\\)\\'")
  (org-agenda-inhibit-startup t)
  (org-agenda-log-mode-items '(closed clock state))
  (org-agenda-ndays 1)
  (org-agenda-persistent-filter t)
  (org-agenda-prefix-format
   '((agenda   . "%-10c%?-12t% s")
     (todo     . "%-10c%5(my/org-todo-age) ")
     (tags     . "%-10c")))
  (org-agenda-scheduled-leaders '("" "S%d: "))
  (org-agenda-scheduled-relative-text "S%d: ")
  (org-agenda-scheduled-text "")
  (org-agenda-show-all-dates t)
  (org-agenda-show-outline-path t)
  (org-agenda-skip-deadline-if-done t)
  (org-agenda-skip-scheduled-if-deadline-is-shown t)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-timestamp-if-done t)
  (org-agenda-skip-unavailable-files t)
  (org-agenda-sorting-strategy
   '((agenda habit-down time-up todo-state-up priority-down)
     (todo priority-down category-keep)
     (tags priority-down category-keep)
     (search category-keep)))
  (org-agenda-span 'day)
  (org-agenda-start-on-weekday nil)
  (org-agenda-start-with-log-mode nil)
  (org-agenda-tags-column -100)
  (org-agenda-tags-todo-honor-ignore-options t)
  (org-agenda-text-search-extra-files '(agenda-archives))
  ;; (org-agenda-todo-ignore-scheduled 'future)
  (org-agenda-todo-ignore-time-comparison-use-seconds t)
  (org-agenda-skip-deadline-prewarning-if-scheduled t)
  (org-agenda-use-time-grid nil)
  (org-agenda-window-frame-fractions '(0.5 . 0.75))
  :custom-face
  (org-agenda-clocking ((t (:background "red2"))))
  (org-agenda-done ((t (:foreground "DarkGreen"))))
  :preface
  (defun my/org-todo-age-time (&optional pos)
    (let ((stamp (org-entry-get (or pos (point)) "CREATED" t)))
      (when stamp
        (time-subtract (current-time)
                       (org-time-string-to-time
                        (org-entry-get (or pos (point)) "CREATED" t))))))

  (defun my/org-todo-age (&optional pos)
    (let ((days (time-to-number-of-days (my/org-todo-age-time pos))))
      (cond
       ((< days 1)   "today")
       ((< days 7)   (format "%dd" days))
       ((< days 30)  (format "%.1fw" (/ days 7.0)))
       ((< days 365) (format "%.1fM" (/ days 30.0)))
       (t            (format "%.1fY" (/ days 365.0))))))

  (defun my/org-compare-todo-age (a b)
    (let ((time-a (my/org-todo-age-time (get-text-property 0 'org-hd-marker a)))
          (time-b (my/org-todo-age-time (get-text-property 0 'org-hd-marker b))))
      (if (time-less-p time-a time-b)
          -1
        (if (equal time-a time-b)
            0
          1))))

  (defun my/org-auto-exclude-function (tag)
    (let ((hour (nth 2 (decode-time))))
      (and (cond
            ((string= tag "Call")   (< hour 9))
            ((string= tag "Errand") (< hour 12))
            ((string= tag "Noon")   (< hour 12))
            ((string= tag "Day")    (< hour 15))
            ((string= tag "Nasim")  (< hour 17))
            ((string= tag "Eve")    (< hour 18))
            ((string= tag "Night")  (< hour 21))
            ((string= tag "Home")
             (with-temp-buffer
               (call-process "ifconfig" nil t nil "en0" "inet")
               (call-process "ifconfig" nil t nil "en1" "inet")
               (goto-char (point-min))
               (not (search-forward "inet 192.168.50." nil t))))
            ((string= tag "Net")
             (not (quickping "imap.fastmail.com"))))
           (concat "-" tag))))

  (defun my/org-toggle-time-noon ()
    (interactive)
    (org-agenda-with-point-at-orig-entry nil (org-toggle-tag "Noon")))
  (defun my/org-toggle-time-day ()
    (interactive)
    (org-agenda-with-point-at-orig-entry nil (org-toggle-tag "Day")))
  (defun my/org-toggle-time-eve ()
    (interactive)
    (org-agenda-with-point-at-orig-entry nil (org-toggle-tag "Eve")))
  (defun my/org-toggle-time-night ()
    (interactive)
    (org-agenda-with-point-at-orig-entry nil (org-toggle-tag "Night")))

  ;; I like the behavior of `arg' to be reversed in this function.
  (defun my/org-agenda-show-and-scroll-up (&optional arg)
    (interactive "P")
    (org-agenda-show-and-scroll-up (null arg)))
  :init
  (unless alternate-emacs
    (add-hook 'emacs-startup-hook #'org-resolve-clocks t))
  :config
  (timeout-debounce! 'org-agenda-do-context-action 0.3))
#+end_src

**** org-agenda-overlay

#+begin_src emacs-lisp
(use-package org-agenda-overlay
  :nix nil
  :load-path "lisp/org-agenda-overlay"
  :after org-agenda
  :demand t
  :hook
  (org-agenda-finalize . org-agenda-overlay-add)
  :custom
  (org-agenda-overlay-by-filetag
   `(("c2g"           face (:background ,palette-orange-darker  :foreground "#eeeeee"))
     ("bahai"         face (:background ,palette-green-darker   :foreground "#eeeeee"))
     ("family"        face (:background ,palette-purple-darker  :foreground "#eeeeee"))
     ("finances"      face (:background ,palette-red-dark       :foreground "#eeeeee"))
     ("home"          face (:background ,palette-yellow-darker  :foreground "#eeeeee"))
     ("assembly"      face (:background ,palette-teal-darker    :foreground "#eeeeee"))
     ("tech"          face (:background ,palette-indigo-darker  :foreground "#eeeeee"))
     ("quantumtrades" face (:background ,palette-fuschia-darker :foreground "#eeeeee"))
     ("kadena"        face (:background ,palette-fuschia-darker :foreground "#eeeeee"))
     ))
  (org-agenda-overlay-by-olp
   `(;; Headings in todo.org
     (("Inbox")       face (:background ,palette-fuschia        :foreground "#ffffff"))
     (("Mobile")      face (:background ,palette-orange         :foreground "#ffffff"))
     ;; red
     (("Finances")    face (:background ,palette-red-dark       :foreground "#eeeeee"))
     ;; orange
     ;; yellow
     (("Health")      face (:background ,palette-yellow-darker  :foreground "#eeeeee"))
     (("Auto")        face (:background ,palette-yellow-darker  :foreground "#eeeeee"))
     (("Home")        face (:background ,palette-yellow-darker  :foreground "#eeeeee"))
     (("Nasim")       face (:background ,palette-yellow-darker  :foreground "#eeeeee"))
     ;; green
     (("Bahá’í")      face (:background ,palette-green-darker   :foreground "#eeeeee"))
     ;; cyan
     ;; slate blue
     (("Friends")     face (:background ,palette-cyan-darker    :foreground "#eeeeee"))
     ;; blue
     (("Blog")        face (:background ,palette-blue-dark      :foreground "#eeeeee"))
     (("Personal")    face (:background ,palette-blue-dark      :foreground "#eeeeee"))
     ;; indigo
     (("Computer")    face (:background ,palette-indigo-darker  :foreground "#eeeeee"))
     ;; purple
     (("Family")      face (:background ,palette-purple-darker  :foreground "#eeeeee")))))
#+end_src

**** org-super-agenda

#+begin_src emacs-lisp
(use-package org-super-agenda
  :after org
  :custom
  (org-super-agenda-header-separator "————————————————————————————————————————————————————————————————————————————————————————————————————\n")
  ;; (org-super-agenda-header-separator "")
  (org-super-agenda-hide-empty-groups t)
  :config
  (org-super-agenda-mode))
#+end_src

*** org-ql

#+begin_src emacs-lisp
(use-package org-ql
  :after org
  :demand t
  :commands org-ql-search
  :bind
  (:map
   org-mode-map
   ("C-c C-x o" . org-ql-open-link)
   :map
   my-ctrl-c-n-map
   ("/" . org-ql-sparse-tree)
   ("a" . org-ql-view)
   ("q" . org-ql-find-in-agenda)
   ("w" . org-ql-refile-path)
   ("W" . org-ql-refile))
  :preface
  (defun org-ql-refile-path ()
    (interactive)
    (let ((org-ql-default-predicate 'outline-path))
      (call-interactively #'org-ql-refile)))
  :config
  (eval-when-compile
    (require 'vertico-multiform))
  (add-all-to-list 'vertico-multiform-commands
                   '(org-ql-find)
                   '(org-refile)))

(use-package org-ql-ext
  :after org-ql
  :demand t
  :bind
  ("M-g O" . org-ql-ext-find-refile-targets)
  :config
  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-commands
               '(org-ql-ext-find-refile-targets))

  (add-hook 'org-mode-hook 'org-ql-ext-completion-hook))
#+end_src

*** org-ext

#+begin_src emacs-lisp
(use-package org-ext
  :after (org)
  :demand t
  :bind* ("M-C" . org-ext-jump-to-agenda)
  :commands (org-ext-jump-to-agenda)
  :bind (:map
         org-mode-map
         ("C-c M-w"       . org-ext-id-copy)
         ("C-c C-M-o"     . org-ext-open-all-links-in-subtree)
         ("C-c C-x B"     . org-ext-set-blocker-from-clipboard-id)
         ("C-c C-x D"     . org-ext-update-date-field)
         ("C-c C-x M"     . org-ext-set-message-link)
         ("C-c C-x O"     . org-ext-open-map-link)
         ("C-c C-x U"     . org-ext-set-url-from-clipboard)
         ("C-c C-x m"     . org-ext-insert-message-link)
         ("C-c C-x u"     . org-ext-todoize)
         ("C-c C-x C-,"   . org-ext-insert-structure-template-and-yank)
         ("C-c C-x C-M-y" . org-ext-yank-link)
         ("C-c C-x C-t"   . org-ext-switch-todo-link)
         ("C-c C-x C-u"   . org-ext-todoize-region)
         ("s-n"           . org-ext-edit-link-name)
         :map
         org-agenda-mode-map
         ("g" . org-ext-agenda-redo)
         :map
         my-ctrl-c-n-map
         ("C" . org-ext-set-category))
  :hook
  (after-save . org-ext-update-team-after-save)
  (org-mode . org-ext-setup-insert-code-block)
  (org-log-buffer-setup . org-ext-setup-insert-code-block)
  ;; (org-agenda-finalize . org-ext-report-items-to-be-reviewed)
  ;; :init
  ;; (unless alternate-emacs
  ;;   (add-hook 'emacs-startup-hook #'org-ext-jump-to-agenda t)
  ;;   (run-with-idle-timer 300 t #'org-ext-jump-to-agenda))
  (org-agenda-mode . org-ext-fit-agenda-window)
  :config
  (org-link-set-parameters "tag" :follow #'org-ext-follow-tag-link)

  (add-hook 'gnus-summary-mode-hook
            (lambda () (org-ext-gnus-drop-link-parameter "gnus")))

  ;; (use-package org-mairix
  ;;   :defer t
  ;;   :config
  ;;   (org-ext-gnus-drop-link-parameter "mairix"))

  (org-ext-update-team))
#+end_src

*** org-config

#+begin_src emacs-lisp
(use-package org-config
  :after org
  :demand t
  :bind
  (:map
   my-ctrl-c-n-map
   ("H"   . org-config-hide)
   ("s"   . org-config-find)
   ("C-s" . org-config-find-any))
  :hook
  (after-init . (lambda () (org-agenda nil "a"))))
#+end_src

*** COMMENT appt

#+begin_src emacs-lisp
(use-package appt
  :nix nil
  :after org
  :hook
  ;; when agenda is opened and showed, refresh appt
  (org-agenda-after-show . (lambda () (org-agenda-to-appt t)))

  ;; when any org file changed, refresh appt
  ;; (after-save . (lambda () (when (eq major-mode 'org-mode)
  ;;                       (org-agenda-to-appt t))))
  :custom
  ;; start warning 60 minutes before the appointment
  (appt-message-warning-time 10)
  ;; warn me every 5 minutes
  (appt-display-interval 5)
  (appt-disp-window-function
   (lambda (remaining new-time msg)
     (alert msg
            :title (format "In %s minutes" remaining)
            :severity 'high)))
  :config
  (appt-activate t))
#+end_src

*** COMMENT org-alert

#+begin_src emacs-lisp
(use-package org-alert
  :after org
  :custom
  (org-alert-notify-after-event-cutoff 60)
  (org-alert-time-match-string
   "\\(?:SCHEDULED\\|DEADLINE\\):\\s-+<[^>]+?\\([0-9]\\{2\\}:[0-9]\\{2\\}\\).*>")
  :config
  (org-alert-enable))
#+end_src

*** org-appear

[[https://github.com/awth13/org-appear][org-appears]] makes invisible parts of Org elements appear visible.

[[https://orgmode.org/][Org mode]] provides a way to toggle visibility of hidden elements such as
emphasis markers, links, etc. by customising specific variables, e.g.,
=org-hide-emphasis-markers=. However, it is currently not possible to do this
interactively and on an element-by-element basis. This package, inspired by
[[https://github.com/io12/org-fragtog][org-fragtog]], enables automatic visibility toggling depending on cursor
position. Hidden element parts appear when the cursor enters an element and
disappear when it leaves.

#+begin_src emacs-lisp
(use-package org-appear
  :after org
  :hook (org-mode . org-appear-mode))
#+end_src

*** org-annotate

[[https://github.com/girzel/org-annotate/blob/master/org-annotate.el][org-annotate]] provides a new link type for Org that allows you to create
annotations on arbitrary chunks of text. The link prefix is “note:”.

Add notes with =org-annotate-add-note=. Following the link will display the text
of the note in a pop-up buffer. The buffer is in special-mode, hit “q” to
dismiss it.

Call =org-annotate-display-notes= to see all notes in a buffer. Press “?” in
this buffer to see more options.

Customize how notes are exported in different backends by setting the
=org-annotate-[backend]-export-function= options, where “backend” is a valid
backend identifier. Each option should point to a function that accepts two
arguments, the path and description strings of the link, and returns a single
formatted string for insertion in the exported text. Some default functions
are provided for HTML, LaTeX and ODT, see the =org-annotate-export-*= functions.

#+begin_src emacs-lisp
(use-package org-annotate
  :after org
  :bind (:map org-mode-map
              ("C-c C-x n a"  . org-annotate-add-note)
              ("C-c C-x n l"  . org-annotate-display-notes)))
#+end_src

*** org-auto-expand

#+begin_src emacs-lisp
(use-package org-auto-expand
  :after org
  :config
  (org-auto-expand-mode))
#+end_src

*** org-capture

#+begin_src emacs-lisp
(use-package org-capture
  :after org
  :demand t
  :hook
  ;; Ensure the ID and CREATED properties are always set for new entries.
  (org-capture-before-finalize . my/org-basic-properties)
  (org-capture-prepare-finalize . my/org-cleanup-whitespace)
  :preface
  (defun my/org-basic-properties (&optional arg)
    (interactive "P")
    (save-excursion
      (org-id-get-create arg)
      (unless (org-entry-get (point) "CREATED")
        (org-entry-put (point) "CREATED"
                       (format-time-string (org-time-stamp-format t t))))
      ;; If possible, add location info. We know the location at home always.
      (cl-destructuring-bind (lat lon)
          (if (quickping "192.168.2.2")
              '("38.569498" "-121.388618")
            (let ((strs
                   (split-string
                    (string-trim
                     (shell-command-to-string "CoreLocationCLI")))))
              (if (= 2 (length strs))
                  strs
                (message "Failed to obtain Lat/Lon!")
                '("" ""))))
        (unless (string= lat "")
          (org-entry-put (point) "LOCATION" (concat lat "," lon))))))

  (defun my/org-cleanup-whitespace (&optional arg)
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (search-forward " " nil t)
        (replace-match  " "))
      (whitespace-cleanup)
      (goto-char (point-max))
      (delete-blank-lines)
      (if (looking-at "^$")
          (delete-char -1)))))
#+end_src

**** org-smart-capture

This wrapper around =org-capture= will also capture Gnus messages as tasks, with
context.

#+begin_src emacs-lisp
(use-package org-smart-capture
  :after (org)
  :bind* ("M-m" . org-smart-capture)
  :custom
  (org-smart-capture-use-lastname t))
#+end_src

**** org-drafts

#+begin_src emacs-lisp
(use-package org-drafts
  :load-path "lisp/org-drafts"
  :after (org)
  :bind* (("M-M" . (lambda () (interactive) (org-capture nil "d")))
          ("H-m" . (lambda () (interactive) (org-capture nil "d"))))
  :config
  (org-drafts-install))
#+end_src

*** org-checklist

#+begin_src emacs-lisp
(use-package org-checklist
  :after org)
#+end_src

*** org-habit

#+begin_src emacs-lisp
(use-package org-habit
  :after org-agenda
  :custom
  (org-habit-graph-column 32)
  (org-habit-preceding-days 53)
  (org-habit-today-glyph 45))
#+end_src

*** org-anki

#+begin_src emacs-lisp
(use-package org-anki
  :after org
  :commands org-anki-sync-all)
#+end_src

*** org-attach

#+begin_src emacs-lisp
(use-package org-attach
  :after (org dired)
  :bind (:map dired-mode-map
              ("C-c C-x a" . org-attach-dired-to-subtree))
  :custom
  (org-attach-file-list-property "FILE")
  (org-attach-auto-tag "FILE")
  (org-attach-id-dir (org-file "data"))
  (org-attach-method 'mv)
  (org-attach-store-link-p 'attached)
  :init
  (defun my/org-attach-visit-headline-from-dired ()
    "Go to the headline corresponding to this org-attach directory."
    (interactive)
    (let* ((id-parts (last (split-string default-directory "/" t) 2))
           (id (apply #'concat id-parts)))
      (let ((m (org-id-find id 'marker)))
        (unless m (user-error "Cannot find entry with ID \"%s\"" id))
        (pop-to-buffer (marker-buffer m))
        (goto-char m)
        (move-marker m nil)))))
#+end_src

**** org-attach-git

#+begin_src emacs-lisp
(use-package org-attach-git
  :after org
  :custom
  (org-attach-git-annex-cutoff 256))
#+end_src

*** org-babel

#+begin_src emacs-lisp
(use-package ob
  :after (org ob-emamux)
  :demand t
  :config
  ;; load more languages for org-babel
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python     . t)
     (emacs-lisp . t)
     (haskell    . t)
     (calc       . t)
     (shell      . t)
     (latex      . t)
     (ditaa      . t)
     (plantuml   . t)
     (C          . t)
     (sql        . t)
     (dot        . t)
     (makefile   . t)
     (emamux     . t)
     ;; (jupyter    . t)
     ))                  ; must be last

  (remove-hook 'kill-emacs-hook 'org-babel-remove-temporary-directory)

  (defun org-babel-sh-strip-weird-long-prompt (string)
    "Remove prompt cruft from a string of shell output."
    (while (string-match "^.+?;C;" string)
      (setq string (substring string (match-end 0))))
    string)

  (advice-add 'org-babel-edit-prep:emacs-lisp :after
              (lambda (&rest _) (run-hooks 'emacs-lisp-mode-hook)))

  (setq org-babel-default-header-args:sh    '((:results . "output replace"))
        org-babel-default-header-args:bash  '((:results . "output replace"))
        org-babel-default-header-args:shell '((:results . "output replace"))
        ;; org-babel-default-header-args:jupyter-python
        ;; '((:async . "yes")
        ;;   (:session . "py")
        ;;   (:kernel . "sagemath"))
        )

  (use-package ob-plantuml)
  (use-package ob-ditaa)

  (setq org-confirm-babel-evaluate nil
        org-plantuml-jar-path
        (expand-file-name "lib/plantuml.jar" (getenv "PROFILE_DIR"))
        org-ditaa-jar-path
        (expand-file-name "lib/ditaa.jar" (getenv "PROFILE_DIR")))

  (add-to-list 'org-src-lang-modes (quote ("plantuml" . plantuml))))
#+end_src

**** ob-emamux

#+begin_src emacs-lisp
(use-package ob-emamux
  :after org
  :demand t
  :commands (org-babel-execute:emamux))
#+end_src

**** ob-restclient

#+begin_src emacs-lisp
(use-package ob-restclient
  :after org)
#+end_src

**** COMMENT ob-verb

#+begin_src emacs-lisp
(use-package ob-verb
  :nix verb
  :after org)
#+end_src

*** org-bookmark-heading

#+begin_src emacs-lisp
(use-package org-bookmark-heading
  :after org)
#+end_src

*** org-contacts

#+begin_src emacs-lisp
(use-package org-contacts
  :after org
  :commands (org-contacts)
  :bind (("M-B" . org-contacts)
         :map org-mode-map
         ("C-x M" . org-contacts-view-send-email))
  :custom
  (org-contacts-files (list (org-file "contacts.org")))
  :config
  (add-hook 'message-mode-hook
            (lambda ()
              (remove-hook 'completion-at-point-functions
                           #'message-completion-function t)))

  (remove-hook 'org-mode-hook #'org-contacts-org-complete-setup)

  (defun org-contacts--candidate (headline)
    "Return candidate string from Org HEADLINE epom element node."
    (let* ((org-contacts-icon-size 32)
           (contact-name (org-element-property :raw-value headline))
           (tags (org-element-property :tags headline))
           (begin (org-element-property :begin headline))
           (properties (org-entry-properties begin 'standard))
           ;; extra headline properties
           (avatar-image-path
            (when-let* ((avatar-value (org-entry-get begin "AVATAR"))
                        (avatar-link-path
                         (cond
                          ;; contact_dir/avatar.png
                          ((string-match org-link-plain-re avatar-value)
                           (when (string-equal (match-string 1 avatar-value) "file")
                             (match-string 2 avatar-value)))
                          ;; contact-name.jpg
                          ((string-match
                            (concat (regexp-opt image-file-name-extensions)
                                    (rx line-end)) avatar-value)
                           (match-string 0 avatar-value))))
                        (avatar-absolute-path
                         (file-name-concat
                          (or org-contacts-directory
                              (expand-file-name
                               (file-name-directory (car org-contacts-files))))
                          avatar-link-path))
                        ( (org-file-image-p avatar-absolute-path))
                        ( (file-exists-p avatar-absolute-path)))
              avatar-absolute-path))
           (info (concat "\n"
                         (concat org-contacts-ahead-space-padding "   ")
                         (let ((org-property-separators
                                (list (cons org-contacts-nickname-property "[,\ ]"))))
                           (org-entry-get begin org-contacts-nickname-property))
                         (let ((org-property-separators
                                (list (cons org-contacts-email-property "[,\ ]"))))
                           (org-entry-get begin org-contacts-email-property))
                         "\n"))
           (middle-line-length (let ((length (- (abs org-tags-column)
                                                (length (string-join tags ":"))
                                                (length contact-name))))
                                 (if (> length 0) length 0))))
      ;; detect whether headline is an org-contacts entry?
      (when (seq-intersection org-contacts-identity-properties-list
                              (mapcar 'car properties))
        (propertize
         (concat
          (if avatar-image-path
              (propertize org-contacts-ahead-space-padding
                          'display
                          (create-image avatar-image-path nil nil
                                        :ascent 30 ; set image baseline to
                                        ; align image top with
                                        ; candidate line.
                                        :width org-contacts-icon-size))
            org-contacts-ahead-space-padding)
          " "
          contact-name
          (format " %s [%s]"
                  (make-string (or middle-line-length 0) ?―)
                  (string-join tags ":")))
         'contact-name contact-name
         'annotation info))))

  (defun org-contacts-complete-group (string)
    "Complete text at START from a group.

A group FOO is composed of contacts with the tag FOO."
    (let* ((completion-ignore-case org-contacts-completion-ignore-case)
           (group-completion-p (string-match-p
                                (concat "^" org-contacts-group-prefix) string)))
      (when group-completion-p
        (let ((completion-list
               (all-completions
                string
                (mapcar
                 (lambda (group)
                   (propertize (concat org-contacts-group-prefix group)
                               'org-contacts-group group))
                 (org-uniquify
                  (cl-loop for contact in (org-contacts-filter)
                           nconc (org-split-string
                                  (or (cdr (assoc-string "ALLTAGS" (caddr contact)))
                                      "") ":")))))))

          (if (= (length completion-list) 1)
              ;; We've found the correct group, returns the address
              (let ((tag (get-text-property 0 'org-contacts-group
                                            (car completion-list))))
                (list
                 (concat
                  string
                  (mapconcat
                   #'identity
                   (cl-loop
                    for contact in (org-contacts-filter
                                    nil
                                    tag)
                    ;; The contact name is always the car of the assoc-list
                    ;; returned by `org-contacts-filter'.
                    for contact-name = (car contact)
                    ;; Grab the first email of the contact
                    for email = (org-contacts-strip-link
                                 (or (car (org-contacts-split-property
                                           (or
                                            (cdr (assoc-string
                                                  org-contacts-email-property
                                                  (cl-caddr contact)))
                                            ""))) ""))
                    ;; If the user has an email address, append USER <EMAIL>.
                    if email collect (org-contacts-format-email contact-name email))
                   ", "))))
            ;; We haven't found the correct group
            (completion-table-case-fold completion-list
                                        (not org-contacts-completion-ignore-case)))))))

  (defun org-contacts-anniversaries (&optional field format)
    (let ((calendar-date-style 'american))
      (unless format (setq format org-contacts-birthday-format))
      (cl-loop
       for contact in (org-contacts-filter)
       for anniv = (let ((anniv (cdr (assoc-string
                                      (or field org-contacts-birthday-property)
                                      (nth 2 contact)))))
                     (when anniv
                       (calendar-gregorian-from-absolute
                        (org-time-string-to-absolute anniv))))
       ;; Use `diary-anniversary' to compute anniversary.
       ;; FIXME: should we require `diary-lib' somewhere to be sure
       ;; `diary-anniversary' is defined when we get here?
       if (and anniv (apply #'diary-anniversary anniv))
       collect (format-spec format
                            `((?l . ,(car contact))
                              (?h . ,(car contact))
                              (?y . ,(- (calendar-extract-year date)
                                        (calendar-extract-year anniv)))
                              (?Y . ,(let ((years (- (calendar-extract-year date)
                                                     (calendar-extract-year anniv))))
                                       (format "%d%s" years (diary-ordinal-suffix years))))))))))
#+end_src

*** org-context

#+begin_src emacs-lisp
(use-package org-context
  :load-path "lisp/org-context"
  :after org
  :demand t
  :bind (:map
         org-mode-map
         ("C-c C-x R" . org-context-undo)
         ("C-c C-x W" . org-context-show-olpath))
  :config
  (org-context-install))
#+end_src

*** org-crypt

#+begin_src emacs-lisp
(use-package org-crypt
  :after org
  :demand t
  :bind (:map org-mode-map
              ("C-c C-x /"    . my/org-set-crypt-tag)
              ("C-c C-x C-/"  . org-decrypt-entry)
              ("C-c C-x C-\\" . org-encrypt-entry))
  :custom
  (org-tags-exclude-from-inheritance (quote ("crypt")))
  (org-crypt-disable-auto-save nil)
  (org-crypt-key "0xBA39EA53EFF3C20D")
  :preface
  (defun my/org-set-crypt-tag ()
    (interactive)
    (save-excursion
      (org-back-to-heading-or-point-min)
      (org-set-tags '("crypt"))))
  :config
  (org-crypt-use-before-save-magic))
#+end_src

*** org-drill

#+begin_src emacs-lisp
(use-package org-drill
  :commands org-drill)
#+end_src

*** org-devonthink

#+begin_src emacs-lisp
(use-package org-devonthink
  :load-path "lisp/org-devonthink"
  :after org
  :demand t
  :functions (org-devonthink-open)
  :bind
  (:map
   org-mode-map
   ("C-c C-x L" . org-devonthink-set-link)
   ("C-c C-x l" . org-devonthink-insert-link))
  :config
  (eval-after-load 'org-noter
    '(add-hook 'org-noter-parse-document-property-hook
               #'org-devonthink-uuid-to-path))

    ;; Replace Gnus link type with Message
  (org-link-set-parameters "message"
			   :follow #'org-devonthink-message-open
			   :store #'org-gnus-store-link))
#+end_src

*** org-edna

#+begin_src emacs-lisp
(use-package org-edna
  :after org
  :diminish
  :config
  (org-edna-mode))
#+end_src

*** org-element

#+begin_src emacs-lisp
(use-package org-element
  :after org
  :preface
  (defun my/org-element-check-buffer (element)
    (unless (org-element-property :buffer element)
      (org-element--cache-warn
       "Got element without buffer (cache active?: %S)\n%S"
       (org-element--cache-active-p)
       element)))
  :init
  (setq org-element-cache-persistent nil
        org-element--cache-self-verify nil
        ;; org-element--cache-self-verify 'backtrace
        )
  :config
  (advice-add 'org-element--cache-verify-element
              :before #'my/org-element-check-buffer))
#+end_src

*** org-color

#+begin_src emacs-lisp
(use-package org-color
  :after org)
#+end_src

*** org-extra-emphasis

#+begin_src emacs-lisp
(use-package org-extra-emphasis
  :after org
  :diminish org-extra-emphasis-intraword-emphasis-mode
  :custom-face
  (org-extra-emphasis-01
   ((t (:inherit org-extra-emphasis
                 :bold t :background "yellow" :foreground "black")))))
#+end_src

*** org-caldav

#+begin_src emacs-lisp
(use-package org-caldav
  :commands org-caldav-sync
  :custom
  (org-caldav-save-directory user-data-directory)
  (org-caldav-url "https://caldav.fastmail.com/dav/calendars/user/johnw@newartisans.com/")
  (org-caldav-debug-level 0)
  (org-caldav-calendars
   `(
     (:calendar-id
      "86ff68d4-479a-4bdf-aef4-eac0bff178f7"
      :inbox ,(org-file "calendar/jwiegley.org")
      :files (,(org-file "archive/calendar/jwiegley.org")))
     (:calendar-id
      "c65fd79e-8321-4d6d-a642-0b647b832b75"
      :inbox ,(org-file "calendar/c2g.org")
      :files (,(org-file "archive/calendar/c2g.org")))
     (:calendar-id
      "91aa56f8-1d1c-437d-a4c0-c9fcc7ab71b6"
      :inbox ,(org-file "calendar/family.org")
      :files (,(org-file "archive/calendar/family.org")))
     (:calendar-id
      "f75ebabb-9c55-4c2e-b572-b6fd734c5fe2"
      :inbox ,(org-file "calendar/bahai.org")
      :files (,(org-file "archive/calendar/bahai.org")))

     (:calendar-id
      "8b1d0a83-6c8e-46d9-acc7-755819a56a54"
      :inbox ,(org-file "calendar/tripit.org")
      :files (,(org-file "archive/calendar/tripit.org")))

     (:calendar-id
      "eb88c053-4d61-4015-ac11-e6d8f437eb16"
      :inbox ,(org-file "calendar/kadena.org")
      :files (,(org-file "archive/calendar/kadena.org")))

     (:calendar-id
      "b6f9a6f5-7a62-45a3-8b29-b4c7cfe4555f"
      :inbox ,(org-file "calendar/coppertogold.org")
      :files (,(org-file "archive/calendar/coppertogold.org")))))
  (org-caldav-files nil)
  (org-caldav-sync-direction 'cal->org)
  (org-caldav-oauth2-client-id "johnw@newartisans.com")
  (org-icalendar-timezone "America/Los_Angeles")
  (org-caldav-description-blank-line-after nil)
  (org-caldav-description-blank-line-before nil)
  (org-caldav-sync-changes-to-org 'title-only)
  :config
  (advice-add
   'org-caldav-insert-org-entry--wrapup :after
   (lambda (&rest _)
     (org-entry-put (point) "CREATED"
                    (format-time-string (org-time-stamp-format t t))))))
#+end_src

*** org-vcard

#+begin_src emacs-lisp
(use-package org-vcard
  :after (org)
  :commands (org-vcard-import org-vcard-export))
#+end_src

*** COMMENT org-fancy-priorities

Org mode is great. It is powerful, versatile and customizable. Unfortunately,
I always found the task priorities functionality a bit underwhelming, not in
terms of usability, but more in the visual department.

Inspired by [[https://github.com/sabof/org-bullets][org-bullets]], I created a [[https://github.com/harrybournis/org-fancy-priorities][minor mode]] that displays org priorities
as custom strings. This mode does *NOT* change your files in any way, it only
displays the priority part of a heading as your preferred string value.

#+begin_src emacs-lisp
(use-package org-fancy-priorities
  :after org
  :diminish org-fancy-priorities-mode
  :hook
  (org-agenda-mode . org-fancy-priorities-mode)
  :custom
  (org-fancy-priorities-list
   `(
     ;; (?A . ,(propertize "🅰" 'face 'org-extra-emphasis-02))
     ;; (?B . ,(propertize "🄱" 'face 'org-level-8))
     ;; (?C . ,(propertize "Ⓒ" 'face 'org-level-1))
     (?A . ,(propertize "[#A]" 'face 'org-extra-emphasis-02))
     (?B . ,(propertize "[#B]" 'face 'org-level-8))
     (?C . ,(propertize "[#C]" 'face 'org-level-1))
     )))
#+end_src

*** COMMENT org-gcal

#+begin_src emacs-lisp
(use-package org-gcal
  :commands org-gcal-fetch
  :custom
  (org-gcal-dir (user-data "org-gcal/"))
  (org-gcal-fetch-file-alist
   (list
    (cons "jwiegley@gmail.com"
          (org-file "calendar/google.org"))
    (cons "ajhrtkkubthrda9l40bf95hceo@group.calendar.google.com"
          (org-file "calendar/bahai.org"))
    (cons "pse8nk29dq9ll8g7jpq0mbllf8@group.calendar.google.com"
          (org-file "calendar/c2g.org"))
    (cons "57jh2om1vl9sv16sor1mudl030@group.calendar.google.com"
          (org-file "calendar/family.org"))
    ;; (cons "54ioufdqn31buq7et3uo1u37tlceqldh@import.calendar.google.com"
    ;;       (org-file "calendar/tripit.org"))
    (cons "789ust6872bajeo87oqd2jqfog@group.calendar.google.com"
          (org-file "calendar/nasim.org"))
    ;; (cons "sacramento.lsa1914@gmail.com"
    ;;       (org-file "calendar/sacramento.org"))
    ))
  :config
  (setq org-gcal-client-id
        (lookup-password "org-caldav-user.google.com" "jwiegley@gmail.com" 80)
        org-gcal-client-secret
        (lookup-password "org-caldav.google.com" org-gcal-client-id 80))

  (org-gcal-reload-client-id-secret))
#+end_src

*** org-hash

#+begin_src emacs-lisp
(use-package org-hash
  :load-path "lisp/org-hash"
  :after org
  :bind (:map
         org-mode-map
         ("C-c C-x #"   . org-hash-update-or-confirm)
         ("C-c C-x C-#" . org-hash-update-or-confirm-all)))
#+end_src

**** hash-store

#+begin_src emacs-lisp
(use-package hash-store
  :load-path "lisp/hash-store"
  :after (org-hash))
#+end_src

*** org-id

#+begin_src emacs-lisp
(use-package org-id
  :after org
  :custom
  (org-id-link-to-org-use-id 'use-existing)
  (org-id-locations-file (user-data "org-id-locations"))
  (org-id-extra-files nil)
  (org-id-search-archives nil))
#+end_src

*** org-inlinetask

#+begin_src emacs-lisp
(use-package org-inlinetask
  :after org
  :demand t
  :functions (org-inlinetask-in-task-p))
#+end_src

*** org-mime

#+begin_src emacs-lisp
(use-package org-mime
  :after org
  :demand t
  :bind
  (:map
   org-mode-map
   ("C-c M-o" . org-mime-org-buffer-htmlize)
   :map
   message-mode-map
   ("C-c M-o" . org-mime-htmlize))
  :config
  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "blockquote" "border-left: 2px solid gray; padding-left: 4px;")
              (org-mime-change-element-style
               "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                             "#E6E1DC" "#232323")))))
#+end_src

*** COMMENT org-msg

#+begin_src emacs-lisp
(use-package org-msg
  :demand t
  :after (org message)
  :bind (:map org-msg-edit-mode-map
              ("C-c C-f C-p" . gnus-alias-select-identity))
  :custom
  (org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t")
  (org-msg-startup "hidestars indent inlineimages")
  (org-msg-greeting-fmt "\nHi %s,\n\n")
  (org-msg-recipient-names '(("jwiegley@gmail.com" . "John")))
  (org-msg-greeting-name-limit 3)
  (org-msg-default-alternatives '((new html text)
				  (reply-to-html html text)
				  (reply-to-text text)))
  (org-msg-convert-citation t)
  :config
  (org-msg-mode)

  (eval-after-load 'gnus-alias
    '(defun gnus-alias-ensure-message-mode ()
       "Assert that the current buffer is a message buffer."
       (when (not (or (derived-mode-p 'message-mode)
                      (derived-mode-p 'org-msg-edit-mode)))
         (gnus-alias-error "Must be in `message-mode'.? ")))))
#+end_src

*** COMMENT org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :custom
  (org-modern-list '((43 . "◦") (45 . "•") (42 . "⋆")))
  (org-modern-todo t)
  (org-modern-star nil)
  :config
  (global-org-modern-mode))
#+end_src

*** org-noter

#+begin_src emacs-lisp
(use-package org-noter
  :after (org pdf-view)
  :commands org-noter
  :bind (:map org-noter-notes-mode-map
              ("C-M-i" . org-noter-insert-dynamic-block))
  :custom
  (org-noter-notes-search-path (list org-directory))
  (org-noter-supported-modes '(doc-view-mode pdf-view-mode))
  (org-noter-max-short-selected-text-length 10)
  (org-noter-separate-notes-from-heading t)
  :config
  (use-package org-noter-pdf)

  (require 'pdf-macs)
  (defun org-noter-pdf--show-arrow ()
    ;; From `pdf-util-tooltip-arrow'.
    (pdf-util-assert-pdf-window)
    (let* (x-gtk-use-system-tooltips
           (arrow-top  (aref org-noter--arrow-location 2)) ; % of page
           (arrow-left (aref org-noter--arrow-location 3))
           (image-top  (if (floatp arrow-top)
                           (round (* arrow-top  (cdr (pdf-view-image-size)))))) ; pixel location on page (magnification-dependent)
           (image-left (if (floatp arrow-left)
                           (floor (* arrow-left (car (pdf-view-image-size))))))
           (dx (or image-left
                   (+ (or (car (window-margins)) 0)
                      (car (window-fringes)))))
           (dy (or image-top 0))
           (pos (list dx dy dx (+ dy (* 2 (frame-char-height)))))
           (vscroll (pdf-util-required-vscroll pos))
           (tooltip-frame-parameters
            `((border-width . 0)
              (internal-border-width . 0)
              ,@tooltip-frame-parameters))
           (tooltip-hide-delay 3))

      (when vscroll
        (image-set-window-vscroll vscroll))
      (setq dy (max 0 (- dy
                         (cdr (pdf-view-image-offset))
                         (window-vscroll nil t)
                         (frame-char-height))))
      (when (overlay-get (pdf-view-current-overlay) 'before-string)
        (let* ((e (window-inside-pixel-edges))
               (xw (pdf-util-with-edges (e) e-width))
               (display-left-margin (/ (- xw (car (pdf-view-image-size t))) 2)))
          (cl-incf dx display-left-margin)))
      (setq dx (max 0 (+ dx org-noter-arrow-horizontal-offset)))
      (pdf-util-tooltip-in-window
       (propertize
        " " 'display (propertize
                      "\u2192" ;; right arrow
                      'display '(height 2)
                      'face `(:foreground
                              ,org-noter-arrow-foreground-color
                              :background
                              ,(if (bound-and-true-p pdf-view-midnight-minor-mode)
                                   (cdr pdf-view-midnight-colors)
                                 org-noter-arrow-background-color))))
       dx dy))))
#+end_src

*** org-pdftools

#+begin_src emacs-lisp
(use-package org-pdftools
  :hook (org-mode . org-pdftools-setup-link))
#+end_src

*** org-protocol

#+begin_src emacs-lisp
(use-package org-protocol
  :after org
  :custom
  (org-protocol-default-template-key "l"))
#+end_src

*** org-real

#+begin_src emacs-lisp
(use-package org-real
  :after org)
#+end_src

*** org-reverse-datetree

[[https://github.com/akirak/org-reverse-datetree][org-reverse-datetree]] provides functions for creating reverse date trees, which
are similar to date trees as supported by built-in functions of Org mode (e.g.
=org-capture=) but in a reversed order.

#+begin_src emacs-lisp
(use-package org-reverse-datetree
  :after org
  :commands (org-reverse-datetree-calendar))
#+end_src

*** org-quick-peek

#+begin_src emacs-lisp
(use-package org-quick-peek
  :after org
  :bind (:map org-agenda-mode-map
              ("E" . org-quick-peek-agenda-current-item))
  :custom
  (org-quick-peek-show-lines 20)
  :config
  ;;; Fix org-quick-peek creating invisible overlay when agenda filter is in
  ;;; place and the next item is hidden by the filter
  (defun quick-peek-overlay-ensure-at (pos)
    "Find or create a quick-peek overlay for the line at POS.

Typical code should not need this method; use `quick-peek-show'
instead."
    (or (quick-peek-overlay-at pos)
	(let* ((ov (save-excursion
                     (goto-char pos)
                     (make-overlay (line-beginning-position)
                                   (1+ (line-end-position))))))
          (overlay-put ov 'quick-peek t)
          ;; Add impossible invisible property
          (overlay-put ov 'invisible 'nope)
          (push ov quick-peek--overlays)
          ov))))
#+end_src

*** org-pretty-table

#+begin_src emacs-lisp
(use-package org-pretty-table
  :after org
  :diminish org-pretty-table-mode
  :hook (org-mode . org-pretty-table-mode))
#+end_src

*** org-projectile

This package provides an easy interface to creating per project =org-mode= =TODO=
headings, whether in a single file, or in a file stored in each project
directory.

#+begin_src emacs-lisp
(use-package org-projectile
  :after org)
#+end_src

**** org-project-capture

[[https://github.com/colonelpanic8/org-project-capture][org-project-capture]] integrates =org-mode= TODOs with both =projectile= and
=project.el=. This permits the maintenance of TODO lists for specific projects.

#+begin_src emacs-lisp
(use-package org-project-capture
  :after org-projectile
  :bind (:map
         my-ctrl-c-n-map
         ("p" . org-project-capture-capture-for-current-project))
  :custom
  (org-project-capture-default-backend
   (make-instance 'org-project-capture-projectile-backend))
  (org-project-capture-projects-file org-constants-open-source-path)
  :config
  (org-project-capture-single-file))
#+end_src

*** COMMENT org-recent-headings

#+begin_src emacs-lisp
(use-package org-recent-headings
  :bind ("M-g O" . org-recent-headings)
  :commands (org-recent-headings-mode)
  :config
  (org-recent-headings-mode)

  (eval-when-compile
    (require 'vertico-multiform))
  (add-to-list 'vertico-multiform-commands
               '(org-recent-headings)))
#+end_src

*** COMMENT org-recoll

#+begin_src emacs-lisp
(use-package org-recoll
  :after org
  :custom
  (org-recoll-command-invocation "/Applications/recoll.app/Contents/MacOS/recoll -t -A")
  (org-recoll-index-invocation "/Applications/recoll.app/Contents/MacOS/recollindex"))
#+end_src

*** org-refile

#+begin_src emacs-lisp
(use-package org-refile
  :after org
  :init
  (use-package org-ext
    :functions (org-ext-refile-heading-p
                org-ext-agenda-files-but-not-meetings
                org-ext-team-files
                org-ext-refine-refile-targets))
  :custom
  (org-refile-targets
   `((org-ext-agenda-files-but-not-meetings . (:maxlevel . 4))
     ;; (org-ext-team-files . (:regexp . "Notes"))
     ((,org-constants-contacts-path
       ,org-constants-plain-org-path)
      . (:level . 1))))
  (org-refile-target-verify-function #'org-ext-refile-heading-p)
  (org-refile-use-cache nil)
  (org-refile-use-outline-path 'file)
  :config
  (advice-add 'org-refile-get-targets :around
              #'org-ext-refine-refile-targets))
#+end_src

*** org-remark

[[https://github.com/nobiot/org-remark][Org-remark]] lets you highlight and annotate text files, websites, EPUB books
and Info documentation with using Org mode.

#+begin_src emacs-lisp
(use-package org-remark
  :after org
  :diminish org-remark-global-tracking-mode
  :commands (org-remark-global-tracking-mode)
  :bind (:map
         my-ctrl-c-n-map
         ("m" . org-remark-mark)
         ("M" . org-remark-mark-line) ; new in v1.3
         :map org-remark-mode-map
         ("C-c n o" . org-remark-open)
         ("C-c n ]" . org-remark-view-next)
         ("C-c n [" . org-remark-view-prev)
         ("C-c n r" . org-remark-remove)
         ("C-c n d" . org-remark-delete))
  :config
  (org-remark-global-tracking-mode t))
#+end_src

*** COMMENT org-return

#+begin_src emacs-lisp
(use-package org-return
  :no-require t
  :after org
  :bind (:map org-mode-map
              ("<return>" . scimax/org-return))
  :preface
  (eval-when-compile
    (require 'org-inlinetask))

  (defun scimax/org-return (&optional ignore)
    "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
    (interactive "P")
    (if ignore
        (org-return)
      (cond

       ((eq 'line-break (car (org-element-context)))
        (org-return t))

       ;; Open links like usual, unless point is at the end of a line.
       ;; and if at beginning of line, just press enter.
       ((or (and (eq 'link (car (org-element-context))) (not (eolp)))
            (bolp))
        (org-return))

       ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
       ;; Johansson!
       ((org-inlinetask-in-task-p)
        (org-return))

       ;; checkboxes too
       ((org-at-item-checkbox-p)
        (org-insert-todo-heading nil))

       ;; lists end with two blank lines, so we need to make sure we are also not
       ;; at the beginning of a line to avoid a loop where a new entry gets
       ;; created with only one blank line.
       ((org-in-item-p)
        (if (save-excursion (beginning-of-line) (org-element-property :contents-begin (org-element-context)))
            (org-insert-heading)
          (beginning-of-line)
          (delete-region (line-beginning-position) (line-end-position))
          (org-return)))

       ;; org-heading
       ((org-at-heading-p)
        (if (not (string= "" (org-element-property :title (org-element-context))))
            (progn (org-end-of-meta-data)
                   (org-insert-heading-respect-content)
                   (outline-show-entry))
          (beginning-of-line)
          (setf (buffer-substring
                 (line-beginning-position) (line-end-position)) "")))

       ;; tables
       ((org-at-table-p)
        (if (-any?
             (lambda (x) (not (string= "" x)))
             (nth
              (- (org-table-current-dline) 1)
              (org-table-to-lisp)))
            (org-return)
          ;; empty row
          (beginning-of-line)
          (setf (buffer-substring
                 (line-beginning-position) (line-end-position)) "")
          (org-return)))

       ;; fall-through case
       (t
        (org-return))))))
#+end_src

*** org-review

Track when you have done a review in org mode.

Tasks typically have Scheduled and Deadline time stamps, which define when the
task has to be done. [[https://github.com/brabalan/org-review][Org-review]] lets you attach an additional review time
stamp to a task, which can be used to schedule a review of the task.

#+begin_src emacs-lisp
(use-package org-review
  :after org
  :demand t
  :bind
  (:map
   my-ctrl-c-n-map
   ("R" . org-review-insert-next-review)
   ("r" . my/org-insert-last-and-set-next-review)
   :map
   org-agenda-mode-map
   :prefix-map
   my/org-review-map
   :prefix "r"
   ("R" . org-review-insert-next-review)
   ("r" . my/org-insert-last-and-set-next-review)
   ("d" . review-next-day)
   ("D" . review-next-three-days)
   ("w" . review-next-week)
   ("2" . review-next-two-days)
   ("@" . review-next-two-weeks)
   ("3" . review-next-three-days)
   ("#" . review-next-three-weeks)
   ("4" . review-next-four-days)
   ("$" . review-next-four-weeks)
   ("5" . review-next-five-days)
   ("%" . review-next-five-weeks)
   ("6" . review-next-six-days)
   ("^" . review-next-six-weeks)
   ("m" . review-next-month)
   ("M" . review-next-two-months)
   ("t" . review-next-two-months)
   ("q" . review-next-quarter)
   ("Q" . review-next-quarter)
   ("h" . review-next-half-year)
   ("y" . review-next-year)
   ("Y" . review-next-two-years)
   )
  :custom
  (org-review-last-timestamp-format 'inactive)
  (org-review-next-timestamp-format 'inactive)
  :preface
  (defun my/org-review-increment-count (&rest _)
    (interactive)
    (let* ((where (if (equal major-mode 'org-agenda-mode)
                      (or (org-get-at-bol 'org-marker)
	                  (org-agenda-error))
                    (point)))
           (reviews (org-entry-get where "REVIEWS")))
      (if reviews
          (org-entry-put where "REVIEWS"
                         (number-to-string
                          (1+ (string-to-number reviews))))
        (org-entry-put where "REVIEWS" "1"))))

  (defun my/org-reviewed-today ()
    (interactive)
    (when (or (ignore-errors
                (and (org-get-todo-state)
                     (not (member (org-get-todo-state)
                                  '("NOTE" "LINK" "SCRAP")))))
              (save-excursion
                (goto-char (point-min))
                (looking-at "^\\(DRAFT\\|TODO\\|TASK\\|HABIT\\) ")))
      (save-excursion
        (org-review-insert-last-review)
        (org-review-insert-date
         org-review-next-property-name
	 org-review-next-timestamp-format
	 (format-time-string (car org-time-stamp-formats)
                             (current-time))))))

  (defun my/org-insert-last-and-set-next-review ()
    (interactive)
    (org-review-insert-last-review)
    (call-interactively #'org-review-insert-next-review))

  (defun my/org-review-next (delay)
    (let ((org-review-delay delay))
      (org-review-insert-last-review nil)))

  (defun review-next-day ()
    (interactive)
    (my/org-review-next "+1d")
    (message "Next review in 1 day"))
  (defun review-next-two-days ()
    (interactive)
    (my/org-review-next "+2d")
    (message "Next review in 2 days"))
  (defun review-next-three-days ()
    (interactive)
    (my/org-review-next "+3d")
    (message "Next review in 3 days"))
  (defun review-next-four-days ()
    (interactive)
    (my/org-review-next "+4d")
    (message "Next review in 4 days"))
  (defun review-next-five-days ()
    (interactive)
    (my/org-review-next "+5d")
    (message "Next review in 5 days"))
  (defun review-next-six-days ()
    (interactive)
    (my/org-review-next "+6d")
    (message "Next review in 6 days"))
  (defun review-next-week ()
    (interactive)
    (my/org-review-next "+1w")
    (message "Next review in 1 week"))
  (defun review-next-two-weeks ()
    (interactive)
    (my/org-review-next "+2w")
    (message "Next review in 2 weeks"))
  (defun review-next-three-weeks ()
    (interactive)
    (my/org-review-next "+3w")
    (message "Next review in 3 weeks"))
  (defun review-next-four-weeks ()
    (interactive)
    (my/org-review-next "+4w")
    (message "Next review in 4 weeks"))
  (defun review-next-five-weeks ()
    (interactive)
    (my/org-review-next "+5w")
    (message "Next review in 5 weeks"))
  (defun review-next-six-weeks ()
    (interactive)
    (my/org-review-next "+6w")
    (message "Next review in 6 weeks"))
  (defun review-next-month ()
    (interactive)
    (my/org-review-next "+1m")
    (message "Next review in 1 month"))
  (defun review-next-two-months ()
    (interactive)
    (my/org-review-next "+2m")
    (message "Next review in 2 months"))
  (defun review-next-quarter ()
    (interactive)
    (my/org-review-next "+3m")
    (message "Next review in 3 months"))
  (defun review-next-half-year ()
    (interactive)
    (my/org-review-next "+6m")
    (message "Next review in 6 months"))
  (defun review-next-year ()
    (interactive)
    (my/org-review-next "+1y")
    (message "Next review in 1 year"))
  (defun review-next-two-years ()
    (interactive)
    (my/org-review-next "+2y")
    (message "Next review in 2 years"))
  :config
  (add-hook 'org-capture-before-finalize-hook #'my/org-reviewed-today)
  (add-hook 'org-after-todo-state-change-hook #'my/org-reviewed-today)

  (advice-add 'org-review-insert-last-review
              :after #'my/org-review-increment-count))
#+end_src

*** org-rich-yank

#+begin_src emacs-lisp
(use-package org-rich-yank
  :bind (:map org-mode-map
              ("C-M-y" . org-rich-yank)))
#+end_src

*** COMMENT org-mem

#+begin_src emacs-lisp
(use-package org-mem
  :custom
  (org-mem-do-sync-with-org-id t)
  (org-mem-watch-dirs (list org-directory))
  (org-mem-roamy-do-overwrite-real-db t)
  :config
  (push "/template" org-mem-exclude)
  (push "archive" org-mem-exclude)

  (use-package org-mem-updater
    :config
    (org-mem-updater-mode))

  (use-package org-mem-roamy
    :config
    (org-mem-roamy-db-mode)))
#+end_src

*** COMMENT org-node

#+begin_src emacs-lisp
(use-package org-node
  :demand t
  ;; :bind
  ;; (:prefix-map org-node-global-prefix-map :prefix "M-o n")
  :config
  (keymap-set global-map "M-o n" org-node-global-prefix-map)
  (with-eval-after-load 'org-keys
    (keymap-set org-mode-map "M-o n" org-node-org-prefix-map))

  ;; (use-package org-keys
  ;;   :demand t
  ;;   :bind
  ;;   (:map
  ;;    org-mode-map
  ;;    :prefix-map org-node-org-prefix-map :prefix "M-o n"))

  (setq org-node-alter-candidates t)

  (setq org-node-filter-fn
        (lambda (node)
          (not (member "ARCHIVE" (org-mem-entry-tags node)))))

  (org-node-cache-mode)
  (org-node-roam-accelerator-mode)

  (setq org-node-creation-fn #'org-node-new-via-roam-capture)
  (setq org-node-file-slug-fn #'org-node-slugify-like-roam-default)
  (setq org-node-file-timestamp-format "%Y%m%d%H%M%S-"))
#+end_src

*** embark-org

#+begin_src emacs-lisp
(use-package embark-org
  :after (embark))
#+end_src

*** org-roam

#+begin_src emacs-lisp
(use-package org-roam
  :demand t
  :after org
  :functions (org-roam-db-sync)
  :bind
  (:map
   org-mode-map
   ("C-M-i" . completion-at-point)
   :map
   my-ctrl-c-n-map
   ("B" . org-roam-buffer-toggle)
   ("f" . org-roam-node-find)     ; overridden by consult-org-roam
   ("i" . org-roam-node-insert)
   ;; ("r" . org-roam-tag-remove)
   ("t" . org-roam-tag-add))
  :custom
  (org-roam-db-update-on-save nil)
  (org-roam-directory org-directory)
  (org-roam-completion-everywhere t)
  (org-roam-db-location (user-data "org-roam.db"))
  (org-roam-extract-new-file-path "%<%Y%m%d%H%M>-${slug}.org")
  (org-roam-file-exclude-regexp
   '(
     "\\`[._]"
     "/[._]"
     "archive"
     "\\`data/"
     "\\`calendar/"
     "\\`template/"
     "\\`snippet/"
     "\\.\\(css\\|html\\|xml\\|txt\\|jpe?g\\|png\\|tiff\\|css\\|yaml\\)\\'"
     ))
  :defines
  (org-roam-v2-ack)
  :functions
  (org-roam-db-query
   org-roam-node-read
   org-roam-capture-
   org-roam-node-list
   org-roam-node-file)
  :preface
  (defun org-roam-excluded-file (relative-path)
    "Return non-nil if RELATIVE-PATH should be excluded from Org-roam."
    (let (is-match)
      (dolist (exclude-re org-roam-file-exclude-regexp)
        (setq is-match
              (or is-match
                  (string-match-p exclude-re relative-path))))
      is-match))
  :init
  (setq org-roam-v2-ack t)
  :config
  ;; (org-roam-db-autosync-mode)
  (unless alternate-emacs
    (run-with-idle-timer 300 t 'org-roam-db-sync))

  (cl-defun org-roam-node-insert-section (&key source-node point properties)
    (magit-insert-section
        section
      (org-roam-node-section)
      (let ((outline
             (if-let ((outline (plist-get properties :outline)))
                 (mapconcat #'org-link-display-format outline " > ")
               "Top")))
        (insert
         (concat
          (propertize (org-roam-node-title source-node)
                      'font-lock-face 'org-roam-title)
          " "
          (propertize (cdr (assoc "CREATED" (org-roam-node-properties source-node)))
                      'font-lock-face 'org-roam-dailies-calendar-note)
          (format " (%s)"
                  (propertize outline 'font-lock-face 'org-roam-olp)))))
      (magit-insert-heading)
      (oset section node source-node)
      (magit-insert-section
          section
        (org-roam-preview-section)
        (insert (org-roam-fontify-like-in-org-mode
                 (org-roam-preview-get-contents
                  (org-roam-node-file source-node) point))
                "\n")
        (oset section file (org-roam-node-file source-node))
        (oset section point point)
        (insert ?\n)))))
#+end_src

**** vulpea

A collection of functions for note taking based on =org= and =org-roam=. This
repository primary goal is to be a tested library for other applications and
utilities around note taking.

*Reasons to use [[https://github.com/d12frosted/vulpea][vulpea]]*

- If you are automating things around Org mode files and you want to have a
  tested library to build upon.

- While =org-roam= was greatly simplified and has adopted some ideas from =vulpea=
  starting from =v2=, it still lacks certain pieces for programmatic usage. Just
  to name few of them:

  1. =vulpea-db-query= is a great interface for quick database search without
     knowing its scheme. In many cases you just want to have a fully
     materialized note instead of a structure that lacks, say tags or aliases.
     So you don’t need to write any extra SQL. See Performance for more
     information.
  2. =vulpea-select= is a configurable interface for selecting a note with an
     optional filter. See vulpea-select for more information.
  3. =vulpea-create= is a wrapper around =org-roam-capture-= allowing to easily
     provide extra properties, tags and context when creating a new note. And
     most importantly - it returns a newly created note. See vulpea-create for
     more information.

- Several interactive functions:

  1. =vulpea-find= that acts like =org-roam-node-find=, but (a) uses =vulpea-select=
     for consistent experience and (b) allows to configure default and on-use
     filtering and candidates source. See vulpea-find for more information.
  2. =vulpea-find-backlink= is just a convenient function to find a note linking
     currently opened one. For those who don’t want to use =org-roam= buffer.
  3. =vulpea-insert= that acts like =org-roam-node-insert=, but (a) uses
     =vulpea-select= for consistent experience, (b) allows to set
     =vulpea-insert-default-filter= (see =vulpea-find= for examples) and (c)
     allows to provide an insertion handler via =vulpea-insert-handle-functions=
     , which is called with inserted note. See vulpea-insert for more
     information.

- =vulpea= is more than just a wrapper around =org-roam= , it contains more stuff:

  1. Utilities for dealing with buffer properties (e.g. =#+KEY: VALUE=).
  2. Utilities for dealing with metadata (e.g. first description list in the
     buffer).

#+begin_src emacs-lisp
(use-package vulpea
  :after org-roam
  :demand t
  :bind
  (:map
   my-ctrl-c-n-map
   ("f" . vulpea-find)
   ("b" . vulpea-find-backlink))
  :hook
  (org-roam-db-autosync-mode . vulpea-db-autosync-enable)
  :config
  (add-all-to-list 'vertico-multiform-commands
                   '(vulpea-find)
                   '(vulpea-find-backlink)
                   '(my-vulpea-find-journal))

  (defsubst vulpea-buffer-meta-get (prop)
    "Get all values of metadata PROP from buffer."
    (vulpea-buffer-meta-get! (vulpea-buffer-meta) name)))
#+end_src

***** vulpea-field

#+begin_src emacs-lisp
(use-package vulpea-field
  :load-path "lisp/vulpea-field"
  :after (vulpea)
  :functions (vulpea-field-setup vulpea-field-query))
#+end_src

***** vulpea-ext

#+begin_src emacs-lisp
(use-package vulpea-ext
  :after (vulpea vulpea-field)
  :demand t
  :bind
  (:map
   my-ctrl-c-n-map
   ("j" . vulpea-find-journal))
  :hook
  (org-roam-db-autosync-mode . vulpea-ext-db-setup-dates)
  :config
  (vulpea-auto-update-install)
  (vulpea-ext-db-setup-dates)
  (vulpea-db-autosync-enable)

  (advice-add
   'vulpea-update-agenda-files
   :after (lambda (&rest _ignore)
            (nconc org-agenda-files
                   (list org-constants-contacts-path
                         org-constants-plain-org-path
                         ;; org-constants-flat-habits-path
                         )))))
#+end_src

**** org-roam-dailies

#+begin_src emacs-lisp
(use-package org-roam-dailies
  :after org-roam
  :demand t
  :bind
  (:map
   my-ctrl-c-n-map
   ("J" . org-roam-dailies-capture-today)
   ("d" . org-roam-dailies-map)         ; this is a keymap
   :map
   org-roam-dailies-map
   ("Y" . org-roam-dailies-capture-yesterday)
   ("T" . org-roam-dailies-capture-tomorrow))
  :custom
  (org-roam-dailies-directory "journal/")
  :functions
  (org-roam-dailies-capture-tomorrow
   org-roam-dailies-capture-yesterday
   org-roam-dailies-capture-today
   org-roam-dailies--capture))
#+end_src

**** org-roam-ext

#+begin_src emacs-lisp
(use-package org-roam-ext
  :after org-roam
  :demand t
  :bind* ("C-c M-m" . org-roam-ext-create-new)
  :bind
  (:map
   org-mode-map
   ("M-@" . org-roam-ext-insert-person)
   ("C-c C-x S" . org-roam-ext-sync)
   :map
   my-ctrl-c-n-map
   ("S" . org-roam-ext-import-fireflies)
   ("I" . org-roam-ext-node-insert-immediate)
   ("T" . org-roam-ext-revise-title)
   ("n" . org-roam-ext-create-new)
   ("W" . org-roam-ext-prepare-note))
  :hook
  (before-save . org-roam-ext-sort-file-properties)
  (before-save . org-roam-ext-pre-save-hook)
  (org-mode . org-roam-ext-paint-transcript)
  :config
  (cl-defmethod org-roam-node-slug ((node org-roam-node))
    "Return the slug of NODE."
    (org-roam-ext-title-slug (org-roam-node-title node))))
#+end_src

**** consult-org-roam

#+begin_src emacs-lisp
(use-package consult-org-roam
  :after (org-roam vertico)
  :demand t
  :diminish consult-org-roam-mode
  :bind
  (:map
   my-ctrl-c-n-map
   ;; ("f" . consult-org-roam-file-find)
   ("F" . consult-org-roam-forward-links)
   ("b" . consult-org-roam-backlinks)
   ("g" . consult-org-roam-search))
  :custom
  (consult-org-roam-grep-func #'consult-ripgrep)
  (consult-org-roam-buffer-enabled nil)
  (consult-org-roam-buffer-narrow-key ?r)
  (consult-org-roam-buffer-after-buffers t)
  :config
  (consult-org-roam-mode 1)

  (eval-when-compile
    (require 'vertico-multiform))
  (add-all-to-list 'vertico-multiform-commands
                   '(consult-org-roam-backlinks)
                   '(consult-org-roam-forward-links)
                   '(consult-org-roam-file-find)
                   '(consult-org-roam-search)))
#+end_src

**** consult-org-bookmarks

#+begin_src emacs-lisp
(use-package consult-org-bookmarks
  :bind ("C-x r B" . consult-org-bookmarks))
#+end_src

**** embark-org-roam

Use [[https://github.com/bramadams/embark-org-roam?tab=readme-ov-file][embark-select]] to select all org roam nodes of interest, then use
embark-export, which will open a special org mode buffer containing links to
the selected nodes.

You can customize whether the exported buffer is read-only using the
embark-org-roam-readonly variable. By default, the buffer is not read-only,
resulting in an org-mode checklist.

#+begin_src emacs-lisp
(use-package embark-org-roam
  :demand t
  :after (org-roam embark))
#+end_src

**** org-roam-ui

#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  :commands (org-roam-ui-mode)
  :diminish org-roam-ui-mode
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t))
#+end_src

**** COMMENT xeft

#+begin_src emacs-lisp
(use-package xeft
  :bind (:map my-ctrl-c-n-map ("x" . xeft))
  :custom
  (xeft-database (user-data "xeft.db"))
  (xeft-default-extension "org")
  (xeft-directory org-directory)
  (xeft-file-filter 'my-xeft-file-filter)
  (xeft-recursive t)
  (xeft-title-function 'my-xeft-get-title)
  (my-xeft-ignored-files org-constants-protected-filenames-list)
  :custom-face
  (xeft-excerpt-body
   ((t (:inherit default :foreground "grey80"))))
  (xeft-excerpt-title
   ((t (:inherit (bold underline) :foreground "green"))))
  (xeft-inline-highlight
   ((t (:inherit underline :extend t :foreground "orange"))))
  :functions
  (xeft-full-reindex)
  :preface
  (defun my-xeft-get-title (file)
    "Return the title of FILE.
Return the first line as title, recognize Org Mode’s #+TITLE:
cookie, if the first line is empty, return the file name as the
title."
    (re-search-forward (rx "#+title:" (* whitespace)) nil t)
    (let ((bol (point)))
      (goto-char (line-end-position))
      (let ((title (buffer-substring-no-properties bol (point))))
        (if (string= title "")
            (file-name-base file)
          title))))

  (defcustom my-xeft-ignored-files nil
    "Files to be excluded from xeft indexing."
    :group 'xeft
    :type '(repeat file))

  (defun my-xeft-file-filter (file)
    "Return nil if FILE should be ignored.
FILE is an absolute path. This default implementation ignores
directories, dot files, and files matched by
‘xeft-ignore-extension’."
    (let ((relative-path (file-relative-name file org-roam-directory))
          (base-name (file-name-nondirectory file)))
      (and (not (string-prefix-p "." base-name))
           (string= (file-name-extension base-name) "org")
           (not (string-suffix-p "~" base-name))
           (file-regular-p file)
           (not (member relative-path my-xeft-ignored-files))
           (not (org-roam-excluded-file relative-path)))))
  :config
  (defun xeft ()
    "Start Xeft."
    (interactive)
    (when (not (file-name-absolute-p xeft-directory))
      (user-error "XEFT-DIRECTORY must be an absolute path"))
    (when (not (file-exists-p xeft-directory))
      (mkdir xeft-directory t))
    (when (not (file-name-absolute-p xeft-database))
      (user-error "XEFT-DATABASE must be an absolute path"))
    (when (not (file-exists-p xeft-database))
      (mkdir xeft-database t))
    (if (not (xeft--require-xapian-lite))
        (message "Cannot start xeft because required dynamic module is missing")
      (setq xeft--last-window-config (current-window-configuration))
      (switch-to-buffer (xeft--buffer))
      (when (not (derived-mode-p 'xeft-mode))
        (xeft-mode)))))
#+end_src

*** org-sidebar

[[https://github.com/alphapapa/org-sidebar][org-sidebar]] presents helpful sidebars for Org buffers. Sidebars are
customizable using [[https://github.com/alphapapa/org-ql][org-ql]] queries and [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] grouping.

The default sidebar includes a chronological list of scheduled and deadlined
items in the current buffer (similar to the Org agenda, but without all its
features) at the top, and a list of all other non-done to-do items below. If
the buffer is narrowed, the sidebar only shows items in the narrowed portion;
this allows seeing an overview of tasks in a subtree.

#+begin_src emacs-lisp
(use-package org-sticky-header
  :commands org-sticky-header-mode)
#+end_src

*** org-srs

#+begin_src emacs-lisp
(use-package org-srs
  :after org
  :commands (org-srs-review-start
             org-srs-item-create)
  :bind (:map org-mode-map
              ("C-c n c"   . org-srs-item-create)
              ("<f4>"      . org-srs-review-start)
              ("C-<f4>"    . org-srs-review-quit)
              ("s-<right>" . org-srs-review-rate-easy)
              ("s-<up>"    . org-srs-review-rate-good)
              ("s-<left>"  . org-srs-review-rate-hard)
              ("s-<down>"  . org-srs-review-rate-again))
  :config
  (use-package org-srs-query
    :demand t)

  (use-package org-srs-embed
    :demand t
    :hook (org-mode . org-srs-embed-overlay-mode))

  (use-package org-srs-log
    :demand t
    :preface
;;; From https://stackoverflow.com/questions/17478260/completely-hide-the-properties-drawer-in-org-mode
    (defun my/org-srs-cycle-hide-drawers (state)
      "Re-hide all drawers after a visibility state change."
      (when (and (derived-mode-p 'org-mode)
                 (not (memq state '(overview folded contents))))
        (save-excursion
          (let* ((globalp (memq state '(contents all)))
                 (beg (if globalp
                          (point-min)
                        (point)))
                 (end (if globalp
                          (point-max)
                        (if (eq state 'children)
                            (save-excursion
                              (outline-next-heading)
                              (point))
                          (org-end-of-subtree t)))))
            (goto-char beg)
            (while (re-search-forward org-drawer-regexp end t)
              (save-excursion
                (beginning-of-line 1)
                (when (looking-at org-drawer-regexp)
                  (let* ((start (1- (match-beginning 0)))
                         (limit
                          (save-excursion
                            (outline-next-heading)
                            (point)))
                         (msg (format
                               (concat
                                "org-cycle-hide-drawers:  "
                                "`:END:`"
                                " line missing at position %s")
                               (1+ start))))
                    (if (re-search-forward "^[ \t]*:END:" limit t)
                        (outline-flag-region start (line-end-position) t)
                      (user-error msg))))))))))
    :config
    (advice-add 'org-srs-log-hide-drawer
                :after (lambda (&rest _ignore)
                         (my/org-srs-cycle-hide-drawers 'all)))))
#+end_src

#+RESULTS:
: org-srs-review-rate-again

**** fsrs

#+begin_src emacs-lisp
(use-package fsrs :defer t)
#+end_src

*** org-sticky-header

This package displays in the header-line the Org heading for the node that's
at the top of the window. This way, if the heading for the text at the top of
the window is beyond the top of the window, you don't forget which heading the
text belongs to.

#+begin_src emacs-lisp
(use-package org-sticky-header
  :commands org-sticky-header-mode)
#+end_src

*** org-superstar

Prettify headings and plain lists in Org mode. [[https://github.com/integral-dw/org-superstar-mode?tab=readme-ov-file][org-superstar]] is a direct
descendant of ‘[[https://github.com/sabof/org-bullets][org-bullets]]’, with most of the code base completely rewritten.
Currently, this package supports:

- Prettifying Org heading lines by:
  - replacing trailing bullets by UTF-8 bullets^{a)}
  - hiding leading stars^{b)}, customizing their look^{(new!)} or removing them from
    vision^{(new!)}
  - applying a custom face to the header bullet^{d)}
  - applying a custom face to the leading bullets^{(new!)}
  - making inline tasks (see =org-inlinetask.el= ) more fancy by:
    - using double-bullets for inline tasks
    - applying a custom face to the marker star of inline tasks^{(new!)}
    - using a special bullet for the marker star^{(new!)}
    - introducing an independent face for marker stars^{(new!)}
  - (optional) using special bullets for =TODO=  keywords^{(new!)}
- Prettifying Org plain list bullets^{(new!)} by:
  - replacing each bullet type ( =*=, =+= and =-= ) with UTF-8 bullets^{c)}
  - applying a custom face to item bullets
- Gracefully degrading features when viewed from terminal

1. These features are mostly the same as in =org-bullets-mode=.

2. Plain hiding is now left to Org mode and the associated variable
   =org-hide-leading-stars= as well as =org-hide=, as suggested by [[https://github.com/Kaligule][Kaligule]].

3. =org-superstar-mode= tries to prettify in a context-sensitive fashion: It
   strives to only recognize item bullets which are really *meant* to be item
   bullets. Your =SRC= blocks are safe!

4. Instead of providing the symbol of an existing face in a variable to
   replace Org’s usual title face(s) for the UTF-8 character, superstar merges
   a custom face with the face that would have been used, allowing the user to
   inherit the level-dependent default look.

#+begin_src emacs-lisp
(use-package org-superstar
  :commands (org-superstar-mode))
#+end_src

*** org-tidy

#+begin_src emacs-lisp
(use-package org-tidy
  :after (org)
  :bind ("C-c n P" . org-tidy-mode)
  :custom
  (org-tidy-properties-style 'fringe))
#+end_src

*** COMMENT org-timeline

[[https://github.com/Fuco1/org-timeline][org-timeline.el]] adds a graphical view of the agenda after the last agenda
line. By default the display starts at 5 AM today and goes up to 4 AM next day
(this covers 24 hours).

Scheduled tasks or tasks with time ranges are rendered in the display with
=org-timeline-block= face. Clocked entires are displayed in =org-timeline-clocked=
face. The background of timeslots which are in the past is highlighted with
=org-timeline-elapsed= face.

You can use custom color for a task by adding the property =TIMELINE_FACE= with
either a string which is a color name or a list which specifies the face
properties or a symbol which is taken to be a face name.

#+begin_src emacs-lisp
(use-package org-timeline
  :after org
  :custom
  (org-timeline-start-hour 7)
  :functions (org-timeline-insert-timeline)
  :preface
  (defun my/org-timeline-insert-blank (&rest _)
    (save-excursion
      (goto-char (point-max))
      (insert ?\n)))
  :init
  (add-hook 'org-agenda-finalize-hook 'org-timeline-insert-timeline :append)
  :config
  (advice-add 'org-timeline-insert-timeline
              :before #'my/org-timeline-insert-blank))
#+end_src

*** org-table-color

#+begin_src emacs-lisp
(use-package org-table-color
  :commands (org-table-color))
#+end_src

*** org-table-highlight

[[https://github.com/llcc/org-table-highlight][org-table-highlight]] provides utilities to highlight columns and rows in
Org-mode tables. It supports cycling through color palettes, clearing
highlights, and working with both column and row overlays.

#+begin_src emacs-lisp
(use-package org-table-highlight
  :bind
  (:map
   org-mode-map
   :prefix-map
   my/org-table-highlight-map
   :prefix "C-x T"
   ("c" . org-table-highlight-column)
   ("r" . org-table-highlight-row)
   ("x" . org-table-highlight-restore)
   ("C" . org-table-highlight-clear-column-highlights)
   ("R" . org-table-highlight-clear-row-highlights)
   ("X" . org-table-highlight-clear-all-highlights)
   ("s" . org-table-highlight-save-metadata)
   ("a" . org-table-highlight-apply-buffer-metadata))
  :custom
  (org-table-highlight-color-palette
   (list palette-fuschia-dark
         palette-cyan-dark
         palette-yellow-dark
         palette-orange-dark)))
#+end_src

*** org-transclusion

[[https://github.com/nobiot/org-transclusion][Org-transclusion]] lets you insert a copy of text content via a file link or ID
link within an Org file. It lets you have the same content present in
different buffers at the same time without copy-and-pasting it. Edit the
source of the content, and you can refresh the transcluded copies to the
up-to-date state. Org-transclusion keeps your files clear of the transcluded
copies, leaving only the links to the original content.

Usage scenario:

1. Press =C-c C-x T= in an Org-mode buffer.
2. Use =C-c n A= to add transclusions.

#+begin_src emacs-lisp
(use-package org-transclusion
  :after org
  :bind (:map
         org-mode-map
         ("C-c C-x T" . org-transclusion-mode)
         :map
         my-ctrl-c-n-map
         ("A" . my/org-transclusion-insert)
         ("M" . org-transclusion-make-from-link))
  :preface
  (defun my/org-transclusion-insert ()
    (interactive)
    (save-excursion
      (call-interactively #'org-roam-node-insert))
    (insert "#+transclude: ")))
#+end_src

*** COMMENT org-upcoming-modeline

[[https://github.com/unhammer/org-upcoming-modeline][org-upcoming-modeline]] shows you the next upcoming org appointment in your
modeline.

You can left-click on it to go to it, right-click for a menu of actions,
middle-click to temporarily hide it.

#+begin_src emacs-lisp
(use-package org-upcoming-modeline
  :after org
  :config
  (org-upcoming-modeline-mode))
#+end_src

*** org-web-tools

#+begin_src emacs-lisp
(use-package org-web-tools
  :bind (("C-c w C-y"   . org-web-tools-insert-link-for-url)
         ("C-c w C-M-y" . org-web-tools-insert-web-page-as-entry)))
#+end_src

*** org-yasnippet

#+begin_src emacs-lisp
(use-package org-yasnippet
  :no-require t
  :after (org yasnippet)
  :hook
  (org-mode . yas-minor-mode-on)
  (org-tab-after-check-for-cycling . yas-expand)
  :preface
  (defun my/run-capture-finalize-for-org-items ()
    (save-excursion
      (save-restriction
        (narrow-to-region yas-snippet-beg yas-snippet-end)
        (goto-char (point-min))
        (when (search-forward ":PROPERTIES:" nil t)
          (run-hooks 'org-capture-before-finalize-hook)))))
  :config
  (add-hook 'yas-after-exit-snippet-hook
            #'my/run-capture-finalize-for-org-items))

#+end_src

*** orgit

#+begin_src emacs-lisp
(use-package orgit
  :after org)
#+end_src

**** orgit-forge

#+begin_src emacs-lisp
(use-package orgit-forge
  :after (org orgit))
#+end_src

*** ox

**** ox-gfm

#+begin_src emacs-lisp
(use-package ox-gfm
  :after org)
#+end_src

**** ox-md

#+begin_src emacs-lisp
(use-package ox-md
  :after org)
#+end_src

**** ox-pandoc

#+begin_src emacs-lisp
(use-package ox-pandoc
  :after org
  :preface
  (defun markdown-to-org-region (start end)
    "Convert region from markdown to org, replacing selection"
    (interactive "r")
    (shell-command-on-region start end "pandoc -f markdown -t org" t t)))
#+end_src

**** ox-slack

This is a simple exporter backend for [[https://orgmode.org/][Emacs org-mode]], derived from the builtin
markdown exporter & its derived backend [[https://github.com/larstvei/ox-gfm][ox-gfm.el]]. It produces simple text
output suitable for pasting into a [[https://slack.com/][Slack]] client. It works like most export
backends, with two main differences:

- At present, *this exporter is not added to the export dispatcher*. It's hard
  to see when it would be useful to make slack-formatted files. Instead,
- This package provides the interactive function
  =org-slack-export-to-clipboard-as-slack=, which copies the region to the
  kill-ring in slack format. From there it should be easy to paste the
  resultant text into your slack client.
- On the slack side, you can quickly apply the formatting by pressing Ctrl
  Shift F (Linux/Windows) or ⌘ Shift F (Mac).

Since Slack syntax is much poorer than Org's, some arbitrary choices have been
made about how to degrade it. Headlines are exported as *bolded text* on their
own lines, for instance.

#+begin_src emacs-lisp
(use-package ox-slack
  :after org
  :bind
  ("C-c w k"   . org-slack-export-to-clipboard-as-slack)
  ("C-c w M-w" . org-slack-export-to-clipboard-as-slack)
  :preface
  (defun my/org-fixup-slack-link (old-func link contents info)
    (let ((text (funcall old-func link contents info)))
      (if (string-match "\\*\\(.+?\\)\\* (\\(.+\\))" text)
          (format "[%s](%s)" (match-string 1 text) (match-string 2 text))
        text)))
  :config
  (advice-add 'org-slack-export-to-clipboard-as-slack :after #'deactivate-mark)
  (advice-add 'org-slack-link :around #'my/org-fixup-slack-link))
#+end_src

**** COMMENT ox-texinfo-plus

#+begin_src emacs-lisp
(use-package ox-texinfo-plus
  :after org)
#+end_src

**** ox-whatsapp

[[https://github.com/Hugo-Heagren/ox-whatsapp][ox-whatsapp]] is a simple WhatsApp markup exporter for org mode.

This exporter is derived from the ASCII exporter which comes with org-mode. It
behaves exactly like that exporter except in cases where that differs from the
[[https://faq.whatsapp.com/539178204879377][markup supported by WhatsApp]].

By default, you can access it in the export dispatcher under the =w= key, itself
under the =t= menu.

#+begin_src emacs-lisp
(use-package ox-whatsapp
  :after org)
#+end_src

*** citar

#+begin_src emacs-lisp
(use-package citar
  :after oc
  :bind (:map
         my-ctrl-c-n-map
         ("N" . citar-create-note))
  :custom
  (org-cite-global-bibliography
   (list "~/org/resource/bibliography.bib"
         "~/org/resource/kadena.bib"))
  (citar-bibliography org-cite-global-bibliography)
  :config
  (setq citar--multiple-setup '("M-RET" . "RET"))

  (use-package citar-capf
    :hook
    (LaTeX-mode . citar-capf-setup)
    (org-mode . citar-capf-setup)))
#+end_src

**** citar-embark

#+begin_src emacs-lisp
(use-package citar-embark
  :after (citar embark)
  :diminish citar-embark-mode
  :custom
  (citar-at-point-function 'embark-act)
  :config
  (citar-embark-mode))
#+end_src

**** citar-org

#+begin_src emacs-lisp
(use-package citar-org
  :after (oc citar)
  :bind
  (:map org-mode-map
        ("C-c b i" . citar-insert-citation)
        ("C-c b r" . citar-insert-reference)
        ("C-c b o" . citar-open-notes))
  :custom
  (citar-notes-paths citar-bibliography)
  (citar-open-note-function 'orb-citar-edit-note)
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  :config
  (eval-when-compile
    (require 'vertico-multiform))
  (add-all-to-list 'vertico-multiform-commands
                   '(citar-insert-citation)
                   '(citar-insert-reference)
                   '(citar-open-notes)))
#+end_src

**** citar-org-roam

#+begin_src emacs-lisp
(use-package citar-org-roam
  :after (citar-org org-roam)
  :diminish citar-org-roam-mode
  :custom
  (citar-org-roam-subdir nil)
  :config (citar-org-roam-mode))
#+end_src

**** COMMENT citar-org-node

#+begin_src emacs-lisp
(use-package citar-org-node
  :after (:any citar org-node)
  :bind (:map org-mode-map
              ("C-c b a" . citar-org-node-add-refs)
              ("C-c b o" . citar-org-node-open-resource))
  :config
  (citar-org-node-mode 1))
#+end_src

*** toc-org

#+begin_src emacs-lisp
(use-package toc-org
  :hook
  (org-mode . toc-org-mode)
  :preface
  (defun my-equalize-newlines-advice (orig-fun &rest args)
    "Leave equal amount of newlines in the result of ORIG-FUN."
    (let* ((result (apply orig-fun args))
           (trimmed (string-trim result))
           (newline-count 1))           ; can be an external variable
      (concat
       (make-string newline-count ?\n)
       trimmed
       (make-string newline-count ?\n))))
  :config
  (advice-add 'toc-org-hrefify-toc :around #'my-equalize-newlines-advice))
#+end_src

*** COMMENT asana

#+begin_src emacs-lisp
(use-package asana
  :load-path "lisp/emacs-asana"
  :commands asana-org-sync-tasks
  :defines (asana-token)
  :custom
  (asana-tasks-org-file org-constants-work-asana-path)
  :config
  (setq asana-token
        (lookup-password "pat.asana.com" "john@kadena.io" 80)))
#+end_src

*** COMMENT calfw

#+begin_src emacs-lisp
(use-package calfw
  :bind (("C-c A" . my-calendar)
         :map cfw:calendar-mode-map
         ("M-n" . cfw:navi-next-month-command)
         ("M-p" . cfw:navi-previous-month-command)
         ("j"   . cfw:navi-goto-date-command)
         ("g"   . cfw:refresh-calendar-buffer))
  :commands cfw:open-calendar-buffer
  :functions (cfw:open-calendar-buffer
              cfw:refresh-calendar-buffer
              cfw:org-create-source
              cfw:cal-create-source)
  :custom
  (cfw:read-date-command
   (lambda nil
     (interactive)
     (let
         ((xs
           (decode-time
            (org-time-string-to-time
             (org-read-date)))))
       (list
        (nth 4 xs)
        (nth 3 xs)
        (nth 5 xs)))))
  :preface
  (defun my-calendar ()
    (interactive)
    (let ((buf (get-buffer "*cfw-calendar*")))
      (if buf
          (pop-to-buffer buf nil)
        (cfw:open-calendar-buffer
         :contents-sources
         (list (cfw:org-create-source "Dark Blue")
               (cfw:cal-create-source "Dark Orange"))
         :view 'two-weeks))))

  :config
  (use-package calfw-cal)

  (use-package calfw-org
    :config
    (setq cfw:org-agenda-schedule-args '(:deadline :timestamp :sexp)))

  (setq cfw:fchar-junction         ?╋
        cfw:fchar-vertical-line    ?┃
        cfw:fchar-horizontal-line  ?━
        cfw:fchar-left-junction    ?┣
        cfw:fchar-right-junction   ?┫
        cfw:fchar-top-junction     ?┯
        cfw:fchar-top-left-corner  ?┏
        cfw:fchar-top-right-corner ?┓))
#+end_src

**** COMMENT calfw-cal

#+begin_src emacs-lisp
(use-package calfw-cal
  :after (calfw))
#+end_src

**** COMMENT calfw-org

#+begin_src emacs-lisp
(use-package calfw-org
  :after (calfw)
  :config
  (setq cfw:org-agenda-schedule-args '(:deadline :timestamp :sexp)))
#+end_src

*** org-autolist

[[https://github.com/calvinwyoung/org-autolist][org-autolist]] makes org-mode lists behave more like lists in non-programming
editors such as Google Docs, MS Word, and OS X Notes.

When editing a list item, pressing "Return" will insert a new list item
automatically. This works for both bullet points and checkboxes, so there's no
need to think about whether to use =M-<return>= or =M-S-<return>=. Similarly,
pressing "Backspace" at the beginning of a list item deletes the bullet /
checkbox, and moves the cursor to the end of the previous line.

#+begin_src emacs-lisp
(use-package org-autolist
  :load-path "lisp/org-autolist"
  :diminish org-autolist-mode
  :hook (org-mode . org-autolist-mode))
#+end_src

*** org-margin

#+begin_src emacs-lisp
(use-package org-margin
  :after (org)
  :commands (org-margin-mode))
#+end_src

*** org-mru-clock

#+begin_src emacs-lisp
(use-package org-mru-clock
  :after (org)
  :bind* (("C-c C-x i" . org-mru-clock-in)
          ("C-c C-x C-j" . org-mru-clock-select-recent-task))
  :custom
  (org-mru-clock-how-many 100))
#+end_src

*** org-literate-calc

#+begin_src emacs-lisp
(use-package org-literate-calc
  :no-require t
  :bind (:map org-mode-map
              ("C-c C-x *" . literate-calc-minor-mode)
              ("C-c C-x C-*" . literate-calc-kill-result)))
#+end_src

** Games

*** 2048-game

#+begin_src emacs-lisp
(use-package 2048-game
  :commands 2048-game
  :bind (:map 2048-mode-map
              ("M-<left>" . my-2048-repeat-down-and-left)
              ("M-<right>" . my-2048-repeat-down-and-right))
  :hook
  (2048-mode . (lambda () (text-scale-adjust 5)))
  :config
  (defun 2048-print-board ()
    "Wipes the entire field, and prints the board."
    (let ((inhibit-read-only t))
      (erase-buffer)
      (dotimes (row *2048-rows*)

        ;;print the separator line on top of, and between cells
        (if (= row 0)
            (insert "┌———————")
          (insert "├———————"))
        (dotimes (col (1- *2048-columns*))
          (if (= row 0)
              (insert "┬———————")
            (insert "┼———————")))
        (if (= row 0)
            (insert "┐")
          (insert "┤"))
        (insert "\n")

        ;;print the empty line above numbers
        (dotimes (col *2048-columns*)
          (insert "│")
          (let ((current-value (2048-get-cell row col)))
            (insert (2048-empty-tile current-value))))
        (insert "│")
        (insert "\n")

        ;; print the number tiles
        (dotimes (col *2048-columns*)
          (insert "│")
          (let ((current-value (2048-get-cell row col)))
            (insert (2048-tile current-value))))
        (insert "│")
        (insert "\n")

        ;;print the empty line below numbers
        (dotimes (col *2048-columns*)
          (insert "│")
          (let ((current-value (2048-get-cell row col)))
            (insert (2048-empty-tile current-value))))
        (insert "│")
        (insert "\n"))

      ;;print the separator line on the bottom of the last row.
      (insert "└———————")
      (dotimes (col (1- *2048-columns*))
        (insert "┴———————"))
      (insert "┘\n")
      (insert "\n")

      (let ((score-width (if (= 0 *2048-score*)
                             1
                           (ceiling (log *2048-score* 10)))))
        (insert (format "%10s%s%s\n" "/" (make-string (+ 9
                                                         score-width)
                                                      ?\=) "\\"))
        (insert (format "%10s %s %d %s\n" "│" "Score:" *2048-score* "│"))
        (insert (format "%10s%s%s\n" "\\" (make-string (+ 9
                                                          score-width)
                                                       ?\=) "/")))
      (insert "\n")

      (2048-print-help)

      (insert "\n")

      ;; print score and history
      (insert (format "%10s%s%s\n" "/" (make-string 13 ?\=) "\\"))
      (insert (format "%24s\n" "│ HIGH SCORES │"))
      (insert (format "%10s%s%s\n" "\\" (make-string 13 ?\=) "/"))
      (insert "\n")
      (insert (format "%8s  %7s  %7s     %4s\n" "Score" "Hi-Tile" "Date" "Duration"))
      (mapc (lambda (x)
              (insert (format "%8d  %7d  %10s  %s\n"
                              (elt x 0) (elt x 1) (elt x 2)
                              (format-time-string "%H:%M:%S" (elt x 3) t))))
            ,*2048-history*)

      (goto-char (point-min))))

  (defun my-2048-repeat-down-and-left ()
    (interactive)
    (let (prev-board)
      (while (not (equal prev-board *2048-board*))
        (setq prev-board (cl-copy-seq *2048-board*))
        (2048-down)
        (2048-left))))

  (defun my-2048-repeat-down-and-right ()
    (interactive)
    (let (prev-board)
      (while (not (equal prev-board *2048-board*))
        (setq prev-board (cl-copy-seq *2048-board*))
        (2048-down)
        (2048-right)))))
#+end_src

*** chess

#+begin_src emacs-lisp
(use-package chess
  :load-path "lisp/chess"
  :commands chess)
#+end_src

**** chess-ics

#+begin_src emacs-lisp
(use-package chess-ics
  :after chess
  :commands chess-ics
  :config
  (defun chess ()
    (interactive)
    (chess-ics "freechess.org" 5000 "jwiegley"
               (lookup-password "freechess.org" "jwiegley" 80))))
#+end_src

*** malyon

#+begin_src emacs-lisp
(use-package malyon
  :commands malyon
  :custom
  (malyon-stories-directory "~/doc/games")
  :config
  (defun replace-invisiclues ()
    (interactive)
    (query-replace-regexp
     "^\\( +\\)\\(\\([A-Z]\\)\\. \\)?\\(.+\\)"
     (quote (replace-eval-replacement
             concat "\\1\\2" (replace-quote (rot13 (match-string 4)))))
     nil (if (use-region-p) (region-beginning))
     (if (use-region-p) (region-end)) nil nil)))
#+end_src

*** minesweeper

#+begin_src emacs-lisp
(use-package minesweeper
  :commands minesweeper)
#+end_src

* Finalization

#+begin_src emacs-lisp
(report-time-since-load)

;; Local Variables:
;; byte-compile-warnings: (not docstrings lexical noruntime)
;; End:
#+end_src
