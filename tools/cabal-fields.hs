{-# LANGUAGE OverloadedStrings #-}
module Main where

import           Data.List (intersperse, sort)
import           Data.Monoid ((<>))
import           Data.Text (Text)
import qualified Data.Text as T
import           Data.Text.Lazy.Builder (Builder)
import qualified Data.Text.Lazy.Builder as TB
import qualified Data.Text.Lazy.Builder.Int as TB
import qualified Data.Text.Lazy.IO as LT
import           Distribution.PackageDescription.Parse
import           Distribution.Simple.Utils (cabalVersion)
import           Distribution.Version (versionNumbers)

type SectionField = (Text, [Text])
type FieldValue = (Text, [Text])

sectionFields :: [SectionField]
sectionFields =
    [ ("benchmark", fields benchmarkFieldDescrs)
    , ("executable", fields executableFieldDescrs)
    , ("flag", fields flagFieldDescrs)
    , ("library", fields libFieldDescrs)
    , ("pkgdescr", fields pkgDescrFieldDescrs)
    , ("source-repository", fields sourceRepoFieldDescrs)
    , ("test-suite", fields testSuiteFieldDescrs)
    ]
  where
    fields = sort . map (T.pack . fieldName)

fieldValues :: [FieldValue]
fieldValues =
    [ ("build-type", ["Simple", "Configure", "Make", "Custom"])
    , ("benchmark-type", ["exitcode-stdio-1.0"])
    , ("testsuite-type", ["exitcode-stdio-1.0", "detailed-1.0"])
    , ("sourcerepo-type", [ "darcs", "git", "svn", "cvs", "mercurial", "hg",
                            "bazaar", "bzr", "arch", "monotone"])
    ]

main :: IO ()
main = LT.putStr $ TB.toLazyText $ mconcat
    [ header
    , mconcat $ map defField sectionFields
    , defSectFieldAlist $ filter (/= "pkgdescr") $ map fst sectionFields
    , defSections
    , mconcat $ map defFieldValue fieldValues
    , footer
    ]

header :: Builder
header = mconcat
    [ ";;; company-cabal-fields.el -- cabal field definitions.\n"
    , ";;\n"
    , ";;; Commentary:\n"
    , ";;\n"
    , ";; Automatically generated by tools/cabal-fields.hs with Cabal-"
    , version cabalVersion
    , ".\n;;\n"
    , ";;; Code:\n\n"
    ]
  where
    version = mconcat . intersperse "." . map TB.decimal . versionNumbers

footer :: Builder
footer = mconcat
    [ "(provide 'company-cabal-fields)\n"
    , ";;; company-cabal-fields.el ends here\n"
    ]

defField :: SectionField -> Builder
defField (sect, fields) = mconcat
    [ "(defconst company-cabal--"
    , sectMod sect
    , "-fields\n  (mapcar\n   (lambda (x) (propertize x :type 'field))\n   '("
    , mconcat $ intersperse "\n     " $ map string fields
    , ")))\n\n"
    ]

defSectFieldAlist :: [Text] -> Builder
defSectFieldAlist sects = mconcat
    [ "(defconst company-cabal--section-field-alist\n"
    , "  (list "
    , mconcat $ intersperse "\n        " $ map consSectField sects
    , "))\n\n"
    ]
  where
    consSectField sect = mconcat
        [ "(cons \""
        , TB.fromText sect
        , "\" company-cabal--"
        , sectMod sect
        , "-fields)"
        ]

defSections :: Builder
defSections = mconcat
    [ "(defconst company-cabal--sections\n"
    , "  (mapcar (lambda (cs) (propertize  (car cs) :type 'section))\n"
    , "          company-cabal--section-field-alist))\n\n"
    ]

defFieldValue :: FieldValue -> Builder
defFieldValue (field, values) = mconcat
    [ "(defconst company-cabal--"
    , TB.fromText field
    , "-values\n"
    , "  (mapcar (lambda (x) (propertize x :type 'value))\n"
    , "          '("
    , is $ map string values
    , ")))\n\n"
    ]
  where
    -- XXX
    is []                      = mempty
    is [x]                     = x
    is (x:xs) | x == "\"bzr\"" = x <> "\n            " <> is xs
              | otherwise      = x <> " "  <> is xs

string :: Text -> Builder
string t = "\"" <> TB.fromText t <> "\""

sectMod :: Text -> Builder
sectMod "test-suite"        = "testsuite"
sectMod "source-repository" = "sourcerepo"
sectMod sect                = TB.fromText sect
